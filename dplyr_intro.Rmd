---
title: "dplyr入門"
date: '2020-04-20'
categories: []
tags: ["統計学", "R", "データハンドリング"]
markup: "mmark"
---

## 参考資料

* [dplyr of Datacamp](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial): 実はこんなもん読むよりこっちのホームページへアクセスして実習した方が100倍いいと思う。
* [Introduction to dplyr](https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html)

---

dplyrはR業界の神様、[Hadley Wickham](http://hadley.nz/)が作成したRのパッケージである。 R内蔵の関数でもデータの管理はできるが、dplyrを使うと生産性は何倍も向上する。

dplyrの主な使い道は以下のとおり

```{r, echo = FALSE}
library(knitr)
library(kableExtra)

data.frame(関数名 = c("`filter`", "`arrange`", "`select`", 
                      "`mutate`", "`summarise`"),
           機能 = c("ある条件に合ったケースだけを抽出",
                    "データをある基準に合わせて揃える",
                    "指定した変数のみを抽出",
                    "計算した結果を新しい変数として定義",
                    "データの要約")) %>%
    kable() %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                        "responsive"),
                  full_width = FALSE)
```

これらの機能を最大限発揮するために、いくつかの良き友達がいる

```{r, echo = FALSE, results='asis'}
data.frame(関数名 = c("`group_by`", "`%>%` (注)"),
           機能 = c("データのグループ化",
                    "複数の処理を逐次的に実行")) %>%
    kable(escape = FALSE, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                        "responsive"),
                  full_width = FALSE)
```

※なぜか2行目は`%&gt;%`と表示されていますが、正しいのは`%>%`です。

---

## 実習の準備

まずは、dplyrのインストールと読み込みである。dplyrはCRANに登録されているので、`install.packages()`でインストールできる。

```{r, eval = FALSE}
install.packages("dplyr")
```

```{r}
library(dplyr)
```

実習用データは有名な`nycflights13`データを使う。これはニューヨーク出発の航空便のデータで、336,776のケースが含まれている。インストールされていない場合、`install.packages("nycflights13")`でインストールしておこう。

まず、データを読み込み、中身を見てみよう。

```{r}
library(nycflights13)

head(flights) # データの中身を見る(最初の6行だけ)
```


---
    
### filter()

`filter()`はある条件に合ったケースのみを抽出する関数である。使い方は`filter(データ, 条件)`である。ここでデータは`flights`である。試しに3月のデータだけを抽出してみる。月は`month`変数である。

```{r}
filter(flights, month == 3)
```

ここで注意すべきなのは`month = 3`ではなく、`month == 3`ということだ。 ほとんどの言語で`=`は代入を意味する。「同じ」を意味するわけではない。

簡単にまとめてみよう

```{r, echo = FALSE, results='asis'}
data.frame(演算子 = c("A == B", "A < B", "A > B",
                      "A <= B", "A >= B", "A != B"),
           意味 = c("AとBは同値",
                    "AはBより小さい(未満)",
                    "AはBより大きい(超過)",
                    "AはBより小さいか、同じ(以下)",
                    "AはBより大きいか、同じ(以上)",
                    "AとBは同じではない")) %>%
    kable(escape = FALSE, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                        "responsive"),
                  full_width = FALSE)
```

先ほどの例では3月(`month == 3`)のデータを抽出したが、もっと条件を絞ることもできる。

たとえば、3月10日に絞りたい場合の条件式は`month == 3 & day == 10`である。

```{r}
filter(flights, month == 3 & day == 10)
```

`&`はANDを意味する。もし、3月10日と11日のデータがほしいなるどうすればいいか。 この場合、OR表現が必要となる。ORは`|`と書く。

```{r}
filter(flights, month == 3 & (day == 10 | day == 11))
```

ここで条件式はANDとORの組み合わせになっている。簡単に表現すると「A and (B or C)」である。これは

* (AかつB) あるいは(AかつC)

を意味する。ちなみに以上のコマンドはもっと省略できる。

```{r}
filter(flights, month == 3 & (day == 10 | 11))
```

`day ==`を一回書くだけでも結果は同じ。ちなみに、OR演算の他の表現法もある。それは%in%である。 `A %in% (1, 2, 3, 4)`は「Aが1, 2, 3, 4どっちかに該当するか」を意味する。これを使って先のコマンドを書きなおしてみよう。

```{r}
filter(flights, month == 3 & (day %in% c(10, 11)))
```

やはり結果は変わらない。ちなみに、Rで複数の要素(数字でも文字でも)を並ぶときには`c()`を使う。ただし、一つのベクトルに数字が文字が混在されることはない。

このデータを使っては実習できないが、欠損値のあるケースを除去したい場合もあろう。 たとえば、`year`が欠損値になってるケースが除去したいなら`filter(flights, year == NA)`で良いだろうか。

実は違う。

この場合は`is.na(year)`と書く。理由は聞かないでほしい。

---

### arrange()

`arrange`はケースをある基準に合わせて並べ直す関数である。

特に意味はないが、データを`month`が小さい順に並べてみよう。

```{r}
arrange(flights, month)
```

もし、大きい方から表示したいなら`desc()`を使う。

```{r}
arrange(flights, desc(month))
```

次は「`month`の順で並べて、もし同じなら、次は`day`の順で並べたい」である。どうすればいいだろうか。実はこれも簡単だ。 条件式に次の基準となる変数名を入れるだけでいい。

```{r}
arrange(flights, month, day)
```

これを「`month`は12から1へ、`day`も31から1の順で並べたい」と思うなら

```{r}
arrange(flights, desc(month), desc(day))
```

最後に、欠損値(`NA`)は常に一番最後の行になる。

---

### select()

これは指定した変数のみを抽出する関数である。

まず、`year`, `month`, `day`列のみを抽出してみよう。

```{r}
select(flights, year, month, day)
```

このように隣接している変数同士なら`:`が使える。`year:day`は「`year`から`day`まで」という意味だ。

```{r}
select(flights, year:day)
```

`year`から`day`まで表示するのではなく`year`から`day`までを表示**させない**こともできる。その時に使うのが`-`である。

```{r}
select(flights, -(year:day))
```

`-year:day`でなく、`-(year:day)`であることに注意しよう。もし`:`を使わないなら`-c(year, month, day)`のように書く。

```{r}
select(flights, -c(year, month, day))
```

これだけでも`select()`は大変便利な関数だが、もっと高度な使い方もある。

まずは、そのリストから

```{r, echo = FALSE, results='asis'}
data.frame(演算子 = c("`starts_with(\"ABC\")`", 
                      "`ends_with(\"XYZ\")`", 
                      "`contains(\"LMN\")`",
                      "`matches(\"(.)\\\\1\")`", 
                      "`num_range(\"X\", 1:3)`"),
           意味 = c("変数名がABCで始まる変数",
                    "変数名がXYZで終わる変数",
                    "変数名にLMNが含まれている変数",
                    "正規表現パターン",
                    "X1, X2, X3")) %>%
    kable(escape = FALSE, format = "html") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed",
                                        "responsive"),
                  full_width = FALSE)
```

まずは、変数名が`dep`で始まる変数のみを抽出してみる。

```{r}
select(flights, starts_with("dep"))
```

続いて、変数名が`time`で終わるやつ

```{r}
select(flights, ends_with("time"))
```

最後に`_`(アンダーバー)が含まれているやつ

```{r}
select(flights, contains("_"))
```

`matches`に関しては私も詳しくない。正規表現を使う時はいつもネットを参照しているので…

`num_range`はこのデータでは使えないが`select(data, num_range("X", 3:5))`と書いたら、`data`というデータから`X3`, `X4`, `X5`のみを抽出せよという意味である。

個人的にあまり使わない機能だが、抽出後、新しい名前を付けることもできる。

```{r}
select(flights, 年 = year, 月 = month, 日 = day)
```

---

### mutate()

`mutate`はデータを計算し、その結果を新しい変数として格納する関数である。

使い方は`mutate(データ, 新しい変数名 = 計算式)`である。

とくに意味はないが、年(`year`)を2倍にし、`double_year`という変数として表示させてみよう。 (変数が多すぎて画面上に表示されないので、`year`から`day`まで抽出したデータ(`flights2`)を使う。)

```{r}
flights2 <- select(flights, year:day)
mutate(flights2, doble_year = year * 2)
```

ちゃんと`double_year`という列さ生成されて、`year`の2倍になっていることが分かる。

次は`year`、`month`、`day`を全部足し、`sum_data`と名付けよう。

```{r}
mutate(flights2, sum_date = year + month + day)
```

これ以外にも`cumsum`、`log`などの関数を使うこともできるし、平均値を引くことも出来る。

例として`day`から`day`の平均値を引いた値を`centered_day`として表示させてみる。

```{r}
mutate(flights2, centered_day = day - mean(day))
```

---

### summarise()

`summarise`は変数の平均、中央値、標準偏差などの統計量を表示させる関数である。

使い方は`summarise(データ, 新しい変数名 = 関数(変数))`である。

ここでは`flight`データに戻って`dep_time`と`arr_time`の平均値を見てみたい。 `dep_time`の平均値は`dep.mean`、`arr_time`の平均値は`arr.mean`としよう。

```{r}
summarise(flights, dep.mean = mean(dep_time), arr.mean = mean(arr_time))
```

`mean()`関数は欠損値が含まれていると`NA`を返すので、これを無視するように引数として`na.rm = TRUE`を付ける。

```{r}
summarise(flights, 
          dep.mean = mean(dep_time, na.rm = TRUE), 
          arr.mean = mean(arr_time, na.rm = TRUE))
```

ちゃんと出来た。

ここでの`mean()`以外に標準偏差(`sd()`)、IQR(`IQR()`)、中央値(`median()`)なども使える。 また、よく使われるものとしてケース数(`n()`)がある。

`summarise`関数はこれから紹介する`group_by`と一緒に使う時が多い。

---

## group_by()と%>%

### pipeline (%>%)

まずは`%>%`から紹介する。実はこれはdplyr独特のものではないが、dplyrとの相性がいい。

先ほど、`flights`の変数が多すぎて`year:day`のみ抽出し、`mutate`を使ったの例を考えてみる。 まずは`flights2`を作って、そこから`mutate`をした。まぁ、二行で終わったし、そこまで面倒くさくはないかも知れない。

それでは次の例を考えてみよう。

1. `year`, `month`, `day`, `dep_delay`, `carrier`を抽出
2. 3月のデータのみ抽出
3. `dep_delay`を60で割って、`sixty_delay`と名付ける。
4. `sixty_delay`が大きい順に並べ替える。

これをこれまでの方式でやってみよう。

```{r}
temp.flights <- select(flights, year:day, dep_delay, carrier)
temp.flights <- filter(temp.flights, month == 3)
temp.flights <- mutate(temp.flights, sixty_delay = dep_delay / 60)
arrange(temp.flights, desc(sixty_delay))
```

これを%>%を使って短めにする。

```{r}
flights %>% 
    select(year:day, dep_delay, carrier) %>% 
    filter(month == 3) %>% 
    mutate(sixty_delay = dep_delay / 60) %>%
    arrange(desc(sixty_delay))
```

まったく同じ結果が得られた。

これまで`select()`や`filter()`などの関数の最初の引数はデータ名だったが、それも要らなくなった。

`flights %>%`は「次に処理するデータは`flights`です」という意味だ。この例では`flights`データを使って`select()`をした。

`select()`で絞られたデータはそのまま次の`filter()`のデータとして使われる。

こんな感じでデータが次々へと伝達されていくのが`%>%`の素晴らしいところだ。

---

### group_by()

では、最後に`group_by()`を見てみよう。

これはある変数(ほとんどカテゴリカル変数)でデータをグループ化するものである。

たとえば各月の平均延着時間の見たいとする。

* `flights %>% filter(month == 1) %>% summarise(mean.delay = mean(dep_delay))`
* `flights %>% filter(month == 2) %>% summarise(mean.delay = mean(dep_delay))`
* …
* `flights %>% filter(month == 12) %>% summarise(mean.delay = mean(dep_delay))`

のように12回やってもいいが、`month`を基準にグループ化すると一瞬で終わる。

```{r}
flights %>% 
    group_by(month) %>% 
    summarise(mean.delay = mean(dep_delay, na.rm = TRUE))
```

これは`flights`データを`month`を基準にグループ化し、それぞれ`summarise()`した結果を表示する仕組みである。

航空会社(`carrier`)ごとに見てみよう。

```{r}
flights %>% 
    group_by(carrier) %>% 
    summarise(mean.delay = mean(dep_delay, na.rm = TRUE)) %>%
    arrange(desc(mean.delay))
```

F9社 (アメリカのFrontier Airlinesらしい)の平均延着時間が最も長いらしい。

グループは一つの変数でなく、複数の変数を指定することもできる。各航空会社の月別平均延着時間は

```{r}
flights %>% 
    group_by(carrier, month) %>%
    summarise(mean.delay = mean(dep_delay, na.rm = TRUE)) %>%
    arrange(desc(mean.delay))
```

もっとも延着時間が長いのは7月の9E社 (アメリカのEndeavor Air)のようだ。

---

大雑把にdplyrの機能を紹介したが、ここで紹介したよりも多くの機能があり、その便利さは我らの想像を超えるほどだ。 興味のある人は[Datacamp](https://www.datacamp.com/courses/dplyr-data-manipulation-r-tutorial)とか、他のチュートリアルを見てみるのもいいと思う。