<!DOCTYPE html>
<html lang="ja-jp">
    <head>
        <script defer src="/fa/fontawesome-all.js"></script>
        

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Rによるオブジェクト指向プログラミング入門</title>
        
        <style>

    html body {
        font-family: 'Noto Sans JP', sans-serif;
        background-color: white;
    }

    :root {
        --accent: darkred;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://www.jaysong.net/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto%20Sans%20JP">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/R.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/php.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/html.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.83.1" />
        

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=UA-96999602-1"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments)};
              gtag('js', new Date());
              gtag('config', 'UA-96999602-1');
              gtag('set', {'user_id': 'USER_ID'});
            </script>

            <script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-96999602-1', 'auto');
                ga('send', 'pageview');
            </script>
        

        <meta name="google-site-verification" content="QJouPRaPKBPU1jDp6VaBuFbVV5imTI-Aazl_ScJwVgU" />

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">Rによるオブジェクト指向プログラミング入門</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/about/">CV</a></li>
                            
                                <li><a href="/research/">Research</a></li>
                            
                                <li><a href="/teaching/">Teaching</a></li>
                            
                                <li><a href="/software/">Software</a></li>
                            
                                <li><a href="/notes/">Notes</a></li>
                            
                                <li><a href="/tutorial/">Tutorial</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:song@kansai-u.ac.jp"><i class="far fa-envelope"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://twitter.com/Tintstyle/"><i class="fab fa-twitter"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.facebook.com/tintstyle"><i class="fab fa-facebook"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.instagram.com/tintstyle/"><i class="fab fa-instagram"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/JaehyunSong/"><i class="fab fa-github"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2><center>Rによるオブジェクト指向プログラミング入門</center></h2>
        <h5><center></center></h5>
        <center>
<a href="https://www.jaysong.net/tags/r"><kbd class="item-tag">R</kbd></a>

<a href="https://www.jaysong.net/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0"><kbd class="item-tag">プログラミング</kbd></a>

</center>
    </div>

    <div align="start" class="content">
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<div id="はじめに" class="section level2">
<h2>はじめに</h2>
<ul>
<li>修正履歴
<ul>
<li>2021/05/24: 公開</li>
<li>2021/05/25: 一部修正</li>
</ul></li>
<li>以下の内容は現在執筆中の内容の一部となります。
<ul>
<li><a href="https://www.jaysong.net/RBook/">Song Jaehyun・矢内勇生『私たちのR: ベストプラクティスの探求』(E-book)</a></li>
<li>いきなり<strong>オブジェクト</strong>、<strong>関数</strong>、<strong>引数</strong>といった馴染みのない概念が出てきます。これらの概念に馴染みのない方は、予め「<a href="../rprogramming/">Rプログラミング入門の入門</a>」をご一読ください。</li>
</ul></li>
</ul>
<hr />
</div>
<div id="oop-intro" class="section level2">
<h2>まずは例から</h2>
<pre class="r"><code>Vector1 &lt;- c(1, 5, 3, 7, 9, 12, 5, 4, 10, 1)
Vector2 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;B&quot;, &quot;E&quot;, &quot;A&quot;, &quot;A&quot;, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;)</code></pre>
<pre class="r"><code>summary(Vector1)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    3.25    5.00    5.70    8.50   12.00</code></pre>
<pre class="r"><code>summary(Vector2)</code></pre>
<pre><code>##    Length     Class      Mode 
##        10 character character</code></pre>
<p>同じ<code>summary()</code>関数ですが、中のデータのタイプによって動きが異なります。これがオブジェクト指向プログラミングにおいて「<strong>多態性</strong> (polymorphism)」と呼ばれる概念です。同じ関数でもデータ型、またはデータ構造に応じて異なる動きをすることです。ここでのデータ型やデータ構造を、OOPでは「<strong>クラス</strong> (class)」と呼びます。クラスは<code>class()</code>関数で確認することができます。</p>
<pre class="r"><code>class(Vector1)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(Vector2)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p><code>Vector1</code>はnumeric、<code>Vector2</code>はcharacterです。もし、無理矢理に<code>Vector1</code>のクラスをcharacterに変えればどうなるでしょうか。クラスの変更は<code>class(オブジェクト名) &lt;- "クラス名"</code>でできます。一つのオブジェクトは複数のクラスが持てますが、これはOOPの「<strong>継承</strong> (inheritance)」概念に関係するので後で解説します。ここではまず、<code>Vector1</code>のクラスをcharacterにし、もう一回<code>summary()</code>を使ってみましょう。</p>
<pre class="r"><code>class(Vector1) &lt;- &quot;character&quot;
summary(Vector1)</code></pre>
<pre><code>##    Length     Class      Mode 
##        10 character character</code></pre>
<p>データの中身は変わっていませんが、<code>summary()</code>関数の動き方が変わりました。このように、Rで頻繁に使う<code>summary()</code>、<code>print()</code>、<code>plot()</code>などの関数は様々なクラスの対応しております。<code>lm()</code>関数を使った回帰分析の結果オブジェクトのクラス名は<code>lm</code>であり、その結果を見るためにも<code>summary()</code>関数を使います。他にも<code>plot(lmオブジェクト名)</code>をすると回帰診断の図が表示されます。これができないと、各クラスに応じた関数を作成する必要がありますね。numeric型専用の<code>numeric_print()</code>、character型専用の<code>character_print()</code>、lm型専用の<code>lm_plot()</code>など…、覚えなきゃいけない関数が増えてきます。ユーザー側でも大変ですが、コードを作成する側も大変です。実際、下の図<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>を見ると、プログラマーにとって最も大変な仕事は「名付け」であることが分かります。</p>
<p><img src="https://images.techhive.com/images/idge/imported/article/itw/2013/10/23/programmers_hardest_tasks-600x700-100521914-orig.jpg" /><!-- --></p>
<p>OOPの多態性にはこのような煩わしい仕事を軽減する機能があります。OOPにはここで紹介した多態性以外にも、「<strong>継承</strong> (inheritance)」、「<strong>カプセル化</strong> (encapsulation)」のような特徴があります。他にも人によっては「メッセージパッシング (message passing)」、「動的バインディング (dynamic binding)」などの特徴を述べたりしますが、詳しい話は専門書に譲りたいと思います。また、ここではRのS3クラスについて解説しますが、S3はカプセル化に対応しておりません。したがって、ここでは以下の概念について例と一緒に解説していきたいと思います。</p>
<ol style="list-style-type: decimal">
<li>オブジェクト (object)</li>
<li>クラス (class)</li>
<li>メソッド (method)</li>
<li>多態性 (polymorphism)　</li>
<li>継承 (inheritance)</li>
</ol>
<hr />
</div>
<div id="what-is-oop" class="section level2">
<h2>OOPとは</h2>
<div id="オブジェクト" class="section level3">
<h3>オブジェクト</h3>
<p>ここは『<a href="https://www.jaysong.net/RBook/">私たちのR</a>』の「<a href="https://www.jaysong.net/RBook/programming.html">Rプログラミングの基礎</a>」内容の繰り返しですが、<strong>オブジェクト (object)</strong> とはメモリに割り当てられた「何か」です。「何か」に該当するのは、ベクトル (vector)、行列 (matrix)、データフレーム (data frame)、リスト (list)、関数 (function) などがあります。一般的に、オブジェクトにはそれぞれ固有の（つまり、他のオブジェクトと重複しない）名前が付いています。</p>
<p>たとえば、1から5までの自然数の数列を</p>
<pre class="r"><code>my_vec1 &lt;- c(1, 2, 3, 4, 5)  # my_vec1 &lt;- 1:5 でも同じ</code></pre>
<p>のように<code>my_vec1</code>という名前のオブジェクトに格納します。オブジェクトに名前をつけてメモリに割り当てると、その後 <code>my_vec1</code> と入力するだけでそのオブジェクトの中身を読み込むことができるようになります。</p>
<p>ここで、次のように <code>my_vec1</code>の要素を2倍にする操作を考えてみましょう。</p>
<pre class="r"><code>my_vec1 * 2</code></pre>
<pre><code>## [1]  2  4  6  8 10</code></pre>
<p><code>my_vec1</code>は、先ほど定義したオブジェクトです。では<code>2</code>はどうでしょうか。<code>2</code>はメモリに割り当てられていないので、オブジェクトではないでしょうか。実は、この数字 <code>2</code> もオブジェクトです。計算する瞬間のみ<code>2</code>がメモリに割り当てられ、計算が終わったらメモリから消されると考えれば良いでしょう。むろん、<code>*</code> のような演算子でさえもオブジェクトです。</p>
</div>
<div id="クラス" class="section level3">
<h3>クラス</h3>
<p><strong>クラス (class)</strong> とはオブジェクトを特徴づける属性のことです。既に何度か <code>class()</code> 関数を使ってデータ型やデータ構造を確認しましたが、<code>class()</code>関数でオブジェクトのクラスを確認することができます。先ほど、<code>my_vec1</code>も<code>*</code>も<code>2</code>もオブジェクトであると説明しました。これらがすべてオブジェクトであるということは、何らかのクラス属性を持っているというこです。また、<code>class()</code>関数そのものもオブジェクトなので、何らかのクラスを持ちます。確認してみましょう。</p>
<pre class="r"><code>class(my_vec1)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(`*`)</code></pre>
<pre><code>## [1] &quot;function&quot;</code></pre>
<pre class="r"><code>class(2)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(class)</code></pre>
<pre><code>## [1] &quot;function&quot;</code></pre>
<p>統計分析をする際に、Rのクラスを意識することはあまりありません。しかし、Rでオブジェクト指向プログラミングを行う際は、オブジェクトのクラスを厳密に定義する必要があります。</p>
<p>Rにおける全てはオブジェクトであり、全てのオブジェクトは一つ以上クラスが付与されています。このクラスの考え方はプログラミング言語によって異なります。たとえば、Pythonの場合、一つのクラスの内部にはオブジェクトのデータ構造が定義され、そのクラスで使用可能な関数も含んでいます。また、データを含む場合もあります。このようにクラス内部にデータ、データ構造、専用関数などを格納することをカプセル化（encapsulation）と呼びます。</p>
<p>一方、Rの（S3）クラスにはクラス専用関数がクラス内で定義されておらず、データのみが格納されています。</p>
</div>
<div id="メソッドと多態性" class="section level3">
<h3>メソッドと多態性</h3>
<p>各クラス専用の関数をメソッド（method）と呼びます。たとえば、<code>summary()</code>関数を考えてみましょう。<code>lm()</code>関数を用いた回帰分析から得られたオブジェクトのクラスは<code>lm</code>であり、<code>c()</code>で作られた数値型ベクトルのクラスは<code>numeric</code>です。しかし、同じ<code>summary()</code>関数ですが、引数のクラスが<code>lm</code>か<code>numeric</code>かによって異なる動きを見せます。その例を見ましょう。</p>
<pre class="r"><code>X &lt;- c(1, 3, 5, 7, 9, 11)
Y &lt;- c(1, 2, 3, 7, 11, 13)
lm_class &lt;- lm(Y ~ X)
class(X)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>class(lm_class)</code></pre>
<pre><code>## [1] &quot;lm&quot;</code></pre>
<pre class="r"><code>summary(X)</code></pre>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##     1.0     3.5     6.0     6.0     8.5    11.0</code></pre>
<pre class="r"><code>summary(lm_class)</code></pre>
<pre><code>## 
## Call:
## lm(formula = Y ~ X)
## 
## Residuals:
##       1       2       3       4       5       6 
##  1.3333 -0.2667 -1.8667 -0.4667  0.9333  0.3333 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)   
## (Intercept)  -1.6333     1.0546  -1.549  0.19637   
## X             1.3000     0.1528   8.510  0.00105 **
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 1.278 on 4 degrees of freedom
## Multiple R-squared:  0.9477, Adjusted R-squared:  0.9346 
## F-statistic: 72.43 on 1 and 4 DF,  p-value: 0.001046</code></pre>
<p>このように同じ関数でもクラスによって異なる動作をすることを多態性 (polymorphism)と呼びます。しかし、実はRにおいてこれらの関数は別途作られた関数です。つまり、<code>summary()</code>という関数がクラスごとに定義されていることを意味します。<code>summary()</code>関数がどのクラスで使用可能かを確認するためには<code>methods()</code>関数を使います。</p>
<pre class="r"><code>methods(&quot;summary&quot;)</code></pre>
<pre><code>##  [1] summary.aov                    summary.aovlist*              
##  [3] summary.aspell*                summary.check_packages_in_dir*
##  [5] summary.connection             summary.data.frame            
##  [7] summary.Date                   summary.default               
##  [9] summary.ecdf*                  summary.factor                
## [11] summary.glm                    summary.infl*                 
## [13] summary.lm                     summary.loess*                
## [15] summary.manova                 summary.matrix                
## [17] summary.mlm*                   summary.nls*                  
## [19] summary.packageStatus*         summary.POSIXct               
## [21] summary.POSIXlt                summary.ppr*                  
## [23] summary.prcomp*                summary.princomp*             
## [25] summary.proc_time              summary.rlang_error*          
## [27] summary.rlang_trace*           summary.srcfile               
## [29] summary.srcref                 summary.stepfun               
## [31] summary.stl*                   summary.table                 
## [33] summary.tukeysmooth*           summary.warnings              
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>このように34種類のクラスに対して<code>summary()</code>関数が定義されています<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>。この関数の内部を確認するにはどうすれば良いでしょうか。関数のコードを見るときにはコンソール上に<code>関数名</code>を入力するだけです（<code>()</code>は不要）。</p>
<pre class="r"><code>summary</code></pre>
<pre><code>## function (object, ...) 
## UseMethod(&quot;summary&quot;)
## &lt;bytecode: 0x7ffd410f6528&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>しかし、多態性を持つ関数の内部を見ることはできません。そもそも<code>summary()</code>関数はクラスごとに異なるコードを持っているため、<code>summary</code>だけでは「どのクラスの<code>summary()</code>か」が分かりません。それでもRには<code>summary()</code>関数が存在し、それをジェネリック関数（generic function）と呼びます。内部には<code>UseMethod("summary")</code>のみが書かれており、これは「この<code>summary()</code>関数は様々なクラスのメソッドとして機能するぞ」と宣言しているだけです。各クラスに対応したメソッドの内部を見るには<code>getS3method("メソッド名", "クラス名")</code>を使います。<code>summary()</code>メソッドは<code>numeric</code>型が別途指定されていないため、<code>"defualt"</code>となります。</p>
<pre class="r"><code>getS3method(&quot;summary&quot;, &quot;default&quot;)</code></pre>
<pre><code>## function (object, ..., digits, quantile.type = 7) 
## {
##     if (is.factor(object)) 
##         return(summary.factor(object, ...))
##     else if (is.matrix(object)) {
##         if (missing(digits)) 
##             return(summary.matrix(object, quantile.type = quantile.type, 
##                 ...))
##         else return(summary.matrix(object, digits = digits, quantile.type = quantile.type, 
##             ...))
##     }
##     value &lt;- if (is.logical(object)) 
##         c(Mode = &quot;logical&quot;, {
##             tb &lt;- table(object, exclude = NULL, useNA = &quot;ifany&quot;)
##             if (!is.null(n &lt;- dimnames(tb)[[1L]]) &amp;&amp; any(iN &lt;- is.na(n))) dimnames(tb)[[1L]][iN] &lt;- &quot;NA&#39;s&quot;
##             tb
##         })
##     else if (is.numeric(object)) {
##         nas &lt;- is.na(object)
##         object &lt;- object[!nas]
##         qq &lt;- stats::quantile(object, names = FALSE, type = quantile.type)
##         qq &lt;- c(qq[1L:3L], mean(object), qq[4L:5L])
##         if (!missing(digits)) 
##             qq &lt;- signif(qq, digits)
##         names(qq) &lt;- c(&quot;Min.&quot;, &quot;1st Qu.&quot;, &quot;Median&quot;, &quot;Mean&quot;, &quot;3rd Qu.&quot;, 
##             &quot;Max.&quot;)
##         if (any(nas)) 
##             c(qq, `NA&#39;s` = sum(nas))
##         else qq
##     }
##     else if (is.recursive(object) &amp;&amp; !is.language(object) &amp;&amp; 
##         (n &lt;- length(object))) {
##         sumry &lt;- array(&quot;&quot;, c(n, 3L), list(names(object), c(&quot;Length&quot;, 
##             &quot;Class&quot;, &quot;Mode&quot;)))
##         ll &lt;- numeric(n)
##         for (i in 1L:n) {
##             ii &lt;- object[[i]]
##             ll[i] &lt;- length(ii)
##             cls &lt;- oldClass(ii)
##             sumry[i, 2L] &lt;- if (length(cls)) 
##                 cls[1L]
##             else &quot;-none-&quot;
##             sumry[i, 3L] &lt;- mode(ii)
##         }
##         sumry[, 1L] &lt;- format(as.integer(ll))
##         sumry
##     }
##     else c(Length = length(object), Class = class(object), Mode = mode(object))
##     class(value) &lt;- c(&quot;summaryDefault&quot;, &quot;table&quot;)
##     value
## }
## &lt;bytecode: 0x7ffd410f71d8&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>Rにはメソッドがクラス内部で定義されず、別途の<code>メソッド名.クラス名()</code>といった関数として作成されています。そしてジェネリック関数によって一つの関数の「ように」まとまっています。このように、ジェネリック関数経由でメソッドを呼び出すことをメソッド・ディスパッチ（method dispatch）と呼びます。</p>
</div>
<div id="継承" class="section level3">
<h3>継承</h3>
<p>クラスの継承 (inheritance)は一つのオブジェクトが2つ以上のクラスを持つ場合、子クラスが親クラスの特徴を継承することを意味します。たとえば、データフレームの拡張版とも言えるtibbleの場合、複数のクラスを持っています。</p>
<pre class="r"><code>library(tidyverse)
my_tibble &lt;- tibble(X = 1:5, Y = 1:5)
class(my_tibble)</code></pre>
<pre><code>## [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</code></pre>
<p>この<code>my_tibble</code>は<code>tlb_df</code>と<code>tbl</code>、<code>data.frame</code>といった3つのクラスを持っており、先に出てきたものが子クラス、後に出てくるものが親クラスです。<code>tbl</code>クラスと<code>data.frame</code>クラス両方に同じメソッドが定義されている場合、まず子クラスである<code>メソッド.tbl()</code>が実行されます。もし、子クラスにメソッドが定義されていない場合は<code>tbl</code>の親クラスである<code>data.frame</code>のメソッドが実行されます。tibbleはデータフレームとは異なるクラスのオブジェクトですが、データフレームと（ほぼ）同じ操作ができるのは、クラスが継承されるからです。クラスの継承ができないと、tibbleで使える全ての関数（列や行の抽出に使う<code>[</code>や<code>$</code>なども！）を全て一から定義する必要がありますが<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>、継承を使うことによってこのような手間を省くことが出来ます。</p>
<hr />
</div>
</div>
<div id="oop-in-r" class="section level2">
<h2>RにおけるOOP</h2>
<div id="オブジェクトに任意のクラスを付ける" class="section level3">
<h3>オブジェクトに任意のクラスを付ける</h3>
<p>クラスを変えるのは簡単です。<code>class(オブジェクト) &lt;- "新しいクラス名"</code>だけです。つまり、関数から何かの結果を返す直前にクラスを変更すれば良いです。</p>
<pre class="r"><code># 方法1
関数名 &lt;- function(...) {
  
  ...
  
  class(返すオブジェクト名) &lt;- &quot;任意のクラス名&quot;
  
  返すオブジェクト名 # return(オブジェクト名) でもOK
}</code></pre>
<p>たとえば、入力された2つのベクトル（<code>x</code>と<code>y</code>）をリスト構造とし、クラス名をScoreにするにはどうすれば良いでしょうか。</p>
<pre class="r"><code>Make_Score1 &lt;- function(x, y) {
  
  # resultリストにxとyを格納
  result &lt;- list(Score1 = x, Score2 = y)
  
  # 以下は attr(result, &quot;class&quot;) &lt;- &quot;Score&quot; も可
  class(result) &lt;- &quot;Score&quot; # resultのクラスを&quot;Score&quot;とする
  
  result                   # resultを返す
}

My_Score1 &lt;- Make_Score1(x = rnorm(10, 50, 10),
                         y = rnorm(10, 50, 10))

My_Score1 # My_Score1の内部を見る</code></pre>
<pre><code>## $Score1
##  [1] 45.53489 39.91481 37.76828 48.46681 43.80458 54.35289 48.14911 51.87457
##  [9] 59.99841 53.56369
## 
## $Score2
##  [1] 54.33540 59.34625 62.40577 52.49822 58.74732 49.65607 45.38859 37.71863
##  [9] 47.63174 49.48211
## 
## attr(,&quot;class&quot;)
## [1] &quot;Score&quot;</code></pre>
<pre class="r"><code>class(My_Score1) # My_Score1のクラスを表示</code></pre>
<pre><code>## [1] &quot;Score&quot;</code></pre>
<p>もう一つの方法は<code>structure()</code>関数を使う方法です。<code>sturcture()</code>の第1引数に返すオブジェクト名を指定し、<code>class = "クラス名"</code>引数でクラスを指定します。</p>
<pre class="r"><code>Make_Score2 &lt;- function(x, y) {
  
  # resultリストにxとyを格納
  result &lt;- list(Score1 = x, Score2 = y)
  
  structure(result, class = &quot;Score&quot;) # resultを返す
}

My_Score2 &lt;- Make_Score2(x = rnorm(10, 50, 10),
                         y = rnorm(10, 50, 10))

My_Score2 # My_Score2の内部を見る</code></pre>
<pre><code>## $Score1
##  [1] 39.40305 52.06861 32.06201 41.20193 55.10658 50.81768 46.09257 39.77138
##  [9] 39.71159 46.38220
## 
## $Score2
##  [1] 50.54684 30.23060 40.86734 43.04252 65.99603 41.81472 38.81934 41.92439
##  [9] 60.46046 64.11953
## 
## attr(,&quot;class&quot;)
## [1] &quot;Score&quot;</code></pre>
<pre class="r"><code>class(My_Score2) # My_Score2のクラスを表示</code></pre>
<pre><code>## [1] &quot;Score&quot;</code></pre>
<p>どれも同じ結果が得られます。</p>
</div>
<div id="メソッドの作り方" class="section level3">
<h3>メソッドの作り方</h3>
<div id="既に存在する関数名を使う" class="section level4">
<h4>既に存在する関数名を使う</h4>
<p>先ほど作成しましたScoreクラスのオブジェクトは長さ2のリスト構造をしています。これらの要素それぞれの平均値を求める場合は、<code>mean(My_Score1[[1]])</code>と<code>mean(My_Score1[[2]])</code>を実行する必要があります。なぜなら、<code>mean()</code>はベクトルしか計算できないからです。ここではScoreクラスのオブジェクト要素それぞれの平均値を求める関数<code>mean()</code>を作成します。</p>
<p>しかし、問題があります。それはRに<code>mean()</code>関数が既に存在することです。ここで勝手に上書きするのは良くないでしょう。ここで出てくるのがメソッドです。Scoreクラスのメソッドは「Scoreクラス専用の関数」であり、通常のベクトルならR内蔵の<code>mean()</code>関数を、ScoreクラスのオブジェクトならScoreのメソッドである<code>mean()</code>を実行します。</p>
<p>メソッドの作り方は<a href="https://www.jaysong.net/RBook/functions.html">自作関数</a>と同じです。相違点としては関数名を<code>関数名.クラス名</code>にすることです。Scoreクラスのメソッドしての<code>mean()</code>関数を定義する場合、関数名を<code>mean.Score</code>とします。</p>
<pre class="r"><code>mean.Score &lt;- function(x) {
  print(mean(x$Score1))
  print(mean(x$Score2))
}

mean(c(1, 3, 5, 7, 9, 11)) # R内蔵関数のmean()を使う</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>mean(My_Score1) # Scoreクラスのメソッドであるmean()を使う</code></pre>
<pre><code>## [1] 48.3428
## [1] 51.72101</code></pre>
<p><code>mean(c(1, 3, 5, 7, 9, 11))</code>は引数がnumeric型ベクトルであるため、既存の<code>mean()</code>関数が使用されます。一方、<code>mean(My_Score1)</code>は引数がScoreクラスであるため、<code>mean.Score()</code>が使用されます。このように<code>mean_Score()</code>のような別途の関数を作る必要なく、既存の関数名が利用できます。実際、<code>methods(mean)</code>を実行すると、Scoreクラスのメソッドとして<code>mean()</code>関数が用意されたことを確認できます。</p>
<pre class="r"><code>methods(mean)</code></pre>
<pre><code>## [1] mean.Date        mean.default     mean.difftime    mean.POSIXct    
## [5] mean.POSIXlt     mean.quosure*    mean.Score       mean.vctrs_vctr*
## see &#39;?methods&#39; for accessing help and source code</code></pre>
</div>
<div id="新しい関数を作る" class="section level4">
<h4>新しい関数を作る</h4>
<p>もし、新しい関数名を使用し、その関数が様々なクラスに対応するとしましょう。今回はCatというクラスを作ってみましょう。Catクラスの内部は長さ1のリストで、要素の名前は<code>Name</code>とし、ここには長さ1のcharacter型ベクトルが入ります。このCatクラスを作成する関数を<code>Make_Cat()</code>とします。</p>
<pre class="r"><code>Make_Cat &lt;- function(name) {
  
  # resultリストにxを格納
  result &lt;- list(Name = name)
  
  structure(result, class = &quot;Cat&quot;) # resultを返す
}

My_Cat &lt;- Make_Cat(name = &quot;矢内&quot;)
My_Cat</code></pre>
<pre><code>## $Name
## [1] &quot;矢内&quot;
## 
## attr(,&quot;class&quot;)
## [1] &quot;Cat&quot;</code></pre>
<pre class="r"><code>class(My_Cat)</code></pre>
<pre><code>## [1] &quot;Cat&quot;</code></pre>
<p>続いて、Catクラスに使う<code>my_func()</code>を作成します。<code>my_func()</code>はそもそも存在しない関数ですので、普通に<code>my_func &lt;- function()</code>で作成可能です。この関数はCatの<code>Name</code>の後ろに<code>": にゃーにゃー"</code>を付けて出力する関数です。実際にやってみましょう。</p>
<pre class="r"><code>my_func &lt;- function(name) {
  print(paste0(name$Name, &quot;: にゃーにゃー&quot;))
}

my_func(My_Cat)</code></pre>
<pre><code>## [1] &quot;矢内: にゃーにゃー&quot;</code></pre>
<p>しかし、<code>my_func()</code>をCatクラス以外にも使いたい場合はどうすればいいでしょうか。普通に<code>my_func.クラス名()</code>で良いでしょうか。確かにそうですが、その前に一つの手順が必要です。それは、<code>my_func()</code>をジェネリック関数として定義することです。この関数そのものは関数として機能はしませんが、「これから<code>my_func()</code>がいろんなクラスのメソッドとして使われるぞ」と予め決めてくれます。ジェネリック関数を作成しないと<code>関数名.クラス名</code>は定義できません。そこで使うのが<code>UseMethod()</code>です。第一引数はメソッド名、第二引数は任意の引数ですが、通常、<code>x</code>が使われます。また、第二の引数は省略可能で、<code>UseMethod("メソッド名")</code>でも動きます。</p>
<pre class="r"><code>my_func &lt;- function(x) {
  UseMethod(&quot;my_func&quot;, x)
}</code></pre>
<p>これからは<code>my_func.クラス名()</code>の関数を作るだけです。まず、Score型オブジェクトに対してはそれぞれの要素の平均値を出力するとします。</p>
<pre class="r"><code>my_func.Score &lt;- function(x) {
  print(mean(x$Score1))
  print(mean(x$Score2))
}

my_func.Cat &lt;- function(cat) {
  print(paste0(cat$Name, &quot;: にゃーにゃー&quot;))
}</code></pre>
<pre class="r"><code>methods(my_func)</code></pre>
<pre><code>## [1] my_func.Cat   my_func.Score
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p><code>my_func()</code>関数はScoreとCatといった2種類のクラスで使われることが確認できます。それでは問題なく作動するかを確認してみましょう。<code>My_Score1</code>と<code>My_Cat</code>を、それぞれ<code>my_func()</code>に渡します。</p>
<pre class="r"><code>my_func(My_Score1)</code></pre>
<pre><code>## [1] 48.3428
## [1] 51.72101</code></pre>
<pre class="r"><code>my_func(My_Cat)</code></pre>
<pre><code>## [1] &quot;矢内: にゃーにゃー&quot;</code></pre>
<p>同じ関数名でも、オブジェクトのクラスによって異なる処理が行われることが分かります。</p>
</div>
</div>
<div id="検証用関数を作る" class="section level3">
<h3>検証用関数を作る</h3>
<p>この作業は必須ではありませんが、今後、自分でパッケージ等を作ることになったら重要になるかも知れません。</p>
<p>最初の例でもお見せしましたが、Rでは事後的にクラスを変更することができます。強制的にクラスを変更した場合、そのクラスに属するメソッドを使うことができますが、エラーが生じてしまうでしょう。例えば、任意のcharacter型ベクトル<code>My_Cat2</code>を作成し、Catクラスを付与してみましょう。</p>
<pre class="r"><code>My_Cat2 &lt;- &quot;宋&quot;
class(My_Cat2) &lt;- &quot;Cat&quot;
class(My_Cat2)</code></pre>
<pre><code>## [1] &quot;Cat&quot;</code></pre>
<p><code>My_Cat2</code>のクラスはCatであるため、<code>my_func.Cat()</code>メソッドが使えます。しかし、<code>my_func.Cat()</code>仕組みを見る限り、うまく作動しないでしょう。</p>
<pre class="r"><code>my_func(My_Cat2)</code></pre>
<pre><code>## Error: $ operator is invalid for atomic vectors</code></pre>
<p>間違った動作をするよりは、エラーが出て中断される方が良いですし、これで問題ないかも知れません。しかし、可能であれば、引数として使われたオブジェクトが、Catクラスか否かを厳密にチェックする機能があれば良いでしょう。カプセル化されている場合、クラスの定義時にデータの構造が厳密に定義されているため、このような手続きの必要性はあまりありませんが、カプセル化ができないRのS3クラスでは検証用関数（Validator）が必要です。</p>
<p>それではCatクラスの特徴をいくつか考えてみましょう。</p>
<ul>
<li>オブジェクトの中には<code>Name</code>という要素のみがある。</li>
<li><code>Name</code>は長さ1のCharacter型ベクトルである。</li>
</ul>
<p>以上の条件を全て満たしていればメソッドを実行し、一つでも満たさない場合はメソッドの実行を中止します。それでは検証用関数<code>Validation_Cat()</code>を作ってみましょう。</p>
<pre class="r"><code>Validation_Cat &lt;- function(x) {
  Message &lt;- &quot;正しいCatクラスではありません。&quot;
  
  if (length(x) != 1) {
    stop(Message)
  } else if (is.null(names(x))) {
    stop(Message)
  } else if (names(x) != &quot;Name&quot;){
    stop(Message)
  } else if (length(x$Name) != 1 | class(x$Name) != &quot;character&quot;) {
    stop(Message)
  }
}</code></pre>
<p>この検証用関数を<code>my_func.Cat()</code>の最初に入れておきましょう。</p>
<pre class="r"><code>my_func.Cat &lt;- function(cat) {
  Validation_Cat(cat)
  
  print(paste0(cat$Name, &quot;: にゃーにゃー&quot;))
}</code></pre>
<p>それでは<code>My_Cat</code>と<code>My_Cat2</code>に対して<code>my_func()</code>メソッドを実行してみます。</p>
<pre class="r"><code>my_func(My_Cat)</code></pre>
<pre><code>## [1] &quot;矢内: にゃーにゃー&quot;</code></pre>
<pre class="r"><code>my_func(My_Cat2)</code></pre>
<pre><code>## Error in Validation_Cat(cat): 正しいCatクラスではありません。</code></pre>
<p>関数を実行する前に与えられたオブジェクトが正しいCatクラスか否かが判断され、パスされた場合のみ、メソッドが実行されることが分かります。もし、あるクラスで使用可能なメソッドが一つだけでしたら、検証用関数はメソッド内に直接書き込んでも良いですが、2つ以上のメソッドを持つ場合は別途の検証用関数を作成しておきましょう。</p>
<hr />
</div>
</div>
<div id="oop-sample" class="section level2">
<h2>例題</h2>
<p>ここでは2つのnumeric型ベクトルとそのベクトル名入力し、相関係数を求める<code>My_Cor()</code>関数を作ってみます。単に相関係数を求めるだけなら<code>cor()</code>や<code>cor.test()</code>があるので、いくつかの機能も追加してみましょう。</p>
<p>たとえば、「1日当たりゲーム時間」と「身長」といった2つのnumeric型ベクトルをそれぞれ<code>x</code>と<code>y</code>で入力し、<code>x.name</code>と<code>y.name</code>で各ベクトルの名前も指定します。また、入力されたデータを用いて相関係数とその信頼区間を求めます。これらのデータはリスト型として格納されますが、クラスを<code>"My_Cor_Object"</code>とします。以下はその例です。</p>
<pre class="r"><code>library(tidyverse)

Cor_Obj &lt;- My_Cor(x      = rnorm(20, 2, 0.5), 
                  y      = rnorm(20, 165, 6), 
                  x.name = &quot;1日当たりゲーム時間&quot;, 
                  y.name = &quot;身長&quot;)

class(Cor_Obj)</code></pre>
<pre><code>## [1] &quot;My_Cor_Object&quot;</code></pre>
<p>この<code>Cor_Obj</code>の構造を<code>str()</code>で確認してみます。</p>
<pre class="r"><code>str(Cor_Obj)</code></pre>
<pre><code>## List of 4
##  $ data    :&#39;data.frame&#39;:    20 obs. of  2 variables:
##   ..$ x: num [1:20] 1.65 1.93 2.41 1.71 2.36 ...
##   ..$ y: num [1:20] 167 174 151 163 166 ...
##  $ var_name: chr [1:2] &quot;1日当たりゲーム時間&quot; &quot;身長&quot;
##  $ cor     : Named num -0.211
##   ..- attr(*, &quot;names&quot;)= chr &quot;cor&quot;
##  $ cor_ci  : num [1:2] -0.598 0.256
##   ..- attr(*, &quot;conf.level&quot;)= num 0.95
##  - attr(*, &quot;class&quot;)= chr &quot;My_Cor_Object&quot;</code></pre>
<p><code>Cor_Obj</code>には元のデータがデータフレームとして格納され（<code>$data</code>）、それぞれの変数名（<code>$var_name</code>）、相関係数（<code>$cor</code>）、相関係数の95%信頼区間（<code>$cor_ci</code>）が<code>Cor_Obj</code>の中に入っています。本質的にはリスト型のデータ構造ですが、クラス名が<code>My_Cor_Object</code>になっているだけです。</p>
<p>この<code>My_Cor_Object</code>クラスには3つのメソッド（専用関数）が用意されており、<code>print()</code>、<code>summary()</code>、<code>plot()</code>です。<code>print()</code>と<code>summary()</code>は同じ関数で、<code>x</code>と<code>y</code>の平均値、そして相関係数と信頼区間を出力します。<code>plot()</code>は散布図と相関係数を出力します。実際の例を見てみましょう。</p>
<pre class="r"><code>print(Cor_Obj)</code></pre>
<pre><code>## 1日当たりゲーム時間の平均値: 2.009
## 身長の平均値: 165.128
## 相関係数: -0.211 [-0.598, 0.256]</code></pre>
<pre class="r"><code>summary(Cor_Obj) # summary()はprint()と同じ</code></pre>
<pre><code>## 1日当たりゲーム時間の平均値: 2.009
## 身長の平均値: 165.128
## 相関係数: -0.211 [-0.598, 0.256]</code></pre>
<pre class="r"><code>plot(Cor_Obj)</code></pre>
<p><img src="/oop_intro_files/figure-html/My_Cor_Object_Exam1-1.png" width="672" /></p>
<p>既存の<code>cor.test()</code>で作成される<code>"htest"</code>クラスに比べ、<code>"My_Cor_Object"</code>クラスは各変数の平均値が名前と一緒に表示され、<code>plot()</code>で簡単に散布図が作成できる大変便利なクラスです。このMy_Cor_Objectクラスとそのメソッドの構造を図示したものが以下の図です。</p>
<p><img src="Figures/OOP/My_Cor_Object.png" /></p>
<p>それでは一つずつ作っていきましょう。まずは、<code>"My_Cor_Object"</code>クラスのオブジェクトを作成する<code>My_Cor()</code>関数からです。</p>
<pre class="r"><code>My_Cor &lt;- function(x, y, x.name, y.name) {
    if (!is.numeric(x) | !is.numeric(y)) {
        stop(&quot;xまたはyがnumeric型ではありません。&quot;)
    }
    if (length(x) != length(y)) {
        stop(&quot;xとyは同じ長さでなかればなりません。&quot;)
    }
    if (!is.character(x.name) | !is.character(y.name)) {
        stop(&quot;x.nameまたはy.nameがcharacter型ではありません。&quot;)
    }
    
    data     &lt;- data.frame(x = x, y = y)
    var_name &lt;- c(x.name, y.name)
    cor      &lt;- cor.test(x, y)$estimate
    cor_ci   &lt;- cor.test(x, y)$conf.int
    
    result   &lt;- structure(list(data     = data, 
                               var_name = var_name, 
                               cor      = cor,
                               cor_ci   = cor_ci),
                          class = &quot;My_Cor_Object&quot;)
    
    result
}</code></pre>
<p>最初の部分は入力されたデータがMy_Cor_Objectクラスに適した構造か否かを判断します。これは最初から想定外のMy_Cor_Objectクラスのオブジェクトが作成されることを防ぐことが目的です。むろん、R（S3）の性質上、事後的にクラスを変更することが可能ですから、検証用関数も作っておきます。ここでは以下の条件を検証します。</p>
<ul>
<li><code>data</code>という要素が存在し、2列である。</li>
<li><code>var_name</code>という要素が存在し、長さ2のcharacter型ベクトルである。</li>
<li><code>cor</code>という要素が存在し、長さ1のnumeric型ベクトルである。</li>
<li><code>cor_ci</code>という要素が存在し、長さ2のnumeric型ベクトルである。</li>
</ul>
<pre class="r"><code>Validation &lt;- function (x) {
  UseMethod(&quot;Validation&quot;, x)
}

Validation.My_Cor_Object &lt;- function(x) {
  Message &lt;- &quot;正しいMy_Cor_Objectクラスではございません。&quot;
  
  if (is.null(x$data) | ncol(x$data) != 2) {
    stop(Message)
  }
  if (is.null(x$var_name) | length(x$var_name) != 2 | class(x$var_name) != &quot;character&quot;) {
    stop(Message)
  }
  if (is.null(x$cor) | length(x$cor) != 1 | class(x$cor) != &quot;numeric&quot;) {
    stop(Message)
  }
  if (is.null(x$cor_ci) | length(x$cor_ci) != 2 | class(x$cor_ci) != &quot;numeric&quot;) {
    stop(Message)
  }
}</code></pre>
<p>ここでは<code>Validation()</code>をジェネリック関数として使用しました。自分が開発するパッケージで複数のクラスを提供する予定でしたら、このようなやり方が良いでしょう。</p>
<p>検証用関数は細かく書いた方が良いです。以上の<code>Validation()</code>もより細かくことが出来ます。たとえば、<code>data</code>が2列か否かを判定するだけでなく、numeric型であるかなども判定した方が良いでしょう。</p>
<p>つづいて、My_Cor_Objectクラス用の<code>print()</code>関数（メソッド）を作成します。</p>
<pre class="r"><code>print.My_Cor_Object &lt;- function(data) {
    Valdation(data)
    
    cat(sprintf(&quot;%sの平均値: %.3f\n&quot;, 
                data$var_name[1],
                mean(data$data$x)))
    cat(sprintf(&quot;%sの平均値: %.3f\n&quot;, 
                data$var_name[2],
                mean(data$data$y)))
    cat(sprintf(&quot;相関係数: %.3f [%.3f, %.3f]\n&quot;, 
                data$cor, 
                data$cor_ci[1],
                data$cor_ci[2]))
}</code></pre>
<p>次は、<code>summary()</code>メソッドですが、これは<code>print()</code>と同じ機能をする関数です。この場合、<code>UseMethod("メソッド名")</code>を使うと、指定したメソッドを使うことになります。</p>
<pre class="r"><code>summary.My_Cor_Object &lt;- function(data) {
  UseMethod(&quot;print&quot;)
}</code></pre>
<p>最後は<code>plot()</code>メソッドです。</p>
<pre class="r"><code>plot.My_Cor_Object &lt;- function(data) {
    Valdation(data)
    
    data$data %&gt;%
      ggplot(aes(x = x, y = y)) +
      geom_point() +
      labs(x = data$var_name[1], y = data$var_name[2]) +
      ggtitle(sprintf(&quot;相関係数 = %.3f&quot;, data[[&quot;cor&quot;]])) +
      theme_minimal(base_family = &quot;HiraKakuProN-W3&quot;)
}</code></pre>
<p>これで相関係数の計算および可視化が便利になる関数群が完成しました。Rパッケージの開発はこれよりも数倍も複雑ですが、本記事の内容はプログラミングをより効率的に行うための入り口となります。</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>図の出典は<a href="https://www.itworld.com/article/2833265/don-t-go-into-programming-if-you-don-t-have-a-good-thesaurus.html">IT WORLD</a>です (アクセス: 2020-05-21)。<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>逆に特定のクラスで使用可能なメソッドを確認するときは<code>methods(class = "クラス名")</code>を入力します。<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>ただし、実際の場合、<code>[</code>や<code>[&lt;-</code>などは<code>tbl</code>または<code>tbl_df</code>用のメソッドが別途用意されています。<code>data.frame</code>クラスから継承されているメソッドとしては<code>dim()</code>や<code>t()</code>などがあります。<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
</div>

</main>

        <footer>
            <p class="copyright text-muted" align = "center">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>. Customized by <a href="https://www.jaysong.net">Jaehyun Song</a></p>
        </footer>

        

        
    </body>

</html>

