---
title: "Rプログラミング入門の入門"
date: "`r Sys.Date()`"
link-external-newwindow: true
toc: true
---

```{r common}
#| include: false
source("_common.R")
```

## はじめに

* 以下の内容は現在執筆中の内容の一部となります。
    * [Song Jaehyun・矢内勇生『私たちのR: ベストプラクティスの探求』(E-book)](https://www.jaysong.net/RBook/)

## Rプログラミング入門の入門

ここでは統計ソフトウェアではなく、プログラミング言語としてのRについて解説します。プログラミングとは難しそうなイメージがありますが、実は難しいです (?!?!)。ただし、プログラミングにおける重要概念は「代入」、「条件分岐」、「反復」この3つだけです。実はこの3つだけでほとんどのプログラムは作れます。しかし、この単純さがプログラミングの難しさでもあります。

たとえば、ある数字列を小さいものから大きい順へ並び替えることを考えてみましょう。`c(6, 3, 7, 2, 5, 1, 8, 4)`の場合、人間ならあまり苦労することなく、`c(1, 2, 3, 4, 5, 6, 7, 8)`に並び替えるでしょう。しかし、「代入」、「条件分岐」、「反復」のみでこれを具現化できるでしょうか[^sort]。もちろんですが、できます。たしかに、Rにはこのための`sort()`関数や`order()`関数などが用意されていますし、これを使えば良いのではないかと思うでしょう。しかし、これも「代入」、「条件分岐」、「反復」を組み合わせてR開発チームが予め作っておいた関数です。

[^sort]: プログラミング教育においてこのソートのアルゴリズムは定番中の定番であり、様々なアルゴリズムがあります。

「代入」、「条件分岐」、「反復」といった3つの概念さえ理解すれば何でも出来るという意味でプログラミングは簡単です。しかし、この3つだけで解決しないといけないという点でプログラミングは難しいです。ただし、ほとんどのプログラミング言語は既に作られた関数 (bulit-in function)が多く用意されており、それを使うのが賢明です。それでも条件分岐や反復について勉強する必要があるのは、我々一般ユーザーにとってもこれが必要な場面が多いからです。たとえば、同じ分析をデータだけ変えながら複数回走らせるには反復が有効です。これを使えばコードを数十分の一に減らすことも可能です。また、学歴が大卒以上なら「高学歴」、未満なら「その他」にデータを再分類したい場合は条件分岐が非常に便利です。これがないと、一々自分がデータを眺めてExcelなどで入力しないといけませんが、パソコンを使うと秒レベルで終わります。

## R言語の基礎概念 {#programming-intro}

これまで「オブジェクト」や「関数」、「引数」などという概念を何の断りもなく使ってきましたが、ここではもうちょっと詳細に定義したいと思います。これらはプログラミングをやっていく上である程度は意識すべき点でもあります。

**オブジェクト (object)**とはメモリに割り当てられた何かです。それは長さ1のベクトルを含むベクトル、行列、データフレーム、リストだけでなく、後ほど紹介する関数もオブジェクトに含まれます。一般的にオブジェクトとは何かの名前が付いています。たとえば、1から5までの公差1の等比数列なら、

```{r}
myVec1 <- c(1, 2, 3, 4, 5) # myVec1 <- 1:5も同じ
```

のように`myVec1`という名前でオブジェクトに割り当てます。一旦、名前を付けてオブジェクトとしてメモリに割り当てると、今後`myVec1`と入力するだけで中身の内容を読み込むことができます。それでは以下のように、`myVec1`の要素を2倍にする操作を考えてみましょう。

```{r}
myVec1 * 2
```

ここで`myVec1`はオブジェクトです。それでは`2`はどうでしょう。メモリに割り当てられていないし、これはオブジェクトではないでしょうか。実は、この数字`2`もオブジェクトです。計算する瞬間のみにおいてメモリに割り当てられ、計算が終わったらメモリから消されたと考えた方が簡単でしょう。R内の全てのものはオブジェクトです ("Everything that exists in R is an object")。実は先ほどの`*`のような演算子すらもオブジェクトです。

**クラス (class)**とはオブジェクトを特徴づけるものです。既にこれまで何回も`class()`関数を作ってデータ型やデータ構造を確認してきましたが、この`class()`関数はオブジェクトのクラスを確認する関数です。先ほど、`myVec1`も`*`も`2`もオブジェクトであると説明しましたが、これがオブジェクトということは何らかのクラスを持っていることになります。また、`class()`関数そのものもオブジェクトであるため、何らかのクラスを持っています。

```{r}
class(myVec1)
class(`*`)
class(2)
class(class)
```

統計言語としてのRでクラスを意識することは多くありません。しかし、Rでパッケージを開発したり、複雑な関数を自作する場合、オブジェクト指向プログラミング (Object-oriented Programming; OOP)の考え方が重要になりますが、その際はオブジェクトのクラスを厳密に定義する必要があります[^class]。

[^class]: 実はRはOOPの実装するためにS3クラスをデフォルトで採用していますが、これはオブジェクト指向プログラミング言語としては厳密性に欠いている面があります。ただし、S4やR6などはもうちょっと現代的なOOPに近い感覚でOOPを実装することができます。

**関数 (function)**は入力されたデータを、関数内部で決められた手順に沿って処理し、その結果を返すものです。関数は`関数名(データ)`のように使いますが、`class(myVec1)`は`myVec1`というデータのクラスを返す関数です。また、`sum(myVec1)`は`myVec1`の要素の総和を計算し、返す関数です。関数は自分で作成することも可能です。複雑な行動を繰り返す場合、その行動を関数内部で記述することで、一行でその行動を再現することが可能になります。この関数を使う際に必要なものが**引数 (argument)**というものです。`sum()`関数はこれだけだと何もできません。何らかのデータが与えられないと結果は返せません。たとえば、`sum(myVec1)`のようにです。ここで`myVec1`が`sum()`関数の引数です。また、引数は複数持つことができます。たとえば、欠損値を含む以下の`myVec2`を考えてみましょう。

```{r}
myVec2 <- c(1, 2, 3, NA, 5)
```

これを`sum()`関数で総和を求めると、結果は欠損値となります。

```{r}
sum(myVec2)
```

これは`sum()`の基本仕様が「欠損値が含まれているなら結果は欠損値にする」ことになっているからです。そこで`sum()`はもう一つの引数があり、それが`na.rm`引数です。`na.rm = TRUE`を指定すると、欠損値を除外した上で総和を返します。

```{r}
sum(myVec2, na.rm = TRUE)
```

引数を指定する場合は`myVec2`のように名前を付けないケースもありますが、ほとんどの場合、`na.rm = ...`のように、どのような引数かを明示する必要があります。関数によっては数十個の引数を必要する関数もあります。それらの多くはデフォルト値を持っています。たとえば、`sum()`関数の`na.rm`引数のデフォルト値は`FALSE`です。しかし、自分で引数を指定したい場合、その引数がどの引数かを明確にするために、引数名は書いた方が望ましいです。むろん、引数が1つのみの関数なら、省略しても構いませんし、そもそも引数名が付いていない場合もあります。`sum()`関数の最初の引数はnumericまたはcomplex型のベクトルですが、これらの引数名はそもそもありません。

ある関数がどのような引数を要求しているか、そのデフォルト値は何か、引数として何か決められたデータ型/データ構造があるかを調べるためには`?関数名`と入力します。ここでは`()`がないことに注意してください。多くの関数の場合、非常に充実なヘルプが付いているため、関数の具体的な使い方を調べるには`?関数名`が有用です。

## スクリプトの書き方 {#programming-style}

Rのコードの書き方には正解がありません。文法さえ合っていれば、何の問題もありません。しかし、コードを「書く」仕事以外にも「修正する」仕事も非常に重要です。そのためにはコードの書き手である人間に優しい書き方をした方が良いでしょう。書き方に正解はありませんが、「このように書いたら読みやすい」、「多くの人が採用している書き方」というのはあります。ここではこれについて簡単に説明します。

### オブジェクト名

ベクトルやデータフレームなどの変数や自作の関数など、全てのオブジェクトには何らかの名前が付きます。むろん、ラムダ式など、名前のない無名関数などもありますが、多くの場合は名前を持ちます。

名前を付ける決まったルールはありませんが、大事な原則があります。

**オブジェクト名は英数字と限られた記号のみにする。数字で始まる変数名は避ける。**

むろん、ローマ字以外にも日本語やハングルの変数名も可能ですが、推奨されておりません。ローマ字以外は文字化けの可能性もありますし、コードを書く際、列がずれる原因ともなります。

```{r}
Variable1 <- c(2, 3, 5, 7, 11) # 推奨
変数1 <- c(2, 3, 5, 7, 11)     # 非推奨
변수1 <- c(2, 3, 5, 7, 11)     # 非推奨
```

```{r}
Variable1
変数1
변수1
```

ただし、数字で始まるオブジェクト名は作成できません。

```{r}
#| error: true
100A <- "R"
```

他にも変数名に`.`と`_`が入ることは禁じられておらず、むしろ積極的に使われる場合が多いです。

**予約語を避ける**

また、Rで既に提供している関数やオブジェクト名は避けるべきです。例えば、Rには円周率 ($\pi$)の数値が`pi`という名前で含まれています。

```{r}
pi
```

`pi`という新しい変数を作るのは可能ですが、既存の`pi`が上書きされるため避けましょう。このようにプロブラミング言語が最初から提供しているオブジェクトの名前を「予約語」といいます。多くのプロブラミング言語は予約語を変数名として使うことを禁じており、Rも一部は禁止されています。たとえば、`pi`は上書き可能ですが、`if`や`for`というオブジェクト名は禁止されています。

```{r}
#| error: true
pi  <- 3
```

```{r}
#| error: true
if  <- "Yanai"
```

```{r}
#| error: true
for <- "All"
```

**短さと分かりやすさを求める**

できれば、オブジェクト名を見るだけで、中身がどのようなものかが分かればベストでしょう。たとえば、学生5人の数学成績が格納されたベクトルを作るとします。

```{r}
Variable1 <- c(30, 91, 43, 77, 100)
```

これでも問題ありませんが、プロブラミングの世界において変数は`Variable1`と全て書くよりも`Var1`や`V1`のように略す場合が多いです。データ分析の世界だと、変数名を`X1`や`X2`にする場合も多いです。しかし、これだけだと中身の内容が想像できません。したがって、変数名は可能な限り中身の内容をよく表現した名前が望ましいです。

```{r}
mathscore <- c(30, 91, 43, 77, 100)
```

これだと、「あ、この変数には数学成績が入っているんだろうな」と容易に想像できます。ただ、ここで変数の可読性をより高めることも可能です。

```{r}
MathScore  <- c(30, 91, 43, 77, 100)
mathScore  <- c(30, 91, 43, 77, 100)
math_score <- c(30, 91, 43, 77, 100)
math.score <- c(30, 91, 43, 77, 100)
```

以上の例は`math`と`score`の間に何らかの方法を使って区切りを入れた変数名であり、こちらの方が可読性が高いです。大文字と小文字の組み合わせで区切る方法は「*キャメルケース (camel case)*」と呼ばれ、大文字から始まるキャメルケースを*アッパーキャメルケース (upper camel case)*、小文字から始まるキャメルケースを*ローワーキャメルケース (lower camel case)*と呼びます。また、`_` (アンダーバー)で区切る方法は「*スネークケース (snake case)*」と呼ばれます。他にも`-` (ハイフン)で区切る「*チェーンケース (chain case)*」というのもありますが、Rの場合、オブジェクト名に`-`は禁止されております。

最後に`.`を使う方法がありますが、Rでは使用可能です。しかし、この方法を推奨しない方も多いです。現在、データサイエンスにおけるTop2の言語はRとPythonですが、Pythonの場合、`.`をメソット呼び出しに使うため、オブジェクト名として使えないからです。RとPython二刀流の方には混乱の原因となりうるため、`.`を嫌う方もいます。しかし、Rのみ使用する方なら`.`を使っても問題ありません。

### 改行

コードは1行が長すぎないように適宜改行します。Rやパッケージなどが提供している関数の中には十数個以上の引数を必要とするケースもあります。この場合、コードを一行に全部書いてしまうと、コードの可読性が著しく落ちてしまします。

一行のどれくらいの文字を入れるべきかについて決まったルールはありませんが、昔は一行80字という基準がよく使われてきました。これま昔のパソコンで使ったパンチカード ( @fig-punchedcard )が一行に80個の穴を開けることができたのから由来します。

```{r}
#| label: fig-punchedcard
#| echo: false
#| fig-cap: "パンチカードの例"
#| out-width: "600px"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/4/4c/Blue-punch-card-front-horiz.png")
```

今はモニターのサイズも大きくなり、解像度も高くなっているので、80文字にこだわる必要はありません。ただし、少なくとも自分のRStudioのSource Paneに収まるように、改行を適宜行ってください。

### スペースとインデント

適切なスペースはコードの可読性を向上させます。以下のコードは全く同じものですが、後者をスペースを入れなかったため、可読性があまりよくありません。

```{r}
#| eval: false
# 良い例
sum(myVec2, na.rm = TRUE)

# 悪い例
sum(myVec2,na.rm=TRUE)
```

どこにスペースを入れるかも決まっておりませんが、「`,`の後にスペース」、「演算子の前後にスペース」などの例があります。ただし、`^`の前後にスペースを入れません。また、後ほど紹介する`for(){}`、`while(){}`、`if(){}`は`()`前後にスペースを入れます。ただし、`function(){}`は`()`の後のみにスペースを入れます。その他の関数の場合、関数名と`()`の間にスペースは入れません。

また、スペースを2回以上入れるケースもあります。たとえば、あるデータフレームを作るとします。

```{r}
#| eval: false
# 良い例
data.frame(
  Name     = c("Song", "Yanai", "Hadley"),
  Favorite = c("Ramen", "Cat", "R"),
  Gender   = c("Male", "Male", "Male")
)

# 悪い例
data.frame(
  Name = c("Song", "Yanai", "Hadley"),
  Favorite = c("Ramen", "Cat", "R"),
  Gender = c("Male", "Male", "Male")
)
```

どのコードも同じですが、前者の方が読みやすいです。ここでもう一つ見てもらいのは「字下げ」です。先ほどのコードは以下のように一行にまとめることは可能ですが、あまりにも可読性がよくありません。

```{r}
#| eval: false
# 邪悪な例
data.frame(Name = c("Song", "Yanai", "Hadley"), Favorite = c("Ramen", "Cat", "R"), Gender = c("Male", "Male", "Male"))
```

このように一行のコードが長い場合、「改行」が重要です。ただし、改行した場合、字下げを入れましょう。改行された行は2文字または4文字分の字下げをします。こうすることで、「この行は上の行の続きです」ということは一目で分かります。

```{r}
#| eval: false
# 良い例
data.frame(
  Name     = c("Song", "Yanai", "Hadley"),
  Favorite = c("Ramen", "Cat", "R"),
  Gender   = c("Male", "Male", "Male")
)

# 悪い例
data.frame(
Name     = c("Song", "Yanai", "Hadley"),
Favorite = c("Ramen", "Cat", "R"),
Gender   = c("Male", "Male", "Male")
)
```

RStudioは自動的に字下げをしてくれるので、あまり気にする必要がありませんが、メモ帳などでコードを書く際は意識してください。

### 代入

オブジェクトに値を代入する演算子として、これまでは`<-`を使ってきましたが、`=`も使えます。実際、多くのプログラミング言語の場合、代入演算子は`=`を採用しています。しかし、本書では`<-`の使用を推奨します。

以上の内容は書き方の一部に過ぎません。本書のコードは出来る限り、多くの人に受け入れられているコードの書き方をするように心がけております。本書のコードを自分の手で書いていくうちに、徐々に書き方が身につくと思います。

最後に、より詳細な書き方のガイドについては以下の2つの資料が非常に参考になります。とりわけ、Hadley先生が書いた[The tidyverse style guide](https://style.tidyverse.org)は事実上 (de facto)の業界標準であり、[Google's Style Guide](https://google.github.io/styleguide/Rguide.html)はHadley先生が書いたスタイルガイドに基づいています。かなりの分量ですが、自分でパッケージ開発などを考えている場合は必ず一回目を通しておきましょう。

* [The tidyverse style guide](https://style.tidyverse.org)
* [Google's Style Guide](https://google.github.io/styleguide/Rguide.html)

## 反復 {#programming-iteration}

パソコンが最も得意とすることが「反復作業」です。普通の人間なら数時間〜数年かかるような退屈な反復作業を、パソコンを一瞬で終わらせます。Rもプログラミング言語である以上、反復作業のための様々な関数を提供しております。

反復作業を行う際は、「いつまで繰り返せば良いのか」を考えなくてはありません。そこで、2つのケースが考えられます。

1. 指定した回数だけ処理を繰り返す場合: `for()`文
2. 一定の条件が満たされるまで処理を繰り返す場合: `while()`文

ここではこの2つのケースそれぞれについて解説します。

### `for()`による反復

まずは、`for()`文を用いた反復処理のコードの雛形をみてみましょう。

```{r}
#| eval: false
for (任意の変数 in ベクトル) {
    処理内容
}
```

任意の変数は何でもいいんですが、よく使うのは`i`です (indexの意味)。この変数は`for(){}`文の内部で使うために用いられる変数です。そして、`in`の後の「ベクトル」は長さ1以上のベクトルです。必ずしもnumeric型である必要はありません。

また、`{}`内の内容が1行くらいで短い場合、`{}`は省略することもできます。したがって、以下のような書き方も可能です。これは`for()`だけでなく、`if()`や`function()`など、`{}`で処理内容を囲む関数において共通です。この場合、処理内容を`()`の直後に書くのが一般的です。例えば、以下のように書きます。

```{r}
#| eval: false
for (任意の変数 in ベクトル) 処理内容
```

ただし、処理内容が2行以上の場合は、必ず`{}`で囲んでください。

まずは、単に`N`回繰り返す`for()`文を書いてみましょう。任意の変数名は`i`とします。この場合、`for (i in 1:N)`と書きます。5回繰り返すなら`for (i in 1:5)`となります。`1:5`は`c(1, 2, 3, 4, 5)`と同じですので、`for (i in c(1, 2, 3, 4, 5))`でも構いませんが、効率はよくありません。

とりあえず、以下のようにコードを作成し、走らせてみましょう。これは3行にわたるコードですので、Rコンソールで打ち込むのは非効率的です。必ずソースコード欄に書いて、`for`の行にカーソルを置いた状態でCmd + Enter (Windowsの場合、Contrl + Enter)を入力しましょう。むろん、この3行を全て選択してからCmd + Enterを押しても構いません。

```{r}
for (i in 1:5) {
    print(i)
}

# 上記のコードはこのように書くことも可能
# for(i in 1:5) print(i)
```

1から5までの数字が表示されました。これは一体、どのような動きをしているのでしょうか。これから詳しく解説します。

1. `i`にベクトル`1:5`の最初の要素を代入 (`i = 1`)
2. `print(i)`を実行
3. `{}`中身の処理が終わったら`i`にベクトル`1:5`内の次の要素を代入 (`i = 2`)
4. `print(i)`を実行
5. `{}`中身の処理が終わったら`i`にベクトル`1:5`内の次の要素を代入 (`i = 3`)
6. `print(i)`を実行
7. `{}`中身の処理が終わったら`i`にベクトル`1:5`内の次の要素を代入 (`i = 4`)
8. `print(i)`を実行
9. `{}`中身の処理が終わったら`i`にベクトル`1:5`内の次の要素を代入 (`i = 5`)
10. `print(i)`を実行
11. `{}`中身の処理が終わったら`i`にベクトル`1:5`内の次の要素を代入するが、`5`が最後なので反復終了

以上のような手順で`for()`文は作動します。この手順を要約すると以下のようになります。

* 任意の変数 (ここでは`i`)にベクトル (ここでは`1:5`)の最初の要素が格納され、`{}`内の処理を行う。
* `{}`内の処理が終わったら、ベクトル (ここでは`1:5`)の次の要素を任意の変数 (ここでは`i`)に格納し、`{}`内の処理を行う。
* 格納できる要素がなくなったら反復を終了する。
    * したがって、反復はベクトル (ここでは`1:5`)の長さだけ実行される (ここでは5回)。
    
反復はベクトルの長さだけ実行されるので、`1:5`のような書き方でなく、普通のベクトルでも問題ありません。たとえば、長さ6の`Iter_Vec1`というベクトルを作り、その要素を出力するコードを書いてみましょう。

```{r}
Iter_Vec1 <- c(24, 64, 31, 46, 81, 102)

for (damage in Iter_Vec1) {
    x <- paste0("トンヌラに", damage, "のダメージ!!")
    print(x)
}
```

スライムを倒すには十分な攻撃力を持つ勇者ですね。ちなみに、`paste0()`は引数を空白なし[^paste]で繋ぎ、文字列として返す関数です。詳細割愛しますが、簡単な例だけお見せします。

[^paste]: `paste()`関数を使うと、空白ありで繋ぎます。

```{r}
paste0("私は", "Rが", "使えません。")
paste0("私の", "英語成績は", 0, "点です。")
```

むろん、文字列のベクトルを使うことも可能です。10個の都市名が格納された`Iter_Vec2`の要素を一個ずつ出力するコードは以下のようになります。

```{r}
Iter_Vec2 <- c("Sapporo", "Sendai", "Tokyo", "Yokohama", "Nagoya",
               "Kyoto", "Osaka", "Kobe", "Hiroshima", "Fukuoka")

for (city in Iter_Vec2) {
    x <- paste0("現在、cityの値は", city, "です。")
    print(x)
}
```

次は、`for()`の外にあるオブジェクトを参照する`for()`文について説明します。たとえば、`"1番目の都市名はSapporoです"`、`"2番目の都市名はSendaiです"`、...のように出力するにはどうすれば良いでしょうか。今までは一箇所だけ変えながら表示しましたが、今回は「**`i`**番目」と「**`city`**です」の二箇所が変わります。この場合は、まず**`i`**を基準に反復を行いながら、`Iter_Vec2`の`i`番目要素を呼び出すことで解決できます。以下のコードを見てみましょう。

```{r}
for (i in 1:length(Iter_Vec2)) {
    msg <- paste0(i, "番目の都市名は", Iter_Vec2[i], "です。")
    print(msg)
}
```

ここでは`for (i in 1:10)`ではなく、`for (i in 1:length(Iter_Vec2))`と表記しましたが、前者よりも後者の方が望ましい書き方です。なぜなら、もし事後的に`Iter_Vec2`に都市名を2つ追加した場合、前者だと`1:12`と修正する必要がありますが、後者は`length()`関数で`Iter_Vec2`の長さを計算してくれるからです。

**多重for()文について**

`for()`文の中に、更に`for()`文を使用することも可能です。最初はやや難しいかも知れませんが、多重反復はプログラミングでもよく使われるので[^multiple_interation]、この機会に勉強しておきましょう。

[^multiple_interation]: しかし、`for()`文をあまりにも多く重ねるとコードの可読性が著しく低下しますので、注意しましょう。この場合は反復処理を行う自作関数を作成することで対応できます。

この多重`for()`文の定番の例は(掛け算)九九です。1から9まで、全ての組み合わせの掛け算を計算するためには、2つの`for()`文が必要です。`i * j`で`i`と`j`それぞれに1から9を代入しながら結果を出力するコードは以下のように書きます。

```{r}
for (i in 1:9) {
  for (j in 1:9) {
    print(paste(i, "*", j, "=", i * j))
  }
}
```

まずは、`i`に1が代入されます。そして、`j`に1から9が一つずつ入れ替わるので、`1 * 1`、`1 * 2`、`1 * 3`、...、`1 * 9`が計算されます。`1 * 9`の計算が終わったら`i`に2が代入され、再び内側の`for()`文が実行され、`2 * 1`、`2 * 2`、`2 * 3`、...、`2 * 9`が計算されます。これを9の段まで繰り返します。もし、9の段から1の段の順にしたい場合は、`i in 1:9`を`i in 9:1`に変えるだけです。

```{r}
for (i in 9:1) {
  for (j in 1:9) {
    print(paste(i, "*", j, "=", i * j))
  }
}
```

九九を覚える際はこれで良いでしょうが、`i * j`と`j * i`は実質的に同じですから、片方だけ出力させても問題はないでしょう。これはどうすれば良いでしょうか。この場合、`for (j in 1:9)`を`for (j in 1:i)`に変えるだけです。

```{r}
for (i in 1:9) {
  for (j in 1:i) {
    print(paste(i, "*", j, "=", i * j))
  }
}
```

これは1の段は`1 * 1`まで、2の段は`2 * 2`まで、3の段は`3 * 3`まで計算し、出力するコードです。2の段の場合、`2 * 3`や`2 * 9`などが出力されませんが、これは3の段において`3 * 2`が、9の段で`9 * 2`が出力されるので問題ないでしょう。このように多重`for()`文は複数のベクトルの組み合わせ全てにおいて処理を行う場合、有効です。

複数のベクトルでなく、データフレームなどの2次元以上データにも多重`for()`文は使われます。データフレームは複数のベクトルで構成されているため、実質的には複数のベクトルを扱うことになります。今回は例として、[FIFA_Men.csv](Data/FIFA_Men.csv)を利用し、それぞれの国のチーム名、FAFAランキング、ポイントをまとめて表示するコードを書いてみます。全てのチームを出すと結果が長くなるので、OFC (オセアニアサッカー連盟)所属チームだけに絞ります。

```{r}
#| message: false
# FIFA_Men.csvを読み込み、myDFという名で保存
# ファイルのパスは適宜修正してください
myDF <- read.csv("Data/FIFA_Men.csv")
# myDFのConfederation列がOFCの行だけを抽出
myDF <- myDF[myDF$Confederation == "OFC", ]

myDF
```

ちょうど10チームとなります。作りたいのは以下のような内容が表示されるコードです。

```
=====1番目の国家情報=====
Team: American Samoa
Rank: 192
Points: 900
=====2番目の国家情報=====
Team: Fiji
Rank: 163
Points: 996
=====3番目の国家情報=====
Team: New Caledonia
...
```

実はこれ、一つの`for()`でも作成できますが、勉強のために2つの`for()`文を使いましょう。

```{r}
#| eval: false
for (i in 1:nrow(myDF)) {
  print(paste0("=====", i, "番目の国家情報====="))
  
  for (j in c("Team", "Rank", "Points")) {
    print(paste0(j, ": ", myDF[i, j]))
  }
}
```

以上のコードを実行すると以下のような結果が表示されます。ここでは全部掲載するのは長いので、最初の2チーム情報のみ掲載します。

```{r}
#| echo: false
for (i in 1:2) {
  print(paste0("=====", i, "番目の国家情報====="))
  
  for (j in c("Team", "Rank", "Points")) {
    print(paste0(j, ": ", myDF[i, j]))
  }
}
```

それではコードの詳細について説明します。まず、外側の`for()`文には任意の変数としては`i`を、内側の`for()`文に対しては`j`を用います。Rの場合、コードは上からの順番で処理します（同じ行なら、カッコの中から処理します）。したがって、まず処理されるのは外側の`for()`文です。`i`に割り当てられたベクトルは`1:nrow(myDF)`です。`nrow()`は行列またはデータフレームの行数を求める関数で、今回の場合、`myDF`は10行のデータであるため、`1:10`になります。つまり、外側の`for()`文は`i`に1, 2, 3...の順で値を格納しながら10回処理を繰り返すことになります。それでは外側`for()`文の中身を見ましょう。ここではまず、`"=====i番目の国家情報====="`というメッセージを出力します。最初は`i`が`1`ですので、`"=====1番目の国家情報====="`が表示されます。

次の行からが内側の`for()`文になります。ここでは`j`に`c("Team", "Rank", "Points")`を格納しながら内側`for()`文内のコードを3回繰り返します。内側のコード内容は例えば、`i = 1`の状態で、`j = "Team"`なら、`print(paste0("Team", ": ", myDF[1, "Team"]))`になります。つまり、`myDF[1, "Team"]`は`myDF`の`Team`列の1番目の要素を意味します。この処理が終わったら、次は`j`に`"Rank"`が代入され、同じコードを処理します。そして、`j = "Points"`まで処理が終わったら、内側の`for()`文の役目はとりあえず終わりです。

内側の`for()`文が終わっても、外側の`for()`文はまだ終わっておりません。次は`i`に`2`が格納され、`"=====2番目の国家情報====="`を表示し、また内側の`for()`文を最初から処理します。この作業は`i = 10`の状態で内側の`for()`文が終わる時点で、外側の`for()`文も止まります。これが多重`for()`文の動き方です。

もし、チーム名の次に、所属連盟も表示したい場合はどう直せば良いでしょうか。正解は`c("Team", "Rank", "Points")`のベクトルにおいて、`"Team"`と`"Rank"`の間に`"Confederation"`を追加するだけです。実際にやってみましょう (結果は紙幅の関係上、最初の2チームのみ掲載します)。

```{r}
#| eval: false
for (i in 1:nrow(myDF)) {
  print(paste0("=====", i, "番目の国家情報====="))
  
  for (j in c("Team", "Confederation", "Rank", "Points")) {
    print(paste0(j, ": ", myDF[i, j]))
  }
}
```

```{r}
#| echo: false
for (i in 1:2) {
  print(paste0("=====", i, "番目の国家情報====="))
  
  for (j in c("Team", "Confederation", "Rank", "Points")) {
    print(paste0(j, ": ", myDF[i, j]))
  }
}
```

ちなみに、同じ動きをする別の書き方は以下のとおりです。結果は掲載しませんが、興味のある方は試してみて下さい。`cat()`関数の使い方については`?cat`を参照してください。ちなみに`\n`は改行コードを意味します。

```{r}
#| eval: false
for (i in 1:nrow(myDF)) {
  cat(paste0("=====", i, "番目の国家情報=====\n"))
  cat(paste0("Team:",   myDF$Team[i], "\n",
             "Rank:",   myDF$Rank[i], "\n",
             "Points:", myDF$Points[i], "\n"))
}
```

もう一つの例を見たいと思います。今回はリスト型を対象とした多重反復の例です。複数のベクトルを含むリストの場合、3番目のベクトルの5番目の要素を抽出するには`リスト名[[3]][5]`のように2つの位置を指定する必要があります。たとえば、以下の3人で構成された3つのクラスがあるとし、そのグループ構成人の名前が出席番号順で入っている`myList`を考えましょう。

```{r}
myList <- list(Class_A = c("Yanai", "Song", "Hadley"),
               Class_B = c("Tanaka", "Sato", "Suzuki"),
               Class_C = c("Abe", "Moon", "Xi"))
```

ここで、まず各クラスの出席番号1番の人の名字3つを出力し、次は2番の人、最後に3番の人を出すにはどうすれば良いでしょうか。以下のコードを見て下さい。

```{r}
for (i in 1:3) {
  
  for (j in names(myList)) {
    print(myList[[j]][i])
  }
  
  print(paste0("===ここまでが出席番号", i, "番の人です==="))
}
```

以上のコードは以下のように動きます。

* 1行目: 任意の変数を`i`とし、1から3までの数字を`i`に格納しながら、3回反復作業を行います。
* 3行目: 任意の変数を`j`とし、ここにはリストの要素名を格納しながら、リストの長さだけ、処理を繰り返します。`names(myList)`は`c("Class_A", "Class_B", "Class_C")`と同じです。
* 4行目: `myList[[j]][i]`の内容を出力します。最初は`i = 1`、`j = "Class_A"`なので、`print(myList[["Class_A"]][1])`、つまり、`myList`から`"Class_A"`を取り出し、そこの`1`番目の要素を出力するという意味です。
* 7行目: 各ベクトルから`i`番目の要素を出力したら、`print(paste0("===ここまでが出席番号", i, "番の人です==="))`を実行し、`i`に次の要素を入れて、反復作業を続きます。`i`に格納する要素がなくなったら、反復を中止します。

多重`for()`文は3重、4重も可能ですが、コードの可読性が低下するため、多くても3つ、できれば最大2つが良いです。3重以上に`for()`文を重ねる場合は内側の`for()`文を後ほど解説する関数でまとめるのがおすすめです。

### `while()`による反復

`for()`文は任意の変数にベクトルの要素を1つずつ入れ替えながら、ベクトルの要素を使い尽くすまで反復処理を行います。一方、「ある条件が満たされる限り、反復し続ける」ことも可能であり、この際使う関数が`while()`文です。`while()`文の書き方は`for()`文に非常に似ています。

```r
while (条件) {
  条件が満たされた場合の処理内容
}
```

`for`が`while`に変わり、`()`内の書き方が`(任意の変数 in ベクトル)`から`(条件)`に変わりました。この`()`内の条件が満たされる間は`{}`内の内容を処理します。1から5を表示するコードは`for()`文を使う場合、以下のようになります。

```{r}
#| eval: false
# for文を使う場合
for (i in 1:5) {
    print(i)
}
```

これを`while()`を使って再現すると以下のようなコードとなります。

```{r}
# while文を使う場合
i <- 1

while (i <= 5) {
  print(i)
  i <- i + 1
}
```

`while()`内の条件は`i <= 5`、つまり「`i`が5以下なら以下の内容を処理する」ことを意味します。注意すべきところは`i`が5以下か否かの判断は最初から行われるため、予め変数`i`を指定しておく必要があります。最初に出てくる`i <- 1`がそれです。そして、`{}`内には`i <- i + 1`を追加し、`i`を1を足していきます。`i = 5`の時点では`print(i)`が実行されますが、`i = 6`になった瞬間、反復は停止します。

もう一つ注意すべきところは`i <- i + 1`の位置です。以下は先ほどと同じコードですが、`i <- i + 1`が`print(i)`の前に位置するコードです。

```{r}
i <- 1

while (i <= 5) {
  i <- i + 1
  print(i)
}
```

今回は2から6まで出力されました。これは`i`を出力する前に`i`に1が足されるからです。そして、`i = 5`の状態で、`i`に1が足されることとなり、6が出力されます。もし、`i <- i + 1`を`print(i)`より前に置いたまま、1から5を出力させる場合は、以下のようにコードを修正する必要があります。

```{r}
i <- 0

while (i <= 4) {
  i <- i + 1
  print(i)
}
```

変更点は1)`i`の初期値が0となった点と、2) `()`内の条件が`(i <= 5)`から`(i <= 4)`に変わった点です。

`while()`による書き方は慣れないとややこしいと感じる方も多いかと思います。また、`for()`文で代替できるケースも多いです。それでも`while()`文を使うケースはあります。それは先述した通り、「目標が決まっているが、その目標が達成されるまでは何回繰り返せば分からない時」において`while()`文は効果的です。

たとえば、6面サイコロ投げを考えてみましょう。投げる度に出た目を記録し、その和が30以上に達した瞬間、サイコロ投げを中止します。この場合、何回サイコロを投げる必要があるでしょうか。連続で6が出るなら5回で十分ですが、ずっと1のみが出るなら30回投げる必要があります。このように、「反復処理は行うが、何回行えばいいか分からない。ただし、いつやめるかは知っている」場合に`while()`文を使います。以下は`while()`文を使ったコードです。

```{r}
Total <- 0
Trial <- 1

while (Total < 30) {
  Dice  <- sample(1:6, 1)
  Total <- Total + Dice
  
  print(paste0(Trial, "回目のサイコロ投げの結果: ", Dice,
               "(これまでの総和: ", Total, ")"))
  
  # print()文は以下のような書き方も可能
  # Result <- sprintf("%d回目のサイコロ投げの結果: %d (これまでの総和: %d)", 
  #                   Trial, Dice, Total)
  # print(Result)
  
  Trial <- Trial + 1
}
```

それでは、コードの説明をします。まず、これまで出た目の和を記録する変数`Total`を用意し、初期値として0を格納します。また、何回目の投げかを記録するための`Trial`変数を記録し、初期値として1を格納しておきます (コードの1、2行目)。

続いて`while()`文を入れます。反復する条件は`Total`が30より小さい場合と設定します。つまり、`Total`が30以上になったら反復を終了することを意味します (コードの4行目)。

つづいて、サイコロ投げをし、出た目を`Dice`という変数に格納します。サイコロ投げは1から6の間の整数から無作為に一つを値を抽出することでできます。そこで使われるのが`sample()`関数です (コードの5行目)。`sample()`関数は与えられたベクトル内の要素を無作為に抽出する関数です。`sample(c(1, 2, 3, 4, 5, 6), 1)`は「`c(1, 2, 3, 4, 5, 6)`から1つの要素を無作為に抽出せよ」という意味です。むろん、複数の要素を抽出することも可能ですし、数値型ベクトルでなく、文字型ベクトルから抽出することも可能です。サイコロ投げをしたら、その目を`Total`の値に足します (コードの6行目)。

つづいて、「1回目のサイコロ投げの結果: 5 (これまでの総和: 5)」のように、現在の処理結果を表示させます (コードの8行目)。最後に`Trial`の値を1増加させて反復を続けます (コードの14行目)。

むろん、`for()`文を使って再現することも可能であり、以下は`for()`を使ったコードになります。

```{r}
Total <- 0

for (Trial in 1:30) {
  Dice  <- sample(1:6, 1)
  Total <- Total + Dice
  
  # print()の代わりにsprintf()を使うことも可能
  Result <- sprintf("%d回目のサイコロ投げの結果: %d (これまでの総和: %d)",
                    Trial, Dice, Total)
  print(Result)
  
  if (Total >= 30) {
    break() # ()は省略可能
  }
}
```

まず、サイコロを何回投げれば良いかは分かりませんが6面サイコロの場合、30回以内には必ず合計30になるので、まず`Trial in 1:30`とします。あとは`while()`文の書き方とほぼ同じですが、今回は`i`が自動的に更新されるので`i <- i + 1`は不要です。ただし、一定の条件が満たされる場合、`for()`文を停止する必要があります。そこで登場するのが条件分岐と`break()`です。条件分岐は次節で説明しますが、これは「`Total`が30以上になった場合、ループから脱出せよ」を意味します。このループからの脱出を指示する関数が`break()`です。ちなみに、`break()`関数は`()`を抜いて`break`と書いても問題ありません。また、`if(){}`内の処理内容は一行ですので、`if (Total >= 30) break`のような書き方でも問題ありません。

これは余談ですが、結果の表示に今回はこれまで使ってきた`print()`と`paste0()` (または`paste()`)を使わず、`sprintf()`を使いました。人によってはこっちの書き方を好む場合もあります。`sprintf()`内の`%d`はその位置に指定された変数の値を整数として代入することを意味します。`sprintf()`はまず、出力する文字列を指定し、続いて代入する変数を順番に引数として入れます。`%s`は文字型、`%f`は実数を意味します。`%f`の場合、少数点の桁数も指定可能であり、小数点2桁まで表示させる場合は`%.2f`のように表記します。以下のコードは3つの変数の値と文字列を結合する処理を`print(paste0())`と`sprintf()`を用いて書いたものであり、同じ動きをします。

```{r}
Name   <- "Song"
Score  <- 50
Height <- 176.2

print(paste0(Name, "の数学成績は", Score, "点で、身長は", Height, "cmです。"))
# %sにNameを、%dにHeightを、%.1fにHeightを小数点1位まで格納し、出力
sprintf("%sの数学成績は%d点で、身長は%.1fcmです。", Name, Score, Height)
```

ただし、`{}`内の`sprintf()`はそのまま出力されないため、一旦、オブジェクトとして保存し、それを`print()`を使って出力させる必要があります。詳細は[`?sprintf`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/sprintf)で確認してください。

今回は「多くても30回以内に終わる」ことが分かっていましたが、シミュレーションなどではそれが未知であるケースも多いです。目的に合わせて`for()`文と`while()`文を使い分けましょう。

## 条件分岐 {#programming-condition}

### `if()`、`else if()`、`else()`による条件分岐

続いて、条件分岐について説明します。これは何らかの条件が満たされた場合、指定された処理を行うことを意味します。一般的な条件分岐は以下のように書きます。

```r
if (条件) {
  条件が満たされた場合の処理内容
}
```

`while()`文と非常に書き方が似ていることが分かります。ただし、`while()`文は条件が満たされる限り`{}`の内容を繰り返して実行する意味を持つ一方、`if()`文は条件が満たされれば`{}`の内容を処理して終わるといった違いがあります。たとえば、名前が格納されているオブジェクト`Name`の中身が`"Song"`なら「アホ」と出力されるコードを考えてみましょう。

```{r}
Name <- "Song"

if (Name == "Song") {
  print("アホ")
}
```

`if()`内の条件は「`Name`が`"Song"`」の場合、`{}`内の内容を処理せよということを意味します。もし、`Name`の中身が`"Yanai"`ならどうでしょうか。

```{r}
Name <- "Yanai"

if (Name == "Song") {
  print("アホ")
}
```

なんの結果も表示されません。`if()`文単体だと、条件が**満たされない**場合の処理内容を指定することができません。ここで`else`文の出番です。これは`if()`とセットで使われるものであり、`if()`内の条件が満たされなかった場合の処理内容を指定します。`else`を加えたコードの書き方は以下の通りです。

```r
if (条件) {
  条件が満たされた場合の処理内容
} else {
  条件が満たされなかった場合の処理内容
}
```

`else`文は以下のように改行して入れることも可能です。

```r
if (条件) {
  条件が満たされた場合の処理内容
} 
else {
  条件が満たされなかった場合の処理内容
}
```

ただし、一般的なRスクリプトの書き方だと、改行しない方が望ましいです。なぜなら、「この`if()`文と`else`は一つのセットです」ということがより明確になるからです。コードの書き方は人にもよりますが、何らかのこだわりがないなら、改行せずに使いましょう。

それでは`Name`が`"Song"`じゃない場合、「天才」と表示されるコードを書いてみましょう。

```{r}
Name <- "Song"

if (Name == "Song") {
  print("アホ")
} else {
  print("天才")
}
```

`Name`が`"Song"`の場合、前と変わらず「アホ」が出力されます。それでは`Name`を`"Yanai"`に変えてみましょう。

```{r}
Name <- "Yanai"

if (Name == "Song") {
  print("アホ")
} else {
  print("天才")
}
```

ちゃんと「天才」が表示されます。しかし、世の中はアホと天才のみで構成されておりません。世界に真の天才はYanaiとShinadaのみ、アホはSongのみだとします。それ以外の人は凡才だとします。つまり、今回はパタンが3つあります。この場合は`else if()`を`if()`と`else`の間に挿入します。

```r
if (条件1) {
  条件1が満たされた場合の処理内容
} else if (条件2) {
  条件1が満たされず、条件2が満たされたい場合の処理内容
} else if (条件3) {
  条件1, 2が満たされず、条件3が満たされたい場合の処理内容
} else {
  条件が全て満たされなかった場合の処理内容
}
```

これは`if()`文の条件が満たされたら後の`{}`内容を処理し、満たされなかったら次の`else if()`内の条件を判定する。そして、条件が満たされたら`{}`の内容が実行され、満たされなかったら次の`else if()`へ移動する...といった構造となります。それでは実際のコードを書いてみましょう。

```{r}
Name <- "Song"

if (Name == "Song") {
  print("アホ")
} else if (Name == "Yanai" | Name == "Shinada") {
  # 以上の文は } else if (Name %in% c("Yanai", "Shinada")) { もOK
  print("天才")
} else {
  print("凡才")
}
```

まず、`Name`が`"Song"`か否かを判定し、`TRUE`なら「アホ」を表示します。もし、`FALSE`なら次の`else if()`文へ移動します。ここでは`Name`が`"Yanai"`もしくは`"Shinada"`かを判定します。`|`は「OR (または)」を意味する論理演算子です。このように条件の中には`|`や`&`などの論理演算子を使うことで、複数の条件を指定することができます。また、`Name == "Yanai" | Name == "Shinada"`は`Name %in% c("Yanai", "Shinada")`に書き換えることができます。`x %in% y`は`x`が`y`に含まれているか否かを判定する演算子です。たとえば、`"A" %in% c("A", "B", "C")`の結果は`TRUE`ですが、`"Z" %in% c("A", "B", "C")`の結果は`FALSE`です。

それでは`Name`を`"Yanai"`、`"Shinada"`、`"Shigemura"`、`"Hakiai"`に変えながら結果を確認してみましょう。

```{r}
Name <- "Yanai"

if (Name == "Song") {
  print("アホ")
} else if (Name %in% c("Yanai", "Shinada")) {
  print("天才")
} else {
  print("凡才")
}
```

```{r}
Name <- "Shinada"

if (Name == "Song") {
  print("アホ")
} else if (Name %in% c("Yanai", "Shinada")) {
  print("天才")
} else {
  print("凡才")
}
```

```{r}
Name <- "Shigemura"

if (Name == "Song") {
  print("アホ")
} else if (Name %in% c("Yanai", "Shinada")) {
  print("天才")
} else {
  print("凡才")
}
```

```{r}
Name <- "Hakiai"

if (Name == "Song") {
  print("アホ")
} else if (Name %in% c("Yanai", "Shinada")) {
  print("天才")
} else {
  print("凡才")
}
```

`if()`文が単独で使われることは滅多にありません。`if()`文は主に反復処理を行う`for()`または`while()`文内、もしくは次節で説明する自作関数内に使われる場合がほとんどです。実際、これまで名前からアホ・天才・凡才を判定する度に同じコードを書いてきました。これはあまりにも非効率的です。これを関数としてまとめることが出来るとより使いやすくなります。関数の作成については後ほどで説明します。

ここでは`for()`文と条件分岐の組み合わせについて考えてみましょう。生徒10人の成績が入っているベクトル`Scores`があるとします。そして、成績が60点以上なら「可」を、未満なら「不可」を返すようなコードを書きます。この作業を効率的に行うためには`for()`文と`if()`文を組み合わせる方法が考えられます。つまり、`for()`文には任意の変数`i`に1から10までの数字を入れ替えながら反復を行います。ここでの10はベクトル`Scores`の長さですので、`length(Scores)`も問題ありません。そして、`Scores`の`i`番目要素に対して60点以上か否かの判定を行い、「可」または「不可」の結果を返します。以下のコードはその例です。

```{r}
Scores <- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85)

for (i in 1:length(Scores)) {
  if (Scores[i] >= 60) {
    print(paste0("生徒", i, "の判定結果: 可"))
  } else {
    print(paste0("生徒", i, "の判定結果: 不可"))
  }
}
```

* 1行目: まず、ベクトル`Scores`を定義します。
* 3行目: `for()`文を用います。任意の変数は`i`とし、ここには1から10を入れ替えながら反復を行います。したがって、`i in 1:10`でも問題ありませんが、ここでは`i in 1:length(Scores)`にします。こうすることで、`Scores`ベクトルの長さが変わっても、`for()`の中身を修正する必要がなくなります。
* 4, 5行目: `Scores`の`i`番目要素が60点以上かを判定し、`TRUE`なら「生徒iの判定結果: 可」を出力します。
* 6-8行目: `Scores`の`i`番目要素が60点以上でない場合、「生徒iの判定結果: 不可」を出力します。

`print()`内に`paste0()`を使うのはコードの可読性がやや落ちるので、`sprintf()`を使うことも可能です。

```{r}
Scores <- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85)

for (i in 1:length(Scores)) {
  if (Scores[i] >= 60) {
    Result <- sprintf("生徒%dの判定結果: 可", i)
  } else {
    Result <- sprintf("生徒%dの判定結果: 不可", i)
  }
  
  print(Result)
}
```

続いて、結果を出力するのではなく、結果を別途のベクトルに格納する例を考えてみましょう。予め長さ10の空ベクトル`PF`を用意します。ここに各生徒の判定結果を「可/不可」で格納する処理を行います。以下はその例です。

```{r}
Scores <- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85)
PF     <- rep(NA, length(Scores))

for (i in 1:length(Scores)) {
  if (Scores[i] >= 60) {
    PF[i] <- "可"
  } else {
    PF[i] <- "不可"
  }
}
```

まず、中身が`NA`のみで構成されている長さ10の空ベクトル`PF`を生成します。`rep(NA, length(Scores))`は`NA`を`length(Scores)`個 (ここでは10個)並べたベクトルを生成する関数です。たとえば、`rep(5, 3)`は`c(5, 5, 5)`と同じです。

続いて、条件分岐ですが、今回はメッセージを出力するのではなく、`PF`の`i`番目に`"可"`か`"不可"`を入れます。以下はその結果です。

```{r}
PF
```

このように、`if()`文は反復処理を行う`for()`または`while()`文と組み合わせることで本領発揮となります。実は今回の例ですが、後で説明する`ifelse()`を使うと、一行で処理することができます。ただし、複雑な処理を伴う反復と条件分岐の組み合わせの場合は、今回のように`for()`と`if()`を組み合わせる必要が出てきます。

### `ifelse()`による条件分岐

`ifelse()`は与えられたベクトル内の要素に対して条件分岐をし、それを全ての要素に対して繰り返す関数です。簡単な条件分岐と反復処理を同時に行う非常に便利な関数です。`ifelse()`の使い方は以下の通りです。

```r
ifelse(条件, 条件がTRUEの場合の処理、条件がFALSEの場合の処理)
```

たとえば、生徒10人の成績が入っているベクトル`Scores`に対して、60点以上の場合、合格 (`"Pass"`)、未満の場合は不合格 (`"Fail"`)の値を割り当て、`PF`というベクトルに格納するとします。

```{r}
Scores <- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85)
PF     <- ifelse(Scores >= 60, "Pass", "Fail")
PF
```

条件は`Scores`が60以上か否かであり、60以上なら`"Pass"`を、それ以外なら`"Fail"`を返します。また、返す値は必ず新しい値である必要がありません。一定の条件が満たされたらそのままにし、それ以外なら指定した値を返すことも可能です。たとえば、世論調査では以下のように「答えたくない」または「わからない」を9や99などで記録することがよくあります。この値はこのまま使うのが難しい場合が多く、欠損値として扱う場合があります。

Q. あなたはラーメンが好きですか。

* 1.非常にそう思う
* 2.そう思う
* 3.どちらかと言えばそう思う
* 9.答えたくない

以上の選択肢に対する10人の回答が格納されているデータフレーム (`Ramen.df`)があるとします。データフレームは2つの列があり、`ID`列は回答者のID、`Ramen`列は以上の質問文に対する答えが入っています。

```{r}
Ramen.df <- data.frame(
  ID    = 1:10,
  Ramen = c(1, 1, 2, 1, 3, 1, 9, 2, 1, 9)
)
```
```{r}
Ramen.df
```

ここの`Ramen`列に対して、`Ramen == 9`なら`NA`を割り当て、それ以外の場合は元の値を割り当てるとします。そしてその結果を`Ramen.df`の`Ramen`列に上書きします。これは以下のように書くことができます。

```{r}
Ramen.df$Ramen <- ifelse(Ramen.df$Ramen == 9, NA, Ramen.df$Ramen)

Ramen.df
```

これは`Ramen.df$Ramen`の値が9なら`NA`を、それ以外なら元の値を格納し、結果を`Ramen.df$Ramen`に上書きすることを意味します。

また、`ifelse()`の中に`ifelse()`を使うことも可能です。`Scores`ベクトルの例を考えてみましょう。ここで90点以上ならS、80点以上ならA、70点以上ならB、60点以上ならCを割り当て、それ以外はDを返すとします。この結果を`Grade`という変数に格納してみましょう。

```{r}
Grade <- ifelse(Scores >= 90, "S", 
                ifelse(Scores >= 80 & Scores < 90, "A",
                       ifelse(Scores >= 70 & Scores < 80, "B",
                              ifelse(Scores >= 60 & Scores < 70, "C", "D"))))
```

```{r}
Grade
```

これは`ifelse()`の条件が`FALSE`の場合、次の`ifelse()`で判定する仕組みとなっています。しかし、`ifelse()`を使いすぎるとコードの可読性が非常に落ちてしまうので、あまり例ではありません。しかも`ifelse()`の中に`ifelse()`を書く場合、`&`や`|`を用いることが多く、更に可動性が落ちてしまいます。この場合は`dplyr`パッケージに含まれている`case_when()`関数を推奨します。この関数に関しては「[dplyr入門](../dplyr_intro/)」で詳細に説明する予定ですが、ここでは上のコードと同じ処理を行う`case_when()`関数を書く方を紹介します。

```{r}
Grade2 <- dplyr::case_when(Scores >= 90 ~ "S",
                           Scores >= 80 & Scores < 90 ~ "A",
                           Scores >= 70 & Scores < 80 ~ "B",
                           Scores >= 60 & Scores < 70 ~ "C",
                           Scores <  60 ~ "D")
```

```{r}
Grade2
```

### `switch()`による条件分岐

`switch()`は基本的に与えられた**長さ1**の文字列[^switch]を用いた条件分岐となります。これは単体で使われうことがほぼなく、自作関数内に使われる場合があります。したがって、この節はとりあえず飛ばし、関数の節を読んでから戻ってきてください。

[^switch]: 長さ1の数値型ベクトルにも使えますが、実際に使われる例はあまりありません。

ここでは2つの数値`x`と`y`の加減乗除を行う関数`myCalc`を作成します。この関数は`x` と`y`以外にも`method`引数があり、この`method`の値によって行う処理が異なります。たとえば、`method = "+"`なら足し算を、`method = "*"`なら掛け算を行う仕組みです。

```{r}
myCalc <- function(x, y, method) {
  switch(method,
         "+" = x + y,
         "-" = x - y,
         "*" = x * y,
         "/" = x / y,
         stop("method引数は+, -, *, /のみ使用可能です。")
         )
}
```

このコードの中身をみてみましょう。重要なのは2行目から8行目の部分です。`switch()`文の最初の引数は条件を判定する長さ1のベクトルです。ここではこれが`method`引数となります。そして、`method`引数によって異なる処理を行うわけです。`"+" = x + y`は「`method`の値が`"+"`の場合、`x + y`を実行する」ことを意味します。これを他の演算子に対しても指定します。最後の引数は条件に合っていない場合の処理内容です。ここでは`"method引数は+, -, *, /のみ使用可能です。"`というメッセージを出力させ、関数を中止させるという意味で、`stop("method引数は+, -, *, /のみ使用可能です。")`を入れました。

むろん、以上のコードは`if()`文を使うことも可能です。

```{r}
#| eval: false
myCalc <- function(x, y, method) {
  
  if (method == "+") {
    return(x + y)
  } else if (method == "-") {
    return(x - y)
  } else if (method == "*") {
    return(x * y)
  } else if (method == "/") {
    return(x / y)
  } else {
    stop("method引数は+, -, *, /のみ使用可能です。")
  }
  
}
```

また、`match.arg()`関数を使って事前に使える引数を指定しておき、該当しない場合は関数の処理を中止させることもできます。基本的には上の書き方より以下の書き方が推奨されます。

```{r}
#| eval: false
myCalc <- function(x, y, method = c("+", "-", "*", "/")) {
  
  method <- match.arg(method)
  
  if (method == "+") {
    return(x + y)
  } else if (method == "-") {
    return(x - y)
  } else if (method == "*") {
    return(x * y)
  } else {
    return(x / y)
  } 
}
```

異なる点は`function()`の中に`method`のデフォルト値をベクトルとしてした点です。これは「`method`引数はこれらの値以外は許さない」ということを意味します。むろん、普通のデフォルト値としてベクトルを指定することも可能ですが、このような使い方もあります。そして`match.arg()`関数についてですが、これは`method`引数が予め指定されていた引数の値と一致するか否かを判断する関数です。もし、予め指定されていた引数と一致しない場合、エラーを表示させ、処理を中断します。ちなみに、`match.arg()`は`swith()`文と組み合わせて使うことも可能です。。

今回の例の場合、`switch()`文の方が読みやすいコードですが、`if()`でも十分に使えます。また、条件によって行う処理が複雑な場合は`switch()`よりも`if()`の方が使いやすいです。

```{r}
#| error: true
myCalc(5, 3, "+")
myCalc(5, 3, "-")
myCalc(5, 3, "*")
myCalc(5, 3, "/")
```

それでは`"+"`、`"-"`、`"*"`、`"/"`以外の値を`method`に与えたらどうなるでしょうか。ここでは`"^"`を入れてみましょう。

```{r}
#| error: true
myCalc(5, 3, "^")
```

`stop()`内に書いたエラーメッセージが表示され、処理は中止されます。

## 関数の作成 {#programming-function}

これまで`class()`や、`sum()`、`print()`など様々な関数を使ってきました。関数は`関数名(引数)`の書き方をします。関数とは`()`内の引数のデータを関数内部の手続きに沿って処理し、その結果を返す関数です。したがって、関数は「データだけ違って、同じ処理を行いたい」場合に非常に便利です。

ベクトル`c(1, 2, 3, 4, 5)`の総和を計算する方法について考えてみましょう。まず、1つ目は単純に足し算をする方法があります。

```{r}
1 + 2 + 3 + 4 + 5
```

他にも反復処理を使うことも可能です。とりわけ、`1:100`のようなベクトルを1つ目の方法で記述するのは時間の無駄でしょう。`for()`文を使った方法は以下のようになります。

```{r}
Result <- 0

for (i in 1:5) {
  Result <- Result + i  
}
```

```{r}
Result
```

数個の数字を足すだけなら方法1の方が楽でしょうし、数百個の数字の場合は方法2の方が効率的です。それでもやはり`sum()`関数の方が数倍は効率的です。また、関数を使うことで、スクリプトの量をへらすこともできます。1から100までの総和なら、方法2の`for (i in 1:5)`を`for (i in 1:100)`に変えることで対応可能ですが、それでも全体としては数行のコードで書かなくてもなりません。一方、`sum(1:100)`なら一行で済みます。

`sum()`はまだマシな方です。たとえば、回帰分析をしたい場合、毎回回帰分析のコードを一から書くのはあまりにも非効率的です。`lm()`関数を使うと、データや回帰式などを指定するだけで、一連の作業を全て自動的に行い、その結果を返してくれます。中には回帰式の係数も計算してくれますが、他にも残差や決定係数なども計算してくれます。その意味で、`lm()`という関数は複数の機能を一つの関数としてまとめたものでもあります。

これらの関数は既にR開発チームが書いた関数ですが、ユーザー側から関数を作成することも可能です。長いコードを書く、同じ作業を繰り返す場合、関数の作成はほぼ必須とも言えます。ここではまず、簡単な関数を作成してみましょう。与えられた数字を二乗し、その結果を返す`myPower()`関数を作ってみましょう。

```{r}
myPower <- function(x) {
  x^2
}
```

```{r}
# 引数が一つしかないので、myPower(24)も可能
myPower(x = 24)
```

それではコードを解説します。関数は以下のように定義されます。

```
関数名 <- function (引数名) {
  処理内容
}
```

まず、関数名を`myPower`とし、それが関数であることを宣言します。そして、この関数の引数の名前は`x`とします。それが

```
myPower <- function (x)
```

の部分です。続いて、`{}`内に処理内容を書きます。今回は`x^2`であり、これは`x`の2乗を意味します。そして、関数の処理結果が返されますが、`{}`内の最後の行が結果として返されます。`x^2`の部分は`return(x^2)`と書き換えることも可能です。`return()`は「この結果を返せよ」という意味の関数ですが、返す結果が最後の行である場合、省略可能であり、Hadely先生もこのような書き方を推奨しています。

それでは、もうちょっと複雑な関数を作成してみましょう。ベクトルを引数とし、その和を計算する`mySum()`という関数です。要するに`sum()`関数を再現したものです。

```{r}
# mySum関数を定義し、引数はxのみとする
mySum <- function(x) {
  # 結果を格納するベクトルResultを生成し、0を入れておく
  Result <- 0
  
  # xの要素をiに一つずつ入れながら反復処理
  for (i in x) {
    # Resultに既存のResultの値にiを足した結果を上書きする
    Result <- Result + i
  }
  
  # Resultを返す
  Result
}
```

```{r}
mySum(1:5)
```

普通の`sum()`関数と同じ動きをする関数が出来上がりました。よく見ると、上で説明した総和を計算する方法2のコードを丸ごと関数内に入っているだけです。変わったところがあるとすれば、`for()`文であり、`for (i in 1:5)`が`for (i in x)`に変わっただけです。ここの`x`は`mySum <- function (x)`の`x`を意味します。このように関数を一回作成しておくと、これからは総和を出す作業を1行に短縮することができます。

この`mySum()`ですが、一つ問題があります。それは`x`に欠損値が含まれている場合、結果が`NA`になることです。

```{r}
mySum(c(1, 2, 3, NA, 5))
```

実際、R内蔵関数である`sum()`も同じですが、`sum()`には`na.rm =`というもう一つの引数があり、これを`TRUE`にすることで欠損値を除いた総和が計算できます。つまり、関数は複数の引数を持つことができます。それでは、`mySum()`を改良してみましょう。ここにも`na.rm`という関数を追加し、`na.rm`引数が`TRUE`の場合、`x`から欠損値を除いた上で総和を計算するようにしましょう。

```{r}
mySum <- function(x, na.rm = FALSE) {
  if (na.rm == TRUE) {
    x <- x[!is.na(x)]
  }
  
  Result <- 0
  
  for (i in x) {
      Result <- Result + i
  }
  
  Result
}
```

```{r}
mySum(c(1, 2, 3, NA, 5))
mySum(c(1, 2, 3, NA, 5), na.rm = FALSE)
mySum(c(1, 2, 3, NA, 5), na.rm = TRUE)
```

変わったところは、まず`function (x)`が`function (x, na.rm = FALSE)`になりました。これは`x`と`na.rm`の引数が必要であるが、`na.rm`のデフォルト値は`FALSE`であることを意味します。デフォルト値が指定されている場合、関数を使用する際、その引数は省略できます。実際、`sum()`関数の`na.rm`引数も`FALSE`がデフォルトとなっており、省略可能となっています。

次は最初に条件分岐が追加されました。ここでは`na.rm`が`TRUE`の場合、`x`から欠損値を抜いたベクトルを`x`に上書きするように指定しました。もし、`FALSE`ならこの処理は行いません。

これでR開発チームが作成した`sum()`関数と同じものが出来上がりました。それでは引数の順番について簡単に解説し、もうちょっと複雑な関数を作ってみましょう。引数の順番は基本的に`function()`の`()`内で定義した順番であるなら、引数名を省略することも可能です。

```{r}
mySum(c(1, 2, 3, NA, 5), TRUE)
```

ただし、順番を逆にすると、以下のようにわけのわからない結果が返されます。

```{r}
#| error: true
mySum(TRUE, c(1, 2, 3, NA, 5))
```

任意の順番で引数を指定する場合、引数名を指定する必要があります。

```{r}
mySum(na.rm = TRUE, x = c(1, 2, 3, NA, 5))
```

自分で関数を作成し、他の人にも使ってもらう場合、引数名、順番、デフォルト値を適切に設定しておくことも大事です。

**ちょっと複雑な関数を作ってみよう**

それではちょっとした遊び心を込めた関数を作ってみましょう。その名もドラクエ戦闘シミュレーターです。

以下はドラクエ11のダメージ公式です。

* ダメージの基礎値 = (攻撃力 / 2) - (守備力 / 4)
    * 0未満の場合、基礎値は0とする
* ダメージの幅 = (ダメージの基礎値 / 16) + 1
    * 端数は切り捨てます (`floor()`関数使用)

ダメージの最小値は「ダメージの基礎値 - ダメージの幅」、最大値は「ダメージの基礎値 - ダメージの幅」となります。この最小値が負になることもありますが、その場合は0扱いになります。実際のダメージはこの範囲内でランダムに決まります (`runif()`関数使用)。

```{r}
# DQ_Attack関数を定義
DQ_Attack <- function(attack, defence, hp, enemy) {
  ## 引数一覧
  ## attack: 勇者の力 + 武器の攻撃力 (長さ1の数値型ベクトル)
  ## defence: 敵の守備力 (長さ1の数値型ベクトル)
  ## hp: 敵のHP (長さ1の数値型ベクトル)
  ## enemy: 敵の名前 (長さ1の文字型ベクトル)
  
  # ダメージの基礎値
  DefaultDamage <- (attack / 2) - (defence / 4)
  # ダメージの基礎値が負の場合、0とする
  DefaultDamage <- ifelse(DefaultDamage < 0, 0, DefaultDamage)
  # ダメージの幅
  DamageWidth   <- floor(DefaultDamage / 16) + 1
  
  # ダメージの最小値
  DamageMin     <- DefaultDamage - DamageWidth
  # ダメージの最小値が負の場合、0とする
  DamageMin     <- ifelse(DamageMin < 0, 0, DamageMin)
  # ダメージの最大値
  DamageMax     <- DefaultDamage + DamageWidth
  
  # 敵の残りHPを格納する
  CurrentHP     <- hp
  
  # 残りHPが0より大きい場合、以下の処理を繰り返す
  while (CurrentHP > 0) {
    # ダメージの最小値から最大値の間の数値を1つ無作為に抽出する
    Damage <- runif(n = 1, min = DamageMin, max = DamageMax)
    # 小数点1位で丸める
    Damage <- round(Damage, 0)
    # 残りのHPを更新する
    CurrentHP <- CurrentHP - Damage
    # メッセージを表示
    print(paste0(enemy, "に", Damage, "のダメージ!!"))
  }
  
  # 上記の反復処理が終わったら勝利メッセージを出力
  paste0(enemy, "をやっつけた！")
}
```

初めて見る関数が3つありますね。まず、`floor()`関数は引数の端数は切り捨てる関数です。たとえば、`floor(2.1)`も`floor(2.6)`も結果は2です。続いて、`runif()`関数は指定された範囲の一様分布から乱数を生成する関数です。引数は生成する乱数の個数 (`n`)、最小値 (`min`)、最大値 (`max`)の3つです。`runif(5, 3, 10)`なら最小値3、最大値10の乱数を5個生成するという意味です。正規分布は平均値周辺の値が生成されやすい一方、一様分布の場合、ある値が抽出される確率は同じです。最後に`round()`関数は四捨五入の関数です。引数は2つあり、1つ目の引数は数値型のベクトルです。2つ目は丸める小数点です。たとえば、`round(3.127, 1)`の結果は`3.1`であり、`round(3.127, 2)`の結果は`3.13`となります。

それでは「ひのきのぼう」を装備したレベル1の勇者を考えてみましょう。ドラクエ5の場合、Lv1勇者の力は11、「ひのきのぼう」の攻撃力は2ですので、攻撃力は13です。まずは定番のスライムから狩ってみましょう。スライムのHPと守備力は両方7です。

```{r}
DQ_Attack(13, defence = 7, hp = 7, "スライム")
```

まぁ、こんなもんでしょう。それではスライムナイト (=ピエール)はどうでしょう。スライムナイトのHPのは40、守備力は44です。

```{r}
DQ_Attack(13, defence = 44, hp = 40, "スライムナイト")
```

これだと「なんと　スライムナイトが　おきあがりなかまに　なりたそうに　こちらをみている！」のメッセージを見る前に勇者ご一行が全滅しますね。エスターク (HP: 9000 / 守備力: 250)は計算するまでもないでしょう...

以上の関数に条件分岐を追加することで「かいしんの　いちげき！」を入れることもできますし[^Kaisin]、逆に敵からの攻撃を計算して誰が先に倒れるかをシミュレーションすることも可能でしょうね。色々遊んでみましょう。

[^Kaisin]: 一般的に会心の一撃が出る確率は約3.125% (=1/32)または約1.563% (=1/64)と言われています。

### 関数 in 関数

当たり前かも知れまっせんが、自作関数を他の自作関数に含めることもできます。ここでは乱数を生成する関数を作ってみましょう。パソコンだけだと完全な乱数を作成することは不可能ですが[^randomnumber]、乱数に近いものは作れます。このようにソフトウェアで生成された乱数は擬似乱数と呼ばれ、様々なアルゴリズムが提案されています。天才、フォン・ノイマン大先生も乱数生成では天才ではなかったらしく、彼が提案した平方採中法 (middle-square method)は使い物になりませんので、ここではもうちょっとマシな方法である線形合同法 (linear congruential generators; 以下、LCG)を採用します。平方採中法よりは式が複雑ですが、それでも非常に簡単な式で乱数が生成可能であり、Rによる実装に関しては平方採中法より簡単です。ちなみに、線形合同法にも様々な問題があり、Rのデフォルトは広島大学の[松本眞](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/index.html)先生と山形大学の[西村拓士](http://yudb.kj.yamagata-u.ac.jp/html/428_ja.html)先生が開発しましたメルセンヌ・ツイスタ (Mersenne twister)を採用しています。それでは、LCGのアルゴリズムから見ましょう。

[^randomnumber]: 特殊なハードウェアを使えば周囲の雑音や電波などのノイズから乱数を生成することも可能です。

乱数の列があるとし、$n$番目の乱数を$X_n$とします。この場合、$X_{n+1}$は以下のように生成されます。

$$
X_{n+1} = (aX_n + c) \text{ mod } m
$$
$\text{mod}$は余りを意味し、$5 \text{mod} 3$は5を3で割った際の余りですので、2となります。$a$と$c$、$m$は以下の条件を満たす任意の数です。

\begin{align}
0 < &  m, \\
0 < &  a < m, \\
0 \leq &  c < m.
\end{align}

ベストな$a$、$c$、$m$も決め方はありませんが、ここではTurbo Cの設定を真似て$a = 22695477$、$c = 1$、$m = 2^{32}$をデフォルト値として設定します[^lcg_ansi_c]。そして、もう一つ重要なのが最初の数、つまり$X_n$をどう決めるかですが、これは自由に決めて問題ありません。最初の数 ($X_0$)はシード (seed)と呼ばれ、最終的には使わない数字となります。それでは`seed`という引数からある乱数を生成する関数`rng_number()`を作ってみましょう。

[^lcg_ansi_c]: ANSI C標準の場合、$a = 1103515245$、$c = 12345$、$m = 2^{31}$です。

```{r}
rng_number <- function(seed, a = 22695477, c = 1, m = 2^32) {
  (a * seed + c) %% m
}
```

簡単な四則演算のみで構成された関数ですね。ちなみに`%%`は余りを計算する演算子です。とりあえず、`seed`を12345に設定し、一つの乱数を生成してみましょう。

```{r}
rng_number(12345)
```

かなり大きい数字が出ました。ちなみに線形合同法で得られる乱数の最大値は$m$、最小値は0です。次は、今回得られた乱数`r rng_number(12345)`を新しい`seed`とし、新しい乱数を作ってみましょう。

```{r}
rng_number(1002789326)
```

この作業を繰り返すと、(疑似)乱数の数列が得られます。続いて、この作業を`n`回繰り返し、長さ`n`の乱数ベクトルを返す関数`LCG`を作ってみましょう。いかがコードになります。

```{r}
LCG <- function(n, seed, a = 22695477, c = 1, m = 2^32) {
  rng_vec    <- rep(NA, n + 1) # seedも入るので長さn+1の空ベクトルを生成
  rng_vec[1] <- seed           # 1番目の要素にseedを入れる
  
  # iに2からn+1までの値を順次的に投入しながら、反復処理
  for (i in 2:(n+1)) {
    # rng_vecのi番目にi-1番目の要素をseedにした疑似乱数を格納
    rng_vec[i] <- rng_number(rng_vec[i - 1], a, c, m)
  }
  
  rng_vec <- rng_vec[-1] # 1番目の要素 (seed)を捨てる
  rng_vec <- rng_vec / m # 最小値0、最大値1になるように、mで割る
  
  rng_vec # 結果を返す
}
```

それでは、詳細に解説します。

* 1行目: 関数`LCG`を定義し、必要な引数として`n`と`seed`を設定する。
* 2行目: 結果を格納する空ベクトル`rng_vec`を生成。ただし、1番目には`seed`が入るので、長さを`n+1`とする。
* 3行目: `rng_vec`の1番目に`seed`を格納する。
* 6行目: 疑似乱数を`n`回生成し、格納するように反復作業を行う。任意の変数は`i`とし、`i`に代入される値は2から`n+1`までである。
* 8行目: `rng_vec`の`i-1`番目要素を`seed`にした疑似乱数を生成し、`rng_vec`の`i`番目に格納する。1回目の処理だと`i=2`であるため、`rng_vec[1]` (= `seed`)を`seed`にした疑似乱数が生成され、`rng_vec[2]`に格納される。
* 11行目: `rng_vec`の1番目の要素は`seed`であるため、捨てる。
* 12行目: 乱数が最小値0、最大値1になるように、調整する。具体的には得られた乱数を`m` (デフォルトは$2^{32}$)で割るだけである。
* 14行目: 結果ベクトルを返す。

それでは、`seed`を[19861008](https://www.jaysong.net)とした疑似乱数10000個を生成し、`LCG_Numbers`という名のベクトルに格納してみましょう。結果を全て表示させるのは無理があるので、最初の20個のみを確認してみます。

```{r}
LCG_Numbers <- LCG(10000, 19861008)
head(LCG_Numbers, 20)
```

正直、これが乱数かどうかは見るだけでは分かりませんね。簡単な確認方法としては、これらの乱数列のヒストグラムを見れば分かります。得られた数列が本当に乱数(に近いもの)なら、その分布は一様分布に従っているからです。ただし、一様分布に従っていることが乱数を意味するものではありません。

可視化については割愛しますが、ここでは簡単に`hist()`関数を使ってみましょう。必要な引数はnumeric型のベクトルのみです。以下のコードにある`xlab =`などはラベルを指定する引数ですが、省略しても構いません。

```{r}
hist(LCG_Numbers, xlab = "乱数", ylab = "度数", 
     main = "生成された乱数10000個のヒストグラム")
```

ややギザギザしているように見えますが[^largenumber]、これなら一様分布だと考えて良いでしょう。

[^largenumber]: 1万個ではなく、100万個、1億個など乱数を生成すればするほど、一様分布に近づきます。