<!DOCTYPE html>
<html lang="ja-jp">
    <head>
        <script defer src="/fa/fontawesome-all.js"></script>
        

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>dplyr入門 (新版)</title>
        
        <style>

    html body {
        font-family: 'Noto Sans JP', sans-serif;
        background-color: white;
    }

    :root {
        --accent: darkred;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://www.jaysong.net/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto%20Sans%20JP">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/R.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/php.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/html.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.84.2" />
        

        
            <script async src="https://www.googletagmanager.com/gtag/js?id=UA-96999602-1"></script>
            <script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments)};
              gtag('js', new Date());
              gtag('config', 'UA-96999602-1');
              gtag('set', {'user_id': 'USER_ID'});
            </script>

            <script>
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-96999602-1', 'auto');
                ga('send', 'pageview');
            </script>
        

        <meta name="google-site-verification" content="QJouPRaPKBPU1jDp6VaBuFbVV5imTI-Aazl_ScJwVgU" />

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">dplyr入門 (新版)</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/about/">CV</a></li>
                            
                                <li><a href="/research/">Research</a></li>
                            
                                <li><a href="/teaching/">Teaching</a></li>
                            
                                <li><a href="/software/">Software</a></li>
                            
                                <li><a href="/notes/">Notes</a></li>
                            
                                <li><a href="/tutorial/">Tutorial</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:song@kansai-u.ac.jp"><i class="far fa-envelope"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://twitter.com/Tintstyle/"><i class="fab fa-twitter"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.facebook.com/tintstyle"><i class="fab fa-facebook"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.instagram.com/tintstyle/"><i class="fab fa-instagram"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/JaehyunSong/"><i class="fab fa-github"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2><center>dplyr入門 (新版)</center></h2>
        <h5><center></center></h5>
        <center>
<a href="https://www.jaysong.net/tags/%E7%B5%B1%E8%A8%88%E5%AD%A6"><kbd class="item-tag">統計学</kbd></a>

<a href="https://www.jaysong.net/tags/r"><kbd class="item-tag">R</kbd></a>

<a href="https://www.jaysong.net/tags/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AA%E3%83%B3%E3%82%B0"><kbd class="item-tag">データハンドリング</kbd></a>

</center>
    </div>

    <div align="start" class="content">
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<script src="/rmarkdown-libs/kePrint/kePrint.js"></script>
<link href="/rmarkdown-libs/lightable/lightable.css" rel="stylesheet" />


<div id="はじめに" class="section level2">
<h2>はじめに</h2>
<ul>
<li>修正履歴
<ul>
<li>2020/06/28: 公開</li>
<li>2020/07/01: データの結合を追加</li>
<li>2020/07/03: factor型の扱い方を追加</li>
<li>誤字・脱字は随時修正しております。</li>
</ul></li>
<li>以下の内容は現在執筆中の内容の一部となります。
<ul>
<li><a href="https://www.jaysong.net/RBook/">Song Jaehyun・矢内勇生『私たちのR: ベストプラクティスの探求』(E-book)</a>
<ul>
<li>前半は「データハンドリング [基礎編: 抽出]」章、後半は「データハンドリング [基礎編: 拡張]」章に基づいており、factor型の扱いについては「データハンドリング [基礎編: factor型]」章を一部抜粋しております。</li>
</ul></li>
<li>したがって、いきなり<strong>オブジェクト</strong>、<strong>関数</strong>、<strong>引数</strong>といった馴染みのない概念が出てきます。これらの概念に馴染みのない方は、予め「<a href="../rprogramming/">Rプログラミング入門の入門</a>」をご一読ください。</li>
</ul></li>
<li>2020年6月に公開されましたdplyr 1.0.0に対応しております。</li>
<li>2016年5月に作成しました旧版は<a href="../dplyr_intro_old/">ここ</a>から閲覧できます。</li>
<li>実習データは<a href="../Data/Ramen.csv">ここ</a>からダウンロード可能です。</li>
</ul>
<hr />
</div>
<div id="パッケージと実習用データの読み込み" class="section level2">
<h2>パッケージと実習用データの読み込み</h2>
<p>パッケージは<code>dplyr</code>でも、<code>tidyverse</code>でもどれでも構いません。ここではデータをtibble型として読み込むため、<code>tidyverse</code>を読み込んでおきます。</p>
<pre class="r numberLines"><code>library(tidyverse)</code></pre>
<pre><code>## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──</code></pre>
<pre><code>## ✓ ggplot2 3.3.3     ✓ purrr   0.3.4
## ✓ tibble  3.1.2     ✓ dplyr   1.0.6
## ✓ tidyr   1.1.3     ✓ stringr 1.4.0
## ✓ readr   1.4.0     ✓ forcats 0.5.1</code></pre>
<pre><code>## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<p>それでは今回の実習用データを読み込みましょう。<a href="../Data/Ramen.csv">Ramen.csv</a>には「<a href="https://www.gnavi.co.jp">ぐるなび</a>」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。</p>
<p>まず、このデータを読み込み、<code>df</code>という名付けます。R内蔵関数である<code>read.csv()</code>を使ってデータを読み込んでも以下の内容を実習するにあたって全く問題はございません。<code>read.csv()</code>から読み込まれたデータのクラスはデータフレーム、<code>read_csv()</code>の場合はtibbleです。tibbleはデータフレームの拡張版であり、データフレームで可能な操作は全てtibbleにおいても可能です。ここではtibbleを使いますが、こちらの方が、結果が読みやすく出力されるからです。</p>
<pre class="r numberLines"><code># ファイルのパスは適宜修正してください
df &lt;- read_csv(&quot;Data/Ramen.csv&quot;)</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   ID = col_character(),
##   Name = col_character(),
##   Pref = col_character(),
##   Zipcode = col_double(),
##   Latitude = col_double(),
##   Longitude = col_double(),
##   Line = col_character(),
##   Station = col_character(),
##   Walk = col_double(),
##   Bus = col_double(),
##   Car = col_double(),
##   Budget = col_double(),
##   ScoreN = col_double(),
##   Score = col_double()
## )</code></pre>
<p>本サンプルデータはUTF-8で保存されており、文字化けが生じる場合、以下のように対処してください。</p>
<pre class="r"><code># readrパッケージのread_csv()を使う場合
df &lt;- read_csv(&quot;Data/Ramen.csv&quot;, locale = locale(encoding = &quot;utf8&quot;))

# R内臓のread.csv()を使う場合
df &lt;- read_csv(&quot;Data/Ramen.csv&quot;, fileEncoding = &quot;utf8&quot;)</code></pre>
<p>データの中身を確認してみましょう。</p>
<pre class="r numberLines"><code>df</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    ID     Name  Pref  Zipcode Latitude Longitude Line  Station  Walk   Bus   Car
##    &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 e5396… 居酒… 東京… 1040031     35.7      140. 地下… 銀座一…     3    NA    NA
##  2 gfeb6… 本格… 東京… 1100005     35.7      140. 地下… 仲御徒…     1    NA    NA
##  3 ggt59… 食べ… 東京… 1250041     35.8      140. ＪＲ… 金町駅      2    NA    NA
##  4 g1813… 博多… 東京… 1920904     35.7      139. ＪＲ  八王子…     1    NA    NA
##  5 ggww1… まさ… 東京… 1500042     35.7      140. 地下… 渋谷駅      7    NA    NA
##  6 gdzk5… 完全… 東京… 1000013     35.7      140. 地下… 虎ノ門…     3    NA    NA
##  7 ga2g2… 鶏そ… 東京… 1760006     35.7      140. 西武… 江古田…     2    NA    NA
##  8 gg9m1… 宴会… 東京… 1010021     35.7      140. ＪＲ  秋葉原…     4    NA    NA
##  9 gdvk2… 中国… 東京… 1000006     35.7      140. ＪＲ  有楽町…     1    NA    NA
## 10 gggb2… 中国… 東京… 1140002     35.8      140. 地下… 王子駅      2    NA    NA
## # … with 6,282 more rows, and 3 more variables: Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;,
## #   Score &lt;dbl&gt;</code></pre>
<p>1行目の<code># A tibble: 6,292 x 14</code>から、ケース数 (店舗数)は6292、変数は14個あることが分かります。各変数の詳細は以下の通りです。</p>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
変数名
</th>
<th style="text-align:left;">
説明
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<code>ID</code>
</td>
<td style="text-align:left;">
店舗ID
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Name</code>
</td>
<td style="text-align:left;">
店舗名
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Pref</code>
</td>
<td style="text-align:left;">
店舗の所在地 (都府県)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Zipcode</code>
</td>
<td style="text-align:left;">
店舗の郵便番号
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Latitude</code>
</td>
<td style="text-align:left;">
緯度
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Longitude</code>
</td>
<td style="text-align:left;">
経度
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Line</code>
</td>
<td style="text-align:left;">
最寄りの駅の路線
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Station</code>
</td>
<td style="text-align:left;">
最寄りの駅
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Walk</code>
</td>
<td style="text-align:left;">
最寄りの駅からの距離 (徒歩; 分)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Bus</code>
</td>
<td style="text-align:left;">
最寄りの駅からの距離 (バス; 分)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Car</code>
</td>
<td style="text-align:left;">
最寄りの駅からの距離 (車; 分)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Budget</code>
</td>
<td style="text-align:left;">
平均予算 (円)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>ScoreN</code>
</td>
<td style="text-align:left;">
口コミの数
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Score</code>
</td>
<td style="text-align:left;">
口コミ評価の平均値
</td>
</tr>
</tbody>
</table>
<p>それではここからは<code>df</code>を用いた<code>dplyr</code>の様々な機能を紹介していきます。</p>
<hr />
</div>
<div id="パイプ演算子" class="section level2">
<h2>パイプ演算子 (<code>%&gt;%</code>)</h2>
<p><code>dplyr</code>パッケージを利用する前にパイプ演算子について説明します。パイプ演算子は<code>dplyr</code>に含まれている演算子ではなく、<code>magrittr</code>という別のパッケージから提供される演算子ですが、<code>tidyverse</code>パッケージを読み込むと自動的に読み込まれます。パイプ演算子は<code>x %&gt;% y()</code>のような書き方となりますが、これは「<code>x</code>を<code>y()</code>の第一引数として渡す」ことを意味します。<code>x</code>の部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。つまり、<code>x() %&gt;% y()</code>という使い方も可能です。そして、パイプは無限に繋ぐこともできます。「データ<code>df</code>を関数<code>x()</code>で処理をし、その結果をまた関数<code>y()</code>で処理する」ことは、パイプを使うと<code>df %&gt;% x() %&gt;% y()</code>のような書き方となります。</p>
<p>たとえば、「<code>paste(3, "+", 5, "=", 8)</code>を実行し、その結果を<code>rep()</code>関数を使って3回複製し、それを<code>print()</code>を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。</p>
<pre class="r numberLines"><code># 方法1: 一関数一オブジェクト
Result1 &lt;- paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8)
Result2 &lt;- rep(Result1, 3)
print(Result2)</code></pre>
<pre><code>## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot;</code></pre>
<pre class="r numberLines"><code># 方法2: 関数の中に関数の中に関数
print(rep(paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8), 3))</code></pre>
<pre><code>## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot;</code></pre>
<p>どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。</p>
<p>コードの可読性と書く手間、両方を満足する書き方がパイプ演算子<code>%&gt;%</code>です。まずは、例から見ましょう。</p>
<pre class="r"><code># %&gt;%を使う
paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print()</code></pre>
<pre><code>## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot;</code></pre>
<p>まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、<code>paste(3, "+", 5, "=", 8)</code>を実行します。そしてその結果をそのまま<code>rep()</code>関数の第一引数として渡されます。つまり、<code>rep(paste(3, "+", 5, "=", 8), 3)</code>になるわけです。ここでは<code>rep(3)</code>と書きましたが、第一引数が渡されたため、<code>3</code>は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまた<code>print()</code>関数に渡します。結果としては<code>print(rep(paste(3, "+", 5, "=", 8), 3))</code>となります。</p>
<p>関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左 (上)から右 (下)へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。</p>
<pre class="r numberLines"><code># 改行 (+字下げ)したらもっと読みやすくなる
paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% 
    rep(3) %&gt;% 
    print()</code></pre>
<p>パイプ演算子を使わない方法は図<a href="#fig:pipe1">1</a>のようにイメージできます。一回の処理ごとに結果を保存し、それをまた次の処理時においてデータとして使うイメージです。</p>
<div class="figure" style="text-align: center"><span id="fig:pipe1"></span>
<img src="Figures/Handling1/Pipeline1.png" alt="パイプ演算子を使わない場合" width="444" />
<p class="caption">
Figure 1: パイプ演算子を使わない場合
</p>
</div>
<p>一方、図<a href="#fig:pipe2">2</a>はパイプ演算子を使う場合のプロセスです。処理後の結果を保存せず、すぐに次のプロセスに渡すことで、メモリ (図だとボウル)や時間、コードの無駄を減らすことができます。むろん、図<a href="#fig:pipe1">1</a>の結果1を使って色々試してみたい場合は、一旦結果1までは格納し、適宜引き出して使った方が効率的でしょう。パイプ演算子はたしかに便利で、「今どき」のRの書き方を象徴するようなものですが、一つの結果を出すまであまりにも多くのパイプ演算子を使うことはあ望ましくありません。</p>
<div class="figure" style="text-align: center"><span id="fig:pipe2"></span>
<img src="Figures/Handling1/Pipeline2.png" alt="パイプ演算子を使う場合" width="100%" />
<p class="caption">
Figure 2: パイプ演算子を使う場合
</p>
</div>
<p>データハンドリングもこれど同様に、様々な作業を順に沿って行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。</p>
</div>
<div id="列の抽出" class="section level2">
<h2>列の抽出</h2>
<div id="特定の列を抽出する" class="section level3">
<h3>特定の列を抽出する</h3>
<p>まずは、データフレーム (または、tibble)から特定の列のみを残す、除去する方法について紹介します。たとえば、<code>df</code>から<code>ID</code>、<code>Name</code>、<code>Pref</code>、<code>Score</code>のみを残すとします。<code>dplyr</code>を使わない方法と<code>dplyr</code>の<code>select()</code>関数を使った方法を紹介します。</p>
<pre class="r numberLines"><code># dplyrを使わない方法
df[, c(&quot;ID&quot;, &quot;Name&quot;, &quot;Pref&quot;, &quot;Score&quot;)]</code></pre>
<pre><code>## # A tibble: 6,292 x 4
##    ID      Name                                                     Pref   Score
##    &lt;chr&gt;   &lt;chr&gt;                                                    &lt;chr&gt;  &lt;dbl&gt;
##  1 e539604 居酒屋 龍記 京橋店                                       東京都 NA   
##  2 gfeb600 本格上海料理 新錦江 上野御徒町本店                       東京都  4.5 
##  3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ）               東京都 NA   
##  4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA   
##  5 ggww100 まさ屋 渋谷店                                            東京都 NA   
##  6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店              東京都 NA   
##  7 ga2g202 鶏そば きらり                                            東京都 NA   
##  8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店                    東京都  3.33
##  9 gdvk200 中国料理 宝龍                                            東京都  2.5 
## 10 gggb200 中国料理 天安門                                          東京都 NA   
## # … with 6,282 more rows</code></pre>
<pre class="r numberLines"><code># dplyr::select()を使う方法
# select(df, ID, Name, Pref, Score)でもOK
df %&gt;%
  select(ID, Name, Pref, Score)</code></pre>
<pre><code>## # A tibble: 6,292 x 4
##    ID      Name                                                     Pref   Score
##    &lt;chr&gt;   &lt;chr&gt;                                                    &lt;chr&gt;  &lt;dbl&gt;
##  1 e539604 居酒屋 龍記 京橋店                                       東京都 NA   
##  2 gfeb600 本格上海料理 新錦江 上野御徒町本店                       東京都  4.5 
##  3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ）               東京都 NA   
##  4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA   
##  5 ggww100 まさ屋 渋谷店                                            東京都 NA   
##  6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店              東京都 NA   
##  7 ga2g202 鶏そば きらり                                            東京都 NA   
##  8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店                    東京都  3.33
##  9 gdvk200 中国料理 宝龍                                            東京都  2.5 
## 10 gggb200 中国料理 天安門                                          東京都 NA   
## # … with 6,282 more rows</code></pre>
<p>どれも結果は同じですが、<code>select()</code>関数を使った方がより読みやすいコードになっているでしょう。むろん、<code>select()</code>関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際は<code>select()</code>を使わない場合が多いです。ただし、一般的な分析の流れでは<code>select()</code>の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。</p>
<p><code>select()</code>関数の使い方は非常に簡単です。第一引数はデータフレーム (または、tibble)ですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレーム/tibble内の変数名です。つまり、ここには残す変数名のみを書くだけで十分です。</p>
<p>また、<code>select()</code>関数を使って列の順番を変えることもできます。たとえば、<code>ID</code>、<code>Pref</code>、<code>Name</code>、<code>Score</code>の順で列を残すなら、この順番で引数を書くだけです。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID, Pref, Name)</code></pre>
<pre><code>## # A tibble: 6,292 x 3
##    ID      Pref   Name                                                    
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;                                                   
##  1 e539604 東京都 居酒屋 龍記 京橋店                                      
##  2 gfeb600 東京都 本格上海料理 新錦江 上野御徒町本店                      
##  3 ggt5900 東京都 食べ飲み放題×中華ビストロ NOZOMI（のぞみ）              
##  4 g181340 東京都 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設
##  5 ggww100 東京都 まさ屋 渋谷店                                           
##  6 gdzk500 東京都 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店             
##  7 ga2g202 東京都 鶏そば きらり                                           
##  8 gg9m100 東京都 宴会個室×餃子酒場 北京飯店 秋葉原本店                   
##  9 gdvk200 東京都 中国料理 宝龍                                           
## 10 gggb200 東京都 中国料理 天安門                                         
## # … with 6,282 more rows</code></pre>
</div>
<div id="特定の列を抽出し列名を変更する" class="section level3">
<h3>特定の列を抽出し、列名を変更する</h3>
<p>また、特定の列を残す際、変数名を変更することも可能です。今回も<code>ID</code>、<code>Name</code>、<code>Pref</code>、<code>Score</code>のみを残しますが、<code>Pref</code>列は<code>Prefecture</code>に変えてみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID, Name, Prefecture = Pref, Score)</code></pre>
<pre><code>## # A tibble: 6,292 x 4
##    ID      Name                                                 Prefecture Score
##    &lt;chr&gt;   &lt;chr&gt;                                                &lt;chr&gt;      &lt;dbl&gt;
##  1 e539604 居酒屋 龍記 京橋店                                   東京都     NA   
##  2 gfeb600 本格上海料理 新錦江 上野御徒町本店                   東京都      4.5 
##  3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ）           東京都     NA   
##  4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル…  東京都     NA   
##  5 ggww100 まさ屋 渋谷店                                        東京都     NA   
##  6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店          東京都     NA   
##  7 ga2g202 鶏そば きらり                                        東京都     NA   
##  8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店                東京都      3.33
##  9 gdvk200 中国料理 宝龍                                        東京都      2.5 
## 10 gggb200 中国料理 天安門                                      東京都     NA   
## # … with 6,282 more rows</code></pre>
<p>抽出する際、変数を<code>新しい変数名 = 既存の変数名</code>にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここでは<code>df</code>の<code>Pref</code>を<code>Prefecture</code>に、<code>Walk</code>を<code>Distance</code>に変更してみます。<code>dplyr</code>を使わない場合と<code>dplyr</code>の<code>rename()</code>関数を使う場合を両方紹介します。</p>
<p>まずは、<code>name()</code>関数についてですが、これはデータフレーム (または、tibble)の変数名をベクトルとして出力する関数です。</p>
<pre class="r numberLines"><code>names(df)</code></pre>
<pre><code>##  [1] &quot;ID&quot;        &quot;Name&quot;      &quot;Pref&quot;      &quot;Zipcode&quot;   &quot;Latitude&quot;  &quot;Longitude&quot;
##  [7] &quot;Line&quot;      &quot;Station&quot;   &quot;Walk&quot;      &quot;Bus&quot;       &quot;Car&quot;       &quot;Budget&quot;   
## [13] &quot;ScoreN&quot;    &quot;Score&quot;</code></pre>
<p>察しの良い読者は気づいたかも知れませんが、<code>names(データフレーム/tibble名)</code>の結果はベクトルであり、上書きも可能です。つまり、<code>names(df)</code>の3番目と9番目の要素を<code>"Prefecture"</code>と<code>"Distance"</code>に上書きすることができるということです。</p>
<pre class="r numberLines"><code># dplyrを使わずに列名を変更する方法
names(df)[c(3, 9)] &lt;- c(&quot;Prefecture&quot;, &quot;Distance&quot;)

# dfの中身を出力
df</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    ID     Name      Prefecture Zipcode Latitude Longitude Line  Station Distance
##    &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      &lt;dbl&gt;
##  1 e5396… 居酒屋 …  東京都     1040031     35.7      140. 地下… 銀座一…        3
##  2 gfeb6… 本格上海… 東京都     1100005     35.7      140. 地下… 仲御徒…        1
##  3 ggt59… 食べ飲み… 東京都     1250041     35.8      140. ＪＲ… 金町駅         2
##  4 g1813… 博多餃子… 東京都     1920904     35.7      139. ＪＲ  八王子…        1
##  5 ggww1… まさ屋 …  東京都     1500042     35.7      140. 地下… 渋谷駅         7
##  6 gdzk5… 完全個室… 東京都     1000013     35.7      140. 地下… 虎ノ門…        3
##  7 ga2g2… 鶏そば …  東京都     1760006     35.7      140. 西武… 江古田…        2
##  8 gg9m1… 宴会個室… 東京都     1010021     35.7      140. ＪＲ  秋葉原…        4
##  9 gdvk2… 中国料理… 東京都     1000006     35.7      140. ＪＲ  有楽町…        1
## 10 gggb2… 中国料理… 東京都     1140002     35.8      140. 地下… 王子駅         2
## # … with 6,282 more rows, and 5 more variables: Bus &lt;dbl&gt;, Car &lt;dbl&gt;,
## #   Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt;</code></pre>
<p>簡単に変数名の変更ができました。続いて、<code>dplyr</code>の<code>rename()</code>関数を使った方法です。今回は、<code>Prefecture</code>を<code>Pref</code>に、<code>Distance</code>を<code>Walk</code>に戻して見ましょう。そして、出力するだけにとどまらず、<code>df</code>に上書きしましょう。</p>
<pre class="r numberLines"><code># dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする
df &lt;- df %&gt;%
  rename(Pref = Prefecture, Walk = Distance)</code></pre>
<p>これで終わりです。実は<code>select()</code>関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータなら<code>select()</code>でもあまり不便は感じないかも知れませんが、変数が多くなると<code>rename()</code>関数は非常に便利です。</p>
</div>
<div id="特定の列を除外する" class="section level3">
<h3>特定の列を除外する</h3>
<p>逆に、一部の変数をデータフレーム (または、tibble)から除去したい場合もあるでしょう。たとえば、緯度 (<code>Latitude</code>)と経度 (<code>Longitude</code>)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID, Name, Pref, Zipcode, 
         Line, Station, Walk, Bus, Car, Budget, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 6,292 x 12
##    ID    Name  Pref  Zipcode Line  Station  Walk   Bus   Car Budget ScoreN Score
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 e539… 居酒… 東京… 1040031 地下… 銀座一…     3    NA    NA   3000      0 NA   
##  2 gfeb… 本格… 東京… 1100005 地下… 仲御徒…     1    NA    NA   2000      2  4.5 
##  3 ggt5… 食べ… 東京… 1250041 ＪＲ… 金町駅      2    NA    NA   2980      0 NA   
##  4 g181… 博多… 東京… 1920904 ＪＲ  八王子…     1    NA    NA   2000      0 NA   
##  5 ggww… まさ… 東京… 1500042 地下… 渋谷駅      7    NA    NA    380      0 NA   
##  6 gdzk… 完全… 東京… 1000013 地下… 虎ノ門…     3    NA    NA   2980      0 NA   
##  7 ga2g… 鶏そ… 東京… 1760006 西武… 江古田…     2    NA    NA    850      0 NA   
##  8 gg9m… 宴会… 東京… 1010021 ＪＲ  秋葉原…     4    NA    NA   2000      3  3.33
##  9 gdvk… 中国… 東京… 1000006 ＪＲ  有楽町…     1    NA    NA   1000      2  2.5 
## 10 gggb… 中国… 東京… 1140002 地下… 王子駅      2    NA    NA   2000      0 NA   
## # … with 6,282 more rows</code></pre>
<p>かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは<code>-</code>を使う方法です。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(-Latitude, -Longitude) # select(-c(Latitude, Longitude))</code></pre>
<pre><code>## # A tibble: 6,292 x 12
##    ID    Name  Pref  Zipcode Line  Station  Walk   Bus   Car Budget ScoreN Score
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 e539… 居酒… 東京… 1040031 地下… 銀座一…     3    NA    NA   3000      0 NA   
##  2 gfeb… 本格… 東京… 1100005 地下… 仲御徒…     1    NA    NA   2000      2  4.5 
##  3 ggt5… 食べ… 東京… 1250041 ＪＲ… 金町駅      2    NA    NA   2980      0 NA   
##  4 g181… 博多… 東京… 1920904 ＪＲ  八王子…     1    NA    NA   2000      0 NA   
##  5 ggww… まさ… 東京… 1500042 地下… 渋谷駅      7    NA    NA    380      0 NA   
##  6 gdzk… 完全… 東京… 1000013 地下… 虎ノ門…     3    NA    NA   2980      0 NA   
##  7 ga2g… 鶏そ… 東京… 1760006 西武… 江古田…     2    NA    NA    850      0 NA   
##  8 gg9m… 宴会… 東京… 1010021 ＪＲ  秋葉原…     4    NA    NA   2000      3  3.33
##  9 gdvk… 中国… 東京… 1000006 ＪＲ  有楽町…     1    NA    NA   1000      2  2.5 
## 10 gggb… 中国… 東京… 1140002 地下… 王子駅      2    NA    NA   2000      0 NA   
## # … with 6,282 more rows</code></pre>
<p>除外したい変数名の前に<code>-</code>を付けただけです。また、<code>-Latitude</code>と<code>-Longitude</code>をそれぞれ指定せず、<code>-c(Latitude, Longitude)</code>のように<code>c()</code>でまとめるのも可能です。</p>
</div>
<div id="隣接した列を指定する" class="section level3">
<h3>隣接した列を指定する</h3>
<p>先ほど、<code>df</code>から緯度 (<code>Latitude</code>)と経度 (<code>Longitude</code>)を除外する例を考えてみましょう。<code>-</code>を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID, Name, Pref, Zipcode, 
         Line, Station, Walk, Bus, Car, Budget, ScoreN, Score)</code></pre>
<p>よく考えてみれば、<code>ID</code>から<code>Zipcode</code>は隣接した列ですし、<code>Line</code>から<code>Score</code>までもそうです。これは<code>names()</code>関数で確認できます。</p>
<pre class="r numberLines"><code>names(df)</code></pre>
<pre><code>##  [1] &quot;ID&quot;        &quot;Name&quot;      &quot;Pref&quot;      &quot;Zipcode&quot;   &quot;Latitude&quot;  &quot;Longitude&quot;
##  [7] &quot;Line&quot;      &quot;Station&quot;   &quot;Walk&quot;      &quot;Bus&quot;       &quot;Car&quot;       &quot;Budget&quot;   
## [13] &quot;ScoreN&quot;    &quot;Score&quot;</code></pre>
<p>ここで便利な演算子が<code>:</code>です。これまで、<code>x</code>から<code>y</code>までの公差1の等差数列を作成する際に<code>x:y</code>を使って来ましたが、これに非常に似ています。データフレーム (または、tibble)の「<code>x</code>列から<code>y</code>列まで」の表記も<code>select()</code>関数内では<code>:</code>と書くことができます。したがって、上記のコードは以下のように短縮化可能です。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID:Zipcode, Line:Score)</code></pre>
<p>「<code>df</code>の<code>ID</code>から<code>Zipcode</code>まで、そして<code>Line</code>から<code>Score</code>までの列を選択する」という意味です。非常に便利な演算子ですので、<code>-</code>と合わせて覚えておきましょう。</p>
</div>
<div id="一部の列の順番だけを変える" class="section level3">
<h3>一部の列の順番だけを変える</h3>
<p>ある列の位置を替えたいとします。たとえば、<code>Score</code>と<code>ScoreN</code>をそれぞれ1列目、2列目にしたい場合、どうすれば良いでしょうか。これまで勉強したことを考えると、以下のようなコードで問題ないでしょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(Score, ScoreN, ID:Budget)</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    Score ScoreN ID    Name  Pref  Zipcode Latitude Longitude Line  Station  Walk
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;
##  1 NA         0 e539… 居酒… 東京… 1040031     35.7      140. 地下… 銀座一…     3
##  2  4.5       2 gfeb… 本格… 東京… 1100005     35.7      140. 地下… 仲御徒…     1
##  3 NA         0 ggt5… 食べ… 東京… 1250041     35.8      140. ＪＲ… 金町駅      2
##  4 NA         0 g181… 博多… 東京… 1920904     35.7      139. ＪＲ  八王子…     1
##  5 NA         0 ggww… まさ… 東京… 1500042     35.7      140. 地下… 渋谷駅      7
##  6 NA         0 gdzk… 完全… 東京… 1000013     35.7      140. 地下… 虎ノ門…     3
##  7 NA         0 ga2g… 鶏そ… 東京… 1760006     35.7      140. 西武… 江古田…     2
##  8  3.33      3 gg9m… 宴会… 東京… 1010021     35.7      140. ＪＲ  秋葉原…     4
##  9  2.5       2 gdvk… 中国… 東京… 1000006     35.7      140. ＪＲ  有楽町…     1
## 10 NA         0 gggb… 中国… 東京… 1140002     35.8      140. 地下… 王子駅      2
## # … with 6,282 more rows, and 3 more variables: Bus &lt;dbl&gt;, Car &lt;dbl&gt;,
## #   Budget &lt;dbl&gt;</code></pre>
<p>しかし、<code>dplyr</code>には<code>relocate()</code>というより便利な専用関数を提供しています。<code>relocate()</code>には変数名を指定するだけですが、ここで指定した変数がデータフレーム (または、tibble)の最初列の方に移動します。</p>
<pre class="r numberLines"><code>df %&gt;%
  relocate(Score, ScoreN)</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    Score ScoreN ID    Name  Pref  Zipcode Latitude Longitude Line  Station  Walk
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;
##  1 NA         0 e539… 居酒… 東京… 1040031     35.7      140. 地下… 銀座一…     3
##  2  4.5       2 gfeb… 本格… 東京… 1100005     35.7      140. 地下… 仲御徒…     1
##  3 NA         0 ggt5… 食べ… 東京… 1250041     35.8      140. ＪＲ… 金町駅      2
##  4 NA         0 g181… 博多… 東京… 1920904     35.7      139. ＪＲ  八王子…     1
##  5 NA         0 ggww… まさ… 東京… 1500042     35.7      140. 地下… 渋谷駅      7
##  6 NA         0 gdzk… 完全… 東京… 1000013     35.7      140. 地下… 虎ノ門…     3
##  7 NA         0 ga2g… 鶏そ… 東京… 1760006     35.7      140. 西武… 江古田…     2
##  8  3.33      3 gg9m… 宴会… 東京… 1010021     35.7      140. ＪＲ  秋葉原…     4
##  9  2.5       2 gdvk… 中国… 東京… 1000006     35.7      140. ＪＲ  有楽町…     1
## 10 NA         0 gggb… 中国… 東京… 1140002     35.8      140. 地下… 王子駅      2
## # … with 6,282 more rows, and 3 more variables: Bus &lt;dbl&gt;, Car &lt;dbl&gt;,
## #   Budget &lt;dbl&gt;</code></pre>
<p><code>relocate()</code>を使うと<code>ID:Budget</code>が省略可能となり、より短いコードになります。もう一つの例は、最初に持ってくるのではなく、「ある変数の前」または「ある変数の後」に移動させるケースです。これも<code>relocate()</code>で可能ですが、もう一つの引数が必要です。<code>Pref</code>と<code>Zipcdoe</code>の順番を変えるなら、まずは以下のような方法が考えられます。</p>
<pre class="r numberLines"><code>df %&gt;%
  select(ID:Name, Zipcode, Pref, Latitude:Score)</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    ID     Name  Zipcode Pref  Latitude Longitude Line  Station  Walk   Bus   Car
##    &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 e5396… 居酒… 1040031 東京…     35.7      140. 地下… 銀座一…     3    NA    NA
##  2 gfeb6… 本格… 1100005 東京…     35.7      140. 地下… 仲御徒…     1    NA    NA
##  3 ggt59… 食べ… 1250041 東京…     35.8      140. ＪＲ… 金町駅      2    NA    NA
##  4 g1813… 博多… 1920904 東京…     35.7      139. ＪＲ  八王子…     1    NA    NA
##  5 ggww1… まさ… 1500042 東京…     35.7      140. 地下… 渋谷駅      7    NA    NA
##  6 gdzk5… 完全… 1000013 東京…     35.7      140. 地下… 虎ノ門…     3    NA    NA
##  7 ga2g2… 鶏そ… 1760006 東京…     35.7      140. 西武… 江古田…     2    NA    NA
##  8 gg9m1… 宴会… 1010021 東京…     35.7      140. ＪＲ  秋葉原…     4    NA    NA
##  9 gdvk2… 中国… 1000006 東京…     35.7      140. ＪＲ  有楽町…     1    NA    NA
## 10 gggb2… 中国… 1140002 東京…     35.8      140. 地下… 王子駅      2    NA    NA
## # … with 6,282 more rows, and 3 more variables: Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;,
## #   Score &lt;dbl&gt;</code></pre>
<p>これを<code>relocate()</code>で書き換えるなら、<code>.after</code>または<code>.before</code>引数が必要になります。<code>relocate(変数名1, .after = 変数名2)</code>は「変数1を変数2の直後に移動させる」
ことを意味します。</p>
<pre class="r numberLines"><code>df %&gt;%
  relocate(Pref, .after = Zipcode)</code></pre>
<pre><code>## # A tibble: 6,292 x 14
##    ID     Name  Zipcode Pref  Latitude Longitude Line  Station  Walk   Bus   Car
##    &lt;chr&gt;  &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 e5396… 居酒… 1040031 東京…     35.7      140. 地下… 銀座一…     3    NA    NA
##  2 gfeb6… 本格… 1100005 東京…     35.7      140. 地下… 仲御徒…     1    NA    NA
##  3 ggt59… 食べ… 1250041 東京…     35.8      140. ＪＲ… 金町駅      2    NA    NA
##  4 g1813… 博多… 1920904 東京…     35.7      139. ＪＲ  八王子…     1    NA    NA
##  5 ggww1… まさ… 1500042 東京…     35.7      140. 地下… 渋谷駅      7    NA    NA
##  6 gdzk5… 完全… 1000013 東京…     35.7      140. 地下… 虎ノ門…     3    NA    NA
##  7 ga2g2… 鶏そ… 1760006 東京…     35.7      140. 西武… 江古田…     2    NA    NA
##  8 gg9m1… 宴会… 1010021 東京…     35.7      140. ＪＲ  秋葉原…     4    NA    NA
##  9 gdvk2… 中国… 1000006 東京…     35.7      140. ＪＲ  有楽町…     1    NA    NA
## 10 gggb2… 中国… 1140002 東京…     35.8      140. 地下… 王子駅      2    NA    NA
## # … with 6,282 more rows, and 3 more variables: Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;,
## #   Score &lt;dbl&gt;</code></pre>
<p><code>.before</code>を使うことできます。この場合は「<code>Zipcode</code>を<code>Pref</code>の直前に移動させる」
ことを指定する必要があります。結果は省略しますが、自分でコードを走らせ、上と同じ結果が得られるかを確認してみてください。</p>
<pre class="r numberLines"><code>df %&gt;%
  relocate(Zipcode, .before = Pref)</code></pre>
</div>
<div id="selectの便利な機能" class="section level3">
<h3><code>select()</code>の便利な機能</h3>
<p><code>select()</code>関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は<code>?dplyr::select</code>を参照してください。</p>
<p><strong><code>starts_with()</code>と<code>ends_with()</code>、<code>contains()</code>、<code>num_range()</code>: 特定の文字を含む変数を選択する</strong></p>
<p>まずは、特定の文字を含む変数名を指定する方法です。<code>starts_with("X")</code>、<code>ends_with("X")</code>、<code>contains("X")</code>は変数名が<code>"X"</code>で始まるか、<code>"X"</code>で終わるか、<code>"X"</code>を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。</p>
<pre class="r numberLines"><code># ID、Nameに続いて、Scoreで始まる変数名を抽出
df %&gt;%
  select(ID, Name, starts_with(&quot;Score&quot;))</code></pre>
<pre><code>## # A tibble: 6,292 x 4
##    ID      Name                                                     ScoreN Score
##    &lt;chr&gt;   &lt;chr&gt;                                                     &lt;dbl&gt; &lt;dbl&gt;
##  1 e539604 居酒屋 龍記 京橋店                                            0 NA   
##  2 gfeb600 本格上海料理 新錦江 上野御徒町本店                            2  4.5 
##  3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ）                    0 NA   
##  4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設      0 NA   
##  5 ggww100 まさ屋 渋谷店                                                 0 NA   
##  6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店                   0 NA   
##  7 ga2g202 鶏そば きらり                                                 0 NA   
##  8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店                         3  3.33
##  9 gdvk200 中国料理 宝龍                                                 2  2.5 
## 10 gggb200 中国料理 天安門                                               0 NA   
## # … with 6,282 more rows</code></pre>
<pre class="r numberLines"><code># eで終わる変数名を除去
df %&gt;%
  select(-ends_with(&quot;e&quot;)) # !ends_with(&quot;e&quot;)も可能</code></pre>
<pre><code>## # A tibble: 6,292 x 8
##    ID      Pref   Station       Walk   Bus   Car Budget ScoreN
##    &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 e539604 東京都 銀座一丁目駅     3    NA    NA   3000      0
##  2 gfeb600 東京都 仲御徒町駅       1    NA    NA   2000      2
##  3 ggt5900 東京都 金町駅           2    NA    NA   2980      0
##  4 g181340 東京都 八王子駅         1    NA    NA   2000      0
##  5 ggww100 東京都 渋谷駅           7    NA    NA    380      0
##  6 gdzk500 東京都 虎ノ門駅         3    NA    NA   2980      0
##  7 ga2g202 東京都 江古田駅         2    NA    NA    850      0
##  8 gg9m100 東京都 秋葉原駅         4    NA    NA   2000      3
##  9 gdvk200 東京都 有楽町駅         1    NA    NA   1000      2
## 10 gggb200 東京都 王子駅           2    NA    NA   2000      0
## # … with 6,282 more rows</code></pre>
<pre class="r numberLines"><code># reを含む変数名を抽出するが、ScoreNは除去する
df %&gt;%
  select(contains(&quot;re&quot;), -ScoreN)</code></pre>
<pre><code>## # A tibble: 6,292 x 2
##    Pref   Score
##    &lt;chr&gt;  &lt;dbl&gt;
##  1 東京都 NA   
##  2 東京都  4.5 
##  3 東京都 NA   
##  4 東京都 NA   
##  5 東京都 NA   
##  6 東京都 NA   
##  7 東京都 NA   
##  8 東京都  3.33
##  9 東京都  2.5 
## 10 東京都 NA   
## # … with 6,282 more rows</code></pre>
<p>他の使い方としては<code>X1</code>、<code>X2</code>のような「文字+数字」の変数を選択する際、<code>starts_with()</code>が活躍します。たとえば、以下のような<code>myDF1</code>があるとします。</p>
<pre class="r numberLines"><code># tibble()の代わりにdata.frame()も使用可能
myDF1 &lt;- tibble(
  ID  = 1:5,
  X1  = c(2, 4, 6, 2, 7),
  Y1  = c(3, 5, 1, 1, 0),
  X1D = c(4, 2, 1, 6, 9),
  X2  = c(5, 5, 6, 0, 2),
  Y2  = c(3, 3, 2, 3, 1),
  X2D = c(8, 9, 5, 0, 1),
  X3  = c(3, 0, 3, 0, 2),
  Y3  = c(1, 5, 9, 1, 3),
  X3D = c(9, 1, 3, 3, 8)
)

myDF1</code></pre>
<pre><code>## # A tibble: 5 x 10
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9
## 2     2     4     5     2     5     3     9     0     5     1
## 3     3     6     1     1     6     2     5     3     9     3
## 4     4     2     1     6     0     3     0     0     1     3
## 5     5     7     0     9     2     1     1     2     3     8</code></pre>
<p>この<code>myDF1</code>から<code>ID</code>、<code>Y1</code>、<code>Y2</code>、<code>Y3</code>を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、<code>:</code>も使えませんが、<code>starts_with()</code>を使えば簡単です。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  select(ID, starts_with(&quot;Y&quot;))</code></pre>
<pre><code>## # A tibble: 5 x 4
##      ID    Y1    Y2    Y3
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     3     3     1
## 2     2     5     3     5
## 3     3     1     2     9
## 4     4     1     3     1
## 5     5     0     1     3</code></pre>
<p>それでは、<code>ID</code>、<code>X1</code>、<code>X2</code>、<code>X3</code>はどうでしょうか。<code>starts_with("X")</code>だと、<code>X1c</code>なども選択されてしまいますね。ここで<code>-ends_with()</code>の出番です。つまり、「まずは<code>starts_with("X")</code>で<code>X</code>で始まる変数を選択し、続いて、<code>D</code>で終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  select(ID, starts_with(&quot;X&quot;), -ends_with(&quot;D&quot;))</code></pre>
<pre><code>## # A tibble: 5 x 3
##      X1    X2    X3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     2     5     3
## 2     4     5     0
## 3     6     6     3
## 4     2     0     0
## 5     7     2     2</code></pre>
<p>あらら、<code>ID</code>も同時になくなりましたね<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。実はこのような時のために用意された関数があり、それが<code>num_range()</code>です。<code>num_range()</code>の第一引数は<code>starts_with()</code>関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。<code>1:3</code>でも、<code>c(1, 2, 3)</code>でも構いません。たとえば、<code>ID</code>、<code>X1</code>、<code>X2</code>、<code>X3</code>するには以下のように書きます。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  select(ID, num_range(&quot;X&quot;, 1:3))</code></pre>
<pre><code>## # A tibble: 5 x 4
##      ID    X1    X2    X3
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     5     3
## 2     2     4     5     0
## 3     3     6     6     3
## 4     4     2     0     0
## 5     5     7     2     2</code></pre>
<p>ぱっぱらぱー！</p>
<p><strong><code>all_of()</code>と<code>any_of()</code>: 文字型ベクトルを用いた変数の選択</strong></p>
<p><code>all_of()</code>と<code>any_of()</code>は<code>select()</code>内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下の<code>Name_Vec</code>を考えてみましょう。</p>
<pre class="r numberLines"><code>Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;)</code></pre>
<p>この<code>Name_Vec</code>の要素と同じ列名を持つ列と<code>ID</code>列を<code>myDF1</code>から抽出する方法は以下の2通りです。</p>
<pre class="r numberLines"><code>myDF1[, c(&quot;ID&quot;, Name_Vec)]</code></pre>
<pre><code>## # A tibble: 5 x 4
##      ID    X1    X2    X3
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     5     3
## 2     2     4     5     0
## 3     3     6     6     3
## 4     4     2     0     0
## 5     5     7     2     2</code></pre>
<pre class="r numberLines"><code>myDF1 %&gt;%
  select(ID, all_of(Name_Vec))</code></pre>
<pre><code>## # A tibble: 5 x 4
##      ID    X1    X2    X3
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     5     3
## 2     2     4     5     0
## 3     3     6     6     3
## 4     4     2     0     0
## 5     5     7     2     2</code></pre>
<p>今の例だと、<code>select()</code>を使わない前者の方が便利かも知れませんが、<code>select()</code>内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。</p>
<p>それでは以下のような<code>Name_Vec</code>はどうでしょう。今回は、<code>myDF1</code>に含まれていない<code>X4</code>と<code>X5</code>もあります。</p>
<pre class="r numberLines"><code>Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;, &quot;X4&quot;, &quot;X5&quot;)

myDF1 %&gt;%
  select(all_of(Name_Vec))</code></pre>
<pre><code>## Error: Can&#39;t subset columns that don&#39;t exist.
## x Columns `X4` and `X5` don&#39;t exist.</code></pre>
<p>このようにエラーが出てしまします。つまり、<code>all_of()</code>の場合、引数の要素全てがデータフレーム (または、tibble)に存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのが<code>any_of()</code>です。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  select(any_of(Name_Vec))</code></pre>
<pre><code>## # A tibble: 5 x 3
##      X1    X2    X3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     2     5     3
## 2     4     5     0
## 3     6     6     3
## 4     2     0     0
## 5     7     2     2</code></pre>
<p><code>any_of()</code>の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、<code>Name_Vec</code>に誤字などが含まれる場合、<code>any_of()</code>だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。</p>
<p><strong><code>last_col()</code>: 最後の列を選択する</strong></p>
<p>普段あまり使わない機能ですが、最後の列を選択する<code>last_col()</code>という関数もあります。たとえば、<code>last_col(0)</code>にすると最後の列を選択し、<code>last_col(1)</code>なら最後から2番目の列を選択します。たとえば、<code>df</code>から<code>ID</code>と最後の列を取り出してみましょう。</p>
<pre class="r numberLines"><code># IDと最後の列のみを抽出
df %&gt;%
  select(ID, last_col(0))</code></pre>
<pre><code>## # A tibble: 6,292 x 2
##    ID      Score
##    &lt;chr&gt;   &lt;dbl&gt;
##  1 e539604 NA   
##  2 gfeb600  4.5 
##  3 ggt5900 NA   
##  4 g181340 NA   
##  5 ggww100 NA   
##  6 gdzk500 NA   
##  7 ga2g202 NA   
##  8 gg9m100  3.33
##  9 gdvk200  2.5 
## 10 gggb200 NA   
## # … with 6,282 more rows</code></pre>
<p>最後の2行分を取り出すことも可能です。この場合は<code>last_col()</code>の引数を長さ1ベクトルでなく、長さ2以上のベクトルにします。最後の行が<code>0</code>、その手前の行が<code>1</code>ですから、中の引数は<code>1:0</code>となります。<code>0:1</code>でも可能ですが、結果が若干異なります。</p>
<pre class="r numberLines"><code># IDと最後の2列分を抽出 (引数を1:0と設定)
df %&gt;%
  select(ID, last_col(1:0))</code></pre>
<pre><code>## # A tibble: 6,292 x 3
##    ID      ScoreN Score
##    &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;
##  1 e539604      0 NA   
##  2 gfeb600      2  4.5 
##  3 ggt5900      0 NA   
##  4 g181340      0 NA   
##  5 ggww100      0 NA   
##  6 gdzk500      0 NA   
##  7 ga2g202      0 NA   
##  8 gg9m100      3  3.33
##  9 gdvk200      2  2.5 
## 10 gggb200      0 NA   
## # … with 6,282 more rows</code></pre>
<pre class="r numberLines"><code># IDと最後の2列分を抽出 (引数を0:1と設定)
df %&gt;%
  select(ID, last_col(0:1))</code></pre>
<pre><code>## # A tibble: 6,292 x 3
##    ID      Score ScoreN
##    &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;
##  1 e539604 NA         0
##  2 gfeb600  4.5       2
##  3 ggt5900 NA         0
##  4 g181340 NA         0
##  5 ggww100 NA         0
##  6 gdzk500 NA         0
##  7 ga2g202 NA         0
##  8 gg9m100  3.33      3
##  9 gdvk200  2.5       2
## 10 gggb200 NA         0
## # … with 6,282 more rows</code></pre>
<p><code>last_col()</code>の引数を<code>1:0</code>にするか<code>0:1</code>にするかによって抽出される順番が異なります。<code>1:0</code>は<code>c(1, 0)</code>、<code>0:1</code>は<code>c(0, 1)</code>と同じであることを考えると理由は簡単です。<code>c(1, 0)</code>の場合、<code>last_col(1), last_col(0)</code>の順番で処理をし、<code>c(0, 1)</code>は<code>last_col(0)</code>、<code>last_col(1)</code>の順番で処理を行うからです。</p>
<p>この<code>last_col()</code>の引数を空っぽにするとそれは最後の列を意味します。これを利用すれば、「ある変数の最後の列へ移動させる」こともできます。たとえば、<code>ID</code>を最後の列に移動させたい場合、<code>relocate(ID, .after = last_col())</code>のように書きます。</p>
<p><strong><code>where()</code>: データ型から変数を選択する</strong></p>
<p>最後に、「numeric型の列のみ抽出したい」、「character型の列だけほしい」場合に便利な<code>where()</code>関数を紹介します。<code>where()</code>の中に入る引数は一つだけであり、データ型を判定する関数名が入ります。たとえば、numeric型か否かを判断する関数は<code>is.numeric</code>です。<code>df</code>からnumeric型の変数のみを抽出したい場合は以下のように書きます。</p>
<pre class="r numberLines"><code># numeric型の列を抽出する
df %&gt;%
  select(where(is.numeric))</code></pre>
<pre><code>## # A tibble: 6,292 x 9
##    Zipcode Latitude Longitude  Walk   Bus   Car Budget ScoreN Score
##      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 1040031     35.7      140.     3    NA    NA   3000      0 NA   
##  2 1100005     35.7      140.     1    NA    NA   2000      2  4.5 
##  3 1250041     35.8      140.     2    NA    NA   2980      0 NA   
##  4 1920904     35.7      139.     1    NA    NA   2000      0 NA   
##  5 1500042     35.7      140.     7    NA    NA    380      0 NA   
##  6 1000013     35.7      140.     3    NA    NA   2980      0 NA   
##  7 1760006     35.7      140.     2    NA    NA    850      0 NA   
##  8 1010021     35.7      140.     4    NA    NA   2000      3  3.33
##  9 1000006     35.7      140.     1    NA    NA   1000      2  2.5 
## 10 1140002     35.8      140.     2    NA    NA   2000      0 NA   
## # … with 6,282 more rows</code></pre>
<p><code>!</code>を使って条件に合致する列を除外することも可能です。もし、character型の列を除外する場合は以下のように<code>!where(is.character)</code>を指定します。</p>
<pre class="r numberLines"><code># character型でない列を抽出する
df %&gt;%
  select(!where(is.character))</code></pre>
<pre><code>## # A tibble: 6,292 x 9
##    Zipcode Latitude Longitude  Walk   Bus   Car Budget ScoreN Score
##      &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 1040031     35.7      140.     3    NA    NA   3000      0 NA   
##  2 1100005     35.7      140.     1    NA    NA   2000      2  4.5 
##  3 1250041     35.8      140.     2    NA    NA   2980      0 NA   
##  4 1920904     35.7      139.     1    NA    NA   2000      0 NA   
##  5 1500042     35.7      140.     7    NA    NA    380      0 NA   
##  6 1000013     35.7      140.     3    NA    NA   2980      0 NA   
##  7 1760006     35.7      140.     2    NA    NA    850      0 NA   
##  8 1010021     35.7      140.     4    NA    NA   2000      3  3.33
##  9 1000006     35.7      140.     1    NA    NA   1000      2  2.5 
## 10 1140002     35.8      140.     2    NA    NA   2000      0 NA   
## # … with 6,282 more rows</code></pre>
<p><code>&amp;</code>を使って複数の条件を使うことも可能です。たとえば、<code>ID</code>変数に加えて「<code>"L"</code>で始まる変数の中でnumeric型の列を抽出」するコードは以下のようになります。</p>
<pre class="r numberLines"><code># IDと、Lで始まるnumeric型の列を抽出する
df %&gt;%
  select(ID, starts_with(&quot;L&quot;) &amp; where(is.numeric))</code></pre>
<pre><code>## # A tibble: 6,292 x 3
##    ID      Latitude Longitude
##    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;
##  1 e539604     35.7      140.
##  2 gfeb600     35.7      140.
##  3 ggt5900     35.8      140.
##  4 g181340     35.7      139.
##  5 ggww100     35.7      140.
##  6 gdzk500     35.7      140.
##  7 ga2g202     35.7      140.
##  8 gg9m100     35.7      140.
##  9 gdvk200     35.7      140.
## 10 gggb200     35.8      140.
## # … with 6,282 more rows</code></pre>
<hr />
</div>
</div>
<div id="行の抽出" class="section level2">
<h2>行の抽出</h2>
<div id="指定した行を抽出する" class="section level3">
<h3>指定した行を抽出する</h3>
<p>他にも特定の行を抽出する場合があります。たとえば、「<code>df</code>の最初の5行」や「<code>df</code>の8行目のケース」といった場合です。この操作には<code>dplyr</code>の<code>slice_*()</code>関数群が便利です。それではそれぞれの関数の使い方について紹介していきます。その前に、実習用データとして<code>df</code>から一部の列のみを抽出した<code>selelct.df</code>を作成します。</p>
<pre class="r"><code>select.df &lt;- df %&gt;% 
  select(ID, Name, Pref, Budget, Score)</code></pre>
<p><strong><code>slice()</code>: 指定した番号の行のみ抽出する</strong></p>
<p><code>select.df</code>から2, 8, 9行目の行を抽出したいとします。このような簡単な操作はパッケージを使わず、以下のように抽出することができます。</p>
<pre class="r"><code># select.dfから2, 8, 9行目の行を抽出し、出力する
select.df[c(2, 8, 9),]</code></pre>
<pre><code>## # A tibble: 3 x 5
##   ID      Name                                  Pref   Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                                 &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 gfeb600 本格上海料理 新錦江 上野御徒町本店    東京都   2000  4.5 
## 2 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都   2000  3.33
## 3 gdvk200 中国料理 宝龍                         東京都   1000  2.5</code></pre>
<p>しかし、以下の<code>slice()</code>関数を使うとパイプ演算子を前後に付けることが可能であり<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>、コードの可読性も高いです。<code>slice()</code>関数には以下のように抽出したい行の番号を入れるだけです。</p>
<pre class="r"><code># select.dfから2, 8, 9行目の行を抽出し、出力する
select.df %&gt;% 
  slice(2, 8, 9) # slice(c(2, 8, 9))もOK</code></pre>
<pre><code>## # A tibble: 3 x 5
##   ID      Name                                  Pref   Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                                 &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 gfeb600 本格上海料理 新錦江 上野御徒町本店    東京都   2000  4.5 
## 2 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都   2000  3.33
## 3 gdvk200 中国料理 宝龍                         東京都   1000  2.5</code></pre>
<p><code>slice(2, 8, 9)</code>でも<code>slice(c(2, 8, 9))</code>でも構いません。また、隣接した行でしたら<code>:</code>を使うことも可能です。たとえば、10行目から15行目まで抽出する場合は<code>slice(10:15)</code>のような書き方も出来ます。</p>
<p><strong><code>slice_head()</code>: 最初のn行を抽出する</strong></p>
<pre class="r"><code># select.dfから最初の3行抽出し、出力する
select.df %&gt;% 
  slice_head(n = 3)</code></pre>
<pre><code>## # A tibble: 3 x 5
##   ID      Name                                       Pref   Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                                      &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 e539604 居酒屋 龍記 京橋店                         東京都   3000  NA  
## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店         東京都   2000   4.5
## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都   2980  NA</code></pre>
<p>これは<code>head(データ名, n = 出力する個数)</code>と同じ動きをする関数です。注意点としては引数<code>n =</code>を必ず付ける点です。たとえば、<code>slice_head(3)</code>にすると、<code>select.df</code>の3行目のみ抽出されます。</p>
<p><strong><code>slice_tail()</code>: 最後のn行を抽出する</strong></p>
<pre class="r"><code># select.dfから最後の7行を抽出し、出力する
select.df %&gt;% 
  slice_tail(n = 7)</code></pre>
<pre><code>## # A tibble: 7 x 5
##   ID      Name                    Pref     Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;
## 1 5508852 場鶴                    和歌山県     NA    NA
## 2 7113351 来来亭 橋本店           和歌山県     NA    NA
## 3 6364939 ばり馬 和歌山紀三井寺店 和歌山県     NA    NA
## 4 7103349 ramen BIRDMAN           和歌山県     NA    NA
## 5 7315303 薩摩ラーメン 斗天王     和歌山県     NA    NA
## 6 7703472 まるしげ                和歌山県     NA    NA
## 7 6395035 暴豚製麺所              和歌山県     NA    NA</code></pre>
<p>これは<code>tail(データ名, n = 出力する個数)</code>と同じ動きをする関数です。ちなみに、この<code>n</code>引数も<code>n =</code>を明記する必要があります。</p>
<p><strong><code>slice_max()</code>: 指定した変数が大きい順でn行抽出する</strong></p>
<p><code>slice_max()</code>は指定した変数が大きい順で<code>n</code>行抽出する関数です。たとえば、<code>Budget</code>が高い順で4店舗を抽出する場合は以下のように書きます。</p>
<pre class="r"><code># select.dfからScoreの値が高い順で5行を抽出し、出力する
select.df %&gt;% 
  slice_max(Budget, n = 4)</code></pre>
<pre><code>## # A tibble: 4 x 5
##   ID      Name                                              Pref    Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                                             &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1 g670609 横浜ベイシェラトン ホテル＆タワーズ 中国料理 彩龍 神奈川…   8000    NA
## 2 g910420 JASMINE 憶江南                                    東京都    7000    NA
## 3 7176666 赤坂焼鳥 鳳                                       東京都    7000    NA
## 4 b612800 羽衣 銀座本店                                     東京都    6000    NA</code></pre>
<p><strong><code>slice_min()</code>: 指定した変数が小さい順でn行抽出する</strong></p>
<p>一方、<code>slice_min()</code>関数が小さい順で抽出します。</p>
<pre class="r"><code># select.dfからScoreの値が低い順で3行を抽出し、出力する
select.df %&gt;% 
  slice_min(Score, n = 3)</code></pre>
<pre><code>## # A tibble: 4 x 5
##   ID      Name                        Pref   Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                       &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 6384909 葛西大勝軒                  東京都     NA     1
## 2 6929243 由丸 アトレヴィ大塚店       東京都     NA     1
## 3 5816075 ラーメン戯拉戯拉            千葉県     NA     1
## 4 5495086 らあめん花月嵐 坂戸わかば店 埼玉県     NA     1</code></pre>
<p>ただし、<code>n = 3</code>と指定したはずなのに、4行が抽出されました。これは同点のケースがあるからです。実際、<code>select.df</code>には<code>Score</code>が1のケースが4つあります。もし、同点の存在により<code>n</code>に収まらない場合、<code>slice_max()</code>、<code>slice_min()</code>関数は<code>n</code>を超える行を出力します。これを強制的に<code>n</code>行に合わせるためには<code>with_ties = FALSE</code>引数を付けます。この場合、データで格納されている順で<code>n</code>個のみ出力されます。</p>
<pre class="r"><code>select.df %&gt;% 
  slice_min(Score, n = 3, with_ties = FALSE)</code></pre>
<pre><code>## # A tibble: 3 x 5
##   ID      Name                  Pref   Budget Score
##   &lt;chr&gt;   &lt;chr&gt;                 &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 6384909 葛西大勝軒            東京都     NA     1
## 2 6929243 由丸 アトレヴィ大塚店 東京都     NA     1
## 3 5816075 ラーメン戯拉戯拉      千葉県     NA     1</code></pre>
<p><strong><code>slice_sample()</code>: 無作為にn行を抽出する</strong></p>
<p>最後に無作為に<code>n</code>行を抽出する<code>slice_sample()</code>関数です。引数は<code>n</code>であり、抽出したい行数を指定します。たとえば、<code>select.df</code>から無作為に10行抽出したい場合は、</p>
<pre class="r"><code># select.dfから無作為に5行を抽出し、出力する
select.df %&gt;% 
  slice_sample(n = 10)</code></pre>
<pre><code>## # A tibble: 10 x 5
##    ID      Name                         Pref     Budget Score
##    &lt;chr&gt;   &lt;chr&gt;                        &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;
##  1 7113892 横浜家系らーめん春樹 笹塚店  東京都       NA    NA
##  2 6899665 麺屋 樹真                    埼玉県       NA    NA
##  3 5496381 皐月                         千葉県       NA    NA
##  4 7462023 麺屋 天孫降臨 元町店         兵庫県       NA    NA
##  5 5500737 くるまやラーメン相模原下溝店 神奈川県     NA    NA
##  6 kbby402 祇園 晩餐のあと              京都府     3500    NA
##  7 5808950 希望軒 丹波篠山店            兵庫県       NA    NA
##  8 7299157 らー麺 つけ麺 おぐり         千葉県       NA    NA
##  9 7623305 油そば専門店 歌志軒 住吉店   兵庫県       NA    NA
## 10 6408158 大勝軒 京都拉麺小路店        京都府       NA    NA</code></pre>
<p>のように書きます。ブートストラップ法や機械学習における交差検証 (cross-validation)の際に有用な関数ですが、ブートストラップや機械学習のパッケージの多くはサンプル分割の関数を提供しているため、あまり使う機会はないでしょう。また、<code>slice_sample()</code>関数をブートストラップ法のために用いる場合は、ケースを反復抽出する必要があり、<code>replace = TRUE</code>を付けると反復抽出を行います。デフォルト値は<code>FALSE</code>です。</p>
</div>
<div id="条件に合致する行を抽出する" class="section level3">
<h3>条件に合致する行を抽出する</h3>
<p>これまで見てきた<code>slice()</code>を用いる行の抽出は、実際あまり使う機会がありません。多くの場合、「何かの条件と合致するケースのみ抽出する」または、「何かの条件と合致しないケースのみを抽出する」やこれらの組み合わせで行の抽出を行います。そこで登場するのが<code>dplyr()</code>パッケージの<code>filter()</code>関数です。<code>filter()</code>関数の使い方は以下の通りです。</p>
<pre class="r numberLines"><code># dplyr::filter()の使い方
filter(データフレーム/tibble名, 条件1, 条件2, ...)</code></pre>
<p>むろん、第一引数がデータですから、<code>%&gt;%</code>を使うことも可能です。</p>
<pre class="r numberLines"><code># dplyr::filter()の使い方 (パイプを使う方法)
データフレーム/tibble名 %&gt;%
  filter(条件1, 条件2, ...)</code></pre>
<p>まずは、条件が一つの場合を考えてみましょう。ここでは「<code>Pref</code>が<code>"京都府"</code>であるケースのみに絞り、<code>Name</code>と<code>Station</code>、<code>Score</code>列のみを出力する」ケースを考えてみましょう。まず、<code>filter()</code>関数で行を抽出し、続いて<code>select()</code>関数で抽出する列を指定します。むろん、今回の場合、<code>filter()</code>と<code>select()</code>の順番は替えても構いません。</p>
<pre class="r numberLines"><code># dfからPrefが&quot;京都府&quot;であるケースのみ残し、df2という名で保存
df2 &lt;- df %&gt;%
  filter(Pref == &quot;京都府&quot;)

# df2からName, Station, Score列を抽出
df2 %&gt;%
  select(Name, Station, Score)</code></pre>
<pre><code>## # A tibble: 414 x 3
##    Name                                                    Station    Score
##    &lt;chr&gt;                                                   &lt;chr&gt;      &lt;dbl&gt;
##  1 中国料理 鳳麟                                           くいな橋駅 NA   
##  2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅      3.19
##  3 京の中華 ハマムラ みやこみち店                          京都駅     NA   
##  4 焼肉処 真 桂店                                          桂駅       NA   
##  5 祇園京都ラーメン                                        祇園四条駅 NA   
##  6 創作料理 串カツ トンカツ jiro                           新田辺駅   NA   
##  7 祇園 晩餐のあと                                         祇園四条駅 NA   
##  8 DETAIL                                                  東山駅     NA   
##  9 めんや龍神                                              北大路駅   NA   
## 10 無尽蔵 京都八条家                                       京都駅      3.5 
## # … with 404 more rows</code></pre>
<p>これは<code>df</code>から<code>Pref == "京都府"</code>のケースのみ残したものを<code>df2</code>として格納し、それをまた<code>select()</code>関数を使って列を抽出するコードです。これでも問題ありませんが、これだとパイプ演算子の便利さが分かりません。パイプ演算子は複数使うことが可能です。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;京都府&quot;) %&gt;%
  select(Name, Station, Score)</code></pre>
<pre><code>## # A tibble: 414 x 3
##    Name                                                    Station    Score
##    &lt;chr&gt;                                                   &lt;chr&gt;      &lt;dbl&gt;
##  1 中国料理 鳳麟                                           くいな橋駅 NA   
##  2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅      3.19
##  3 京の中華 ハマムラ みやこみち店                          京都駅     NA   
##  4 焼肉処 真 桂店                                          桂駅       NA   
##  5 祇園京都ラーメン                                        祇園四条駅 NA   
##  6 創作料理 串カツ トンカツ jiro                           新田辺駅   NA   
##  7 祇園 晩餐のあと                                         祇園四条駅 NA   
##  8 DETAIL                                                  東山駅     NA   
##  9 めんや龍神                                              北大路駅   NA   
## 10 無尽蔵 京都八条家                                       京都駅      3.5 
## # … with 404 more rows</code></pre>
<p>全く同じ結果ですが、無駄に<code>df2</code>というデータフレーム (または、tibble)を作らず済むので、メモリの観点からも嬉しいですし、何よりコードが短く、しかも可読性も上がりました。</p>
<p>今回は<code>==</code>を使って<strong>合致する</strong>ものに絞りましたが、<code>!=</code>を使って<strong>合致しない</strong>ものに絞ることも可能です。または、比較演算子 (<code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code>など)を使うことも可能です。それでは、組み込み数 (<code>ScoreN</code>)が<em>0ではない</em>ケースを取り出し、<code>Name</code>、<code>Station</code>、<code>ScoreN</code>、<code>Score</code>列を出力させてみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(ScoreN != 0) %&gt;%
  select(Name, Station, starts_with(&quot;Score&quot;))</code></pre>
<pre><code>## # A tibble: 1,344 x 4
##    Name                                             Station         ScoreN Score
##    &lt;chr&gt;                                            &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;
##  1 本格上海料理 新錦江 上野御徒町本店               仲御徒町駅           2  4.5 
##  2 宴会個室×餃子酒場 北京飯店 秋葉原本店            秋葉原駅             3  3.33
##  3 中国料理 宝龍                                    有楽町駅             2  2.5 
##  4 麺達 うま家                                      高田馬場駅           2  3   
##  5 刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園… 後楽園駅             1 NA   
##  6 七志らーめん 渋谷道玄坂店                        渋谷駅               7  4.5 
##  7 永楽                                             京成小岩駅           6  4.42
##  8 よってこや お台場店                              お台場海浜公園…      1  4   
##  9 ラーメン武藤製麺所                               竹ノ塚駅             4  3.5 
## 10 桂花ラーメン 新宿末広店                          新宿三丁目駅         8  3   
## # … with 1,334 more rows</code></pre>
<p>これで口コミ数が1以上の店舗のみに絞ることができました。ただし、店によっては口コミはあっても、評価 (<code>Score</code>)が付いていないところもあります。たとえば、「刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店」の場合、口コミはありますが、評価はありません。したがって、今回は評価が付いている店舗に絞ってみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Score != NA) %&gt;%
  select(Name, Station, starts_with(&quot;Score&quot;))</code></pre>
<pre><code>## # A tibble: 0 x 4
## # … with 4 variables: Name &lt;chr&gt;, Station &lt;chr&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt;</code></pre>
<p>あらら、何の結果も表示されませんでした。これは<code>filter()</code>内の条件に合致するケースが存在しないことを意味します。しかし、先ほどの結果を見ても、評価が付いている店はいっぱいありましたね。これはなぜでしょう。</p>
<p>察しの良い読者さんは気づいているかと思いますが、<code>NA</code>か否かを判定する際は<code>==</code>や<code>!=</code>は使えません。<code>is.na()</code>を使います。<code>filter(is.na(Score))</code>なら「<code>Score</code>が<code>NA</code><strong>である</strong>ケースに絞る」ことを意味しますが、今回は「<code>Score</code>が<code>NA</code><strong>でない</strong>ケースに絞る」ことが目的ですので、<code>is.na()</code>の前に<code>!</code>を付けます。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Score)) %&gt;%
  select(Name, Station, starts_with(&quot;Score&quot;))</code></pre>
<pre><code>## # A tibble: 1,134 x 4
##    Name                                  Station          ScoreN Score
##    &lt;chr&gt;                                 &lt;chr&gt;             &lt;dbl&gt; &lt;dbl&gt;
##  1 本格上海料理 新錦江 上野御徒町本店    仲御徒町駅            2  4.5 
##  2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅              3  3.33
##  3 中国料理 宝龍                         有楽町駅              2  2.5 
##  4 麺達 うま家                           高田馬場駅            2  3   
##  5 七志らーめん 渋谷道玄坂店             渋谷駅                7  4.5 
##  6 永楽                                  京成小岩駅            6  4.42
##  7 よってこや お台場店                   お台場海浜公園駅      1  4   
##  8 ラーメン武藤製麺所                    竹ノ塚駅              4  3.5 
##  9 桂花ラーメン 新宿末広店               新宿三丁目駅          8  3   
## 10 北斗 新橋店                           新橋駅                4  2.5 
## # … with 1,124 more rows</code></pre>
<p>これで口コミ評価が登録された店舗に絞ることができました。</p>
<p>続いて、複数の条件を持つケースを考えてみましょう。例えば、「京都府内の店舗で、口コミ評価が3.5以上の店舗」を出力したい場合、以下のようなコードとなります。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;京都府&quot;, Score &gt;= 3.5) %&gt;%
  select(Name, Station, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 53 x 4
##    Name               Station    ScoreN Score
##    &lt;chr&gt;              &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 無尽蔵 京都八条家  京都駅          2  3.5 
##  2 一蘭 京都河原町店  河原町駅        2  3.75
##  3 ミスター・ギョーザ 西大路駅        8  4.06
##  4 一蘭 京都八幡店    樟葉駅          3  4   
##  5 中華料理 清華園    京都駅          3  5   
##  6 まがり             &lt;NA&gt;            2  4   
##  7 魁力屋 北山店      北大路駅        2  4.25
##  8 大中BAL横店        &lt;NA&gt;            7  4.1 
##  9 こうちゃん         西舞鶴駅        1  5   
## 10 大黒ラーメン       伏見桃山駅      4  4.25
## # … with 43 more rows</code></pre>
<p>条件を<code>filter()</code>内に追加するだけです。今回は<code>!is.na(Score)</code>は不要です。なぜなら、<code>Score &gt;= 3.5</code>という条件で既に欠損値は対象外になるからです。条件文が複数ある場合、ANDかORかを指定する必要があります。つまり、条件文AとBがある場合、「AとB両方満たすものを出力する」か「AとBどちらかを満たすものを出力するか」を指定する必要があります。今の結果ってANDでしたよね。<code>filter()</code>関数は、別途の指定がない場合、全てAND扱いになります。RのAND演算子は<code>&amp;</code>ですので、以上のコードは以下のコードと同じです。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;京都府&quot; &amp; Score &gt;= 3.5) %&gt;%
  select(Name, Station, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 53 x 4
##    Name               Station    ScoreN Score
##    &lt;chr&gt;              &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 無尽蔵 京都八条家  京都駅          2  3.5 
##  2 一蘭 京都河原町店  河原町駅        2  3.75
##  3 ミスター・ギョーザ 西大路駅        8  4.06
##  4 一蘭 京都八幡店    樟葉駅          3  4   
##  5 中華料理 清華園    京都駅          3  5   
##  6 まがり             &lt;NA&gt;            2  4   
##  7 魁力屋 北山店      北大路駅        2  4.25
##  8 大中BAL横店        &lt;NA&gt;            7  4.1 
##  9 こうちゃん         西舞鶴駅        1  5   
## 10 大黒ラーメン       伏見桃山駅      4  4.25
## # … with 43 more rows</code></pre>
<p>AND演算子 (<code>&amp;</code>)が使えるということはOR演算子 (<code>|</code>)も使えることを意味します。たとえば、<code>Station</code>が<code>"高田馬場駅"</code>か<code>"三田駅"</code>の条件を指定したい場合、</p>
<pre class="r numberLines"><code>df %&gt;% 
  filter(Station == &quot;高田馬場駅&quot; | Station == &quot;三田駅&quot;) %&gt;%
  select(Name, Station, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 14 x 4
##    Name                                 Station    ScoreN Score
##    &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 麺達 うま家                          高田馬場駅      2  3   
##  2 らぁ麺 やまぐち                      高田馬場駅      7  4.08
##  3 博多一瑞亭 三田店                    三田駅          0 NA   
##  4 つけ麺屋 ひまわり                    高田馬場駅      4  2.75
##  5 石器ラーメン 高田馬場                高田馬場駅      0 NA   
##  6 旨辛らーめん 表裏                    高田馬場駅      0 NA   
##  7 三歩一                               高田馬場駅      8  4.56
##  8 えぞ菊 戸塚店                        高田馬場駅      4  3.62
##  9 麺屋　宗                             高田馬場駅      5  4.2 
## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅      2  3   
## 11 横浜家系ラーメン 馬場壱家            高田馬場駅      0 NA   
## 12 らーめん よし丸                      高田馬場駅      1  5   
## 13 札幌ラーメン どさん子 三田店         三田駅          0 NA   
## 14 天下一品 三田店                      三田駅          0 NA</code></pre>
<p>のように書きます（ちなみに高田馬場の「やまぐち」は本当に美味しいです）。むろん、複数の変数を用いたORも可能です。たとえば、「<code>Pref</code>が<code>"京都府"</code>か<code>Score</code>が3以上」のような条件も可能ですが (<code>Pref == "京都府" | Score &gt;= 3</code>)、実際、このような例はあまりありません。よく使うのは「変数<code>X</code>が<code>a</code>か<code>b</code>か<code>c</code>か」のような例です。ただし、この場合は<code>|</code>を使わないもっと簡単な方法があります。それは<code>%in%</code>演算子です。以下のコードは上のコードと同じものです。</p>
<pre class="r numberLines"><code>df %&gt;% 
  filter(Station %in% c(&quot;高田馬場駅&quot;, &quot;三田駅&quot;)) %&gt;%
  select(Name, Station, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 14 x 4
##    Name                                 Station    ScoreN Score
##    &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 麺達 うま家                          高田馬場駅      2  3   
##  2 らぁ麺 やまぐち                      高田馬場駅      7  4.08
##  3 博多一瑞亭 三田店                    三田駅          0 NA   
##  4 つけ麺屋 ひまわり                    高田馬場駅      4  2.75
##  5 石器ラーメン 高田馬場                高田馬場駅      0 NA   
##  6 旨辛らーめん 表裏                    高田馬場駅      0 NA   
##  7 三歩一                               高田馬場駅      8  4.56
##  8 えぞ菊 戸塚店                        高田馬場駅      4  3.62
##  9 麺屋　宗                             高田馬場駅      5  4.2 
## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅      2  3   
## 11 横浜家系ラーメン 馬場壱家            高田馬場駅      0 NA   
## 12 らーめん よし丸                      高田馬場駅      1  5   
## 13 札幌ラーメン どさん子 三田店         三田駅          0 NA   
## 14 天下一品 三田店                      三田駅          0 NA</code></pre>
<p>結局、<code>|</code>が使われるケースがかなり限定されます。あるとすれば、「変数<code>X</code>が<code>a</code>以下か、<code>b</code>以上か」のようなケースですね。ただし、<code>&amp;</code>と<code>|</code>を同時に使うケースは考えられます。たとえば、大阪駅と京都駅周辺のうまいラーメン屋を調べるとします。問題は美味しさの基準ですが、3.5点以上としましょう。ただし、京都府民はラーメンに非常に厳しく、3点以上なら美味しいと仮定します。この場合、「(<code>Station</code>が<code>"大阪駅"</code>かつ<code>Score &gt;= 3.5</code>)、または(<code>Station</code>が<code>"京都駅"</code>かつ<code>Score &gt;= 3</code>)」のような条件が必要になります。<code>()</code>は「<code>()</code>の中から判定せよ」という、普通の算数での使い方と同じです。それでは、実際に検索してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter((Station == &quot;大阪駅&quot; &amp; Score &gt;= 3.5) | (Station == &quot;京都駅&quot; &amp; Score &gt;= 3)) %&gt;%
  select(Name, Station, Walk, ScoreN, Score)</code></pre>
<pre><code>## # A tibble: 6 x 5
##   Name                      Station  Walk ScoreN Score
##   &lt;chr&gt;                     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1 Lei can ting 大阪ルクア店 大阪駅      3      3  4   
## 2 神座 ルクア大阪店         大阪駅      1     10  3.94
## 3 みつか坊主 醸             大阪駅     10      4  5   
## 4 無尽蔵 京都八条家         京都駅      5      2  3.5 
## 5 中華料理 清華園           京都駅     10      3  5   
## 6 ますたに 京都拉麺小路店   京都駅      9      3  3.67</code></pre>
<p>Songが大好きな神座がヒットして嬉しいです。</p>
<hr />
</div>
</div>
<div id="行のソート" class="section level2">
<h2>行のソート</h2>
<p>続いて、行のソートについて解説します。「食べログ」などのレビューサービスを利用する場合、口コミ評価が高い順で見るのが一般的でしょう<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>。また、サッカーのランキングも多くは1位から下の順位で掲載されるのが一般的です。ここではこのようにある変数の値順に行を並び替える方法について説明します。</p>
<p>ソートには<code>dplyr</code>パッケージの<code>arrange()</code>関数を使います。引数は変数名のみです。たとえば、奈良県のラーメン屋を検索してみましょう。並び替える順は駅から近い店舗を上位に、遠い店舗を下位に並べます。このような順は<strong>昇順 (ascending)</strong>と呼ばれ、ランキング表などでよく見ます。駅から近い順にソートするので、まず最寄りの駅情報が欠損でないことが必要です。また、ラーメン屋の評価も気になるので口コミが1つ以上付いている店舗に絞りましょう。表示する列は店舗名、最寄りの駅、徒歩距離、口コミ数、点数です。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;%
  select(Name, Station, Walk, ScoreN, Score) %&gt;%
  arrange(Walk) %&gt;%
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 24 x 5
##    Name                                  Station             Walk ScoreN Score
##    &lt;chr&gt;                                 &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 麺屋 あまのじゃく 本店                富雄駅                 2      2  4.5 
##  2 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅                 4      1  4   
##  3 ラーメン家 みつ葉                     富雄駅                 4      1  3.5 
##  4 天下一品 新大宮店                     新大宮駅               6      1  3   
##  5 麺屋 一徳                             天理駅                 7      1  3   
##  6 丸源ラーメン 橿原店                   金橋駅                 8      1  3.5 
##  7 らーめん食堂 よってこや 平群店        元山上口駅            10      1  4   
##  8 天理スタミナラーメン本店              櫟本駅                11      2  3.25
##  9 博多長浜らーめん夢街道 奈良土橋店     真菅駅                11      1  3.5 
## 10 ぶ～け                                奈良駅                11      1  5   
## 11 つけめん らーめん元喜神 押熊店        学研奈良登美ヶ丘駅    12      4  4.12
## 12 彩華ラーメン 本店                     前栽駅                12      5  3.6 
## 13 力皇                                  天理駅                13      1  3.5 
## 14 らーめん きみちゃん                   京終駅                14      2  4.5 
## 15 無鉄砲がむしゃら                      帯解駅                15      2  4   
## 16 彩華ラーメン 田原本店                 石見駅                15      1  4   
## 17 神座 大和高田店                       大和高田駅            17      2  3.75
## 18 彩華ラーメン 奈良店                   尼ヶ辻駅              17      3  4.33
## 19 彩華ラーメン 桜井店                   大福駅                18      1  3   
## 20 天下一品 東生駒店                     東生駒駅              19      1  3.5 
## 21 まりお流ラーメン                      新大宮駅              20      1  5   
## 22 どうとんぼり神座 奈良柏木店           西ノ京駅              22      1  3   
## 23 河童ラーメン本舗 押熊店               学研奈良登美ヶ丘駅    28      1  4   
## 24 博多長浜らーめん 夢街道 四条大路店    新大宮駅              29      4  2.88</code></pre>
<p>3行まではこれまで習ってきたもので、4行目がソートの関数、<code>arrange()</code>です。引数はソートの基準となる変数で、今回は最寄りの駅からの徒歩距離を表す<code>Walk</code>です。5行目は省略可能ですが、<code>tibble</code>クラスの場合、10行までしか出力されないので、<code>print(n = Inf)</code>で「すべての行を表示」させます。<code>n</code>を指定することで出力される行数が調整可能です。奈良県のラーメン屋の中で最寄りの駅から最も近い店は「<a href="https://www.menya-amanojaku.com">麺屋 あまのじゃく 本店</a>」で徒歩2分でした。京田辺店も駅から約2分ですし、近いですね。ちなみにSongはここの塩とんこつが好きです。世界一こってりなラーメンとも言われる「チョモランマ」で有名な「<a href="http://www.marioramen.com">まりお流ラーメン</a>」は新大宮駅から徒歩20分でかなり遠いことが分かります。</p>
<p>続いて、駅からの距離ではなく、評価が高い順にしてみましょう。評価が高いほど上に来るので、今回は昇順でなく、<strong>降順 (descending)</strong>でソートする必要があります。<code>arrange()</code>関数は基本的に、指定された変数を基準に昇順でソートします。降順にするためには<code>desc()</code>関数を更に用います。たとえば、<code>arrange(desc(変数名))</code>のようにです。それでは実際にやってみましょう。上のコードの4行目を<code>arange(Walk)</code>から<code>arrange(desc(Score))</code>にちょっと修正するだけです。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;%
  select(Name, Station, Walk, ScoreN, Score) %&gt;%
  arrange(desc(Score)) %&gt;%
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 24 x 5
##    Name                                  Station             Walk ScoreN Score
##    &lt;chr&gt;                                 &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 まりお流ラーメン                      新大宮駅              20      1  5   
##  2 ぶ～け                                奈良駅                11      1  5   
##  3 麺屋 あまのじゃく 本店                富雄駅                 2      2  4.5 
##  4 らーめん きみちゃん                   京終駅                14      2  4.5 
##  5 彩華ラーメン 奈良店                   尼ヶ辻駅              17      3  4.33
##  6 つけめん らーめん元喜神 押熊店        学研奈良登美ヶ丘駅    12      4  4.12
##  7 河童ラーメン本舗 押熊店               学研奈良登美ヶ丘駅    28      1  4   
##  8 無鉄砲がむしゃら                      帯解駅                15      2  4   
##  9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅                 4      1  4   
## 10 彩華ラーメン 田原本店                 石見駅                15      1  4   
## 11 らーめん食堂 よってこや 平群店        元山上口駅            10      1  4   
## 12 神座 大和高田店                       大和高田駅            17      2  3.75
## 13 彩華ラーメン 本店                     前栽駅                12      5  3.6 
## 14 天下一品 東生駒店                     東生駒駅              19      1  3.5 
## 15 力皇                                  天理駅                13      1  3.5 
## 16 博多長浜らーめん夢街道 奈良土橋店     真菅駅                11      1  3.5 
## 17 ラーメン家 みつ葉                     富雄駅                 4      1  3.5 
## 18 丸源ラーメン 橿原店                   金橋駅                 8      1  3.5 
## 19 天理スタミナラーメン本店              櫟本駅                11      2  3.25
## 20 麺屋 一徳                             天理駅                 7      1  3   
## 21 どうとんぼり神座 奈良柏木店           西ノ京駅              22      1  3   
## 22 彩華ラーメン 桜井店                   大福駅                18      1  3   
## 23 天下一品 新大宮店                     新大宮駅               6      1  3   
## 24 博多長浜らーめん 夢街道 四条大路店    新大宮駅              29      4  2.88</code></pre>
<p>よく考えてみれば、「評価が同点の場合、どうなるの?」と疑問を抱く方がいるかも知れません。たとえば、7行目の「河童ラーメン本舗 押熊店」と8行目の「無鉄砲がむしゃら」はどれも評価が4点ですが、「河童ラーメン本舗 押熊店」が先に表示されます。そのこれは簡単です。同点の場合、データセット内で上に位置する行が先に表示されます。これを確認するには<code>which()</code>関数を使います。<code>()</code>内に条件文を指定することで、この条件に合致する要素の位置を返します。もし、条件に合致するものが複数あった場合は全ての位置を返します<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>。</p>
<pre class="r numberLines"><code>which(df$Name == &quot;河童ラーメン本舗 押熊店&quot;)</code></pre>
<pre><code>## [1] 6021</code></pre>
<pre class="r numberLines"><code>which(df$Name == &quot;無鉄砲がむしゃら&quot;)</code></pre>
<pre><code>## [1] 6040</code></pre>
<p>データ内に「河童ラーメン本舗 押熊店」がより上に位置することが分かります。「もし同点なら口コミ評価数が多いところにしたい」場合はどうすれば良いでしょうか。これは<code>arrange()</code>内に変数名を足すだけで十分です。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;%
  select(Name, Station, Walk, ScoreN, Score) %&gt;%
  arrange(desc(Score), desc(ScoreN)) %&gt;%
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 24 x 5
##    Name                                  Station             Walk ScoreN Score
##    &lt;chr&gt;                                 &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 まりお流ラーメン                      新大宮駅              20      1  5   
##  2 ぶ～け                                奈良駅                11      1  5   
##  3 麺屋 あまのじゃく 本店                富雄駅                 2      2  4.5 
##  4 らーめん きみちゃん                   京終駅                14      2  4.5 
##  5 彩華ラーメン 奈良店                   尼ヶ辻駅              17      3  4.33
##  6 つけめん らーめん元喜神 押熊店        学研奈良登美ヶ丘駅    12      4  4.12
##  7 無鉄砲がむしゃら                      帯解駅                15      2  4   
##  8 河童ラーメン本舗 押熊店               学研奈良登美ヶ丘駅    28      1  4   
##  9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅                 4      1  4   
## 10 彩華ラーメン 田原本店                 石見駅                15      1  4   
## 11 らーめん食堂 よってこや 平群店        元山上口駅            10      1  4   
## 12 神座 大和高田店                       大和高田駅            17      2  3.75
## 13 彩華ラーメン 本店                     前栽駅                12      5  3.6 
## 14 天下一品 東生駒店                     東生駒駅              19      1  3.5 
## 15 力皇                                  天理駅                13      1  3.5 
## 16 博多長浜らーめん夢街道 奈良土橋店     真菅駅                11      1  3.5 
## 17 ラーメン家 みつ葉                     富雄駅                 4      1  3.5 
## 18 丸源ラーメン 橿原店                   金橋駅                 8      1  3.5 
## 19 天理スタミナラーメン本店              櫟本駅                11      2  3.25
## 20 麺屋 一徳                             天理駅                 7      1  3   
## 21 どうとんぼり神座 奈良柏木店           西ノ京駅              22      1  3   
## 22 彩華ラーメン 桜井店                   大福駅                18      1  3   
## 23 天下一品 新大宮店                     新大宮駅               6      1  3   
## 24 博多長浜らーめん 夢街道 四条大路店    新大宮駅              29      4  2.88</code></pre>
<p>ソートの基準は<code>arrange()</code>内において先に指定された変数の順番となります。「口コミ評価も評価数も同じなら、駅から近いところにしたい」場合は変数が3つとなり、<code>Score</code>、<code>ScoreN</code>、<code>Walk</code>の順で入れます。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;%
  select(Name, Station, Walk, ScoreN, Score) %&gt;%
  arrange(desc(Score), desc(ScoreN), Walk) %&gt;%
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 24 x 5
##    Name                                  Station             Walk ScoreN Score
##    &lt;chr&gt;                                 &lt;chr&gt;              &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
##  1 ぶ～け                                奈良駅                11      1  5   
##  2 まりお流ラーメン                      新大宮駅              20      1  5   
##  3 麺屋 あまのじゃく 本店                富雄駅                 2      2  4.5 
##  4 らーめん きみちゃん                   京終駅                14      2  4.5 
##  5 彩華ラーメン 奈良店                   尼ヶ辻駅              17      3  4.33
##  6 つけめん らーめん元喜神 押熊店        学研奈良登美ヶ丘駅    12      4  4.12
##  7 無鉄砲がむしゃら                      帯解駅                15      2  4   
##  8 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅                 4      1  4   
##  9 らーめん食堂 よってこや 平群店        元山上口駅            10      1  4   
## 10 彩華ラーメン 田原本店                 石見駅                15      1  4   
## 11 河童ラーメン本舗 押熊店               学研奈良登美ヶ丘駅    28      1  4   
## 12 神座 大和高田店                       大和高田駅            17      2  3.75
## 13 彩華ラーメン 本店                     前栽駅                12      5  3.6 
## 14 ラーメン家 みつ葉                     富雄駅                 4      1  3.5 
## 15 丸源ラーメン 橿原店                   金橋駅                 8      1  3.5 
## 16 博多長浜らーめん夢街道 奈良土橋店     真菅駅                11      1  3.5 
## 17 力皇                                  天理駅                13      1  3.5 
## 18 天下一品 東生駒店                     東生駒駅              19      1  3.5 
## 19 天理スタミナラーメン本店              櫟本駅                11      2  3.25
## 20 天下一品 新大宮店                     新大宮駅               6      1  3   
## 21 麺屋 一徳                             天理駅                 7      1  3   
## 22 彩華ラーメン 桜井店                   大福駅                18      1  3   
## 23 どうとんぼり神座 奈良柏木店           西ノ京駅              22      1  3   
## 24 博多長浜らーめん 夢街道 四条大路店    新大宮駅              29      4  2.88</code></pre>
<hr />
</div>
<div id="記述統計量の計算" class="section level2">
<h2>記述統計量の計算</h2>
<div id="summariseによる記述統計量の計算" class="section level3">
<h3><code>summarise()</code>による記述統計量の計算</h3>
<p>ある変数の平均値や標準偏差、最小値、最大値などの記述統計量 (要約統計量)を計算することも可能です。これは<code>summarize()</code>または<code>summarise()</code>関数を使いますが、この関数は後で紹介する<code>group_by()</code>関数と組み合わせることで力を発揮します。ここではグルーピングを考えずに、全データの記述統計量を計算する方法を紹介します。</p>
<p><code>summarise()</code>関数の使い方は以下の通りです。</p>
<pre class="r numberLines"><code># summarise()関数の使い方
データフレーム/tibble名 %&gt;%
  summarise(新しい変数名 = 関数名(計算の対象となる変数名))</code></pre>
<p>もし、<code>Score</code>変数の平均値を計算し、その結果を<code>Mean</code>という列にしたい場合は以下のようなコードになります。</p>
<pre class="r numberLines"><code>df %&gt;%
  summarise(Mean = mean(Score))</code></pre>
<pre><code>## # A tibble: 1 x 1
##    Mean
##   &lt;dbl&gt;
## 1    NA</code></pre>
<p>ただし、<code>mean()</code>関数は欠損値が含まれるベクトルの場合、<code>NA</code>を返します。この場合方法は2つ考えられます。</p>
<ol style="list-style-type: decimal">
<li><code>filter()</code>関数を使って<code>Score</code>が欠損しているケースを予め除去する。</li>
<li><code>na.rm</code>引数を指定し、欠損値を除去した平均値を求める。</li>
</ol>
<p>ここでは2番目の方法を使います。</p>
<pre class="r numberLines"><code>df %&gt;%
  summarise(Mean = mean(Score, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 1
##    Mean
##   &lt;dbl&gt;
## 1  3.66</code></pre>
<p><code>df</code>の<code>Score</code>変数の平均値はNAであることが分かります。また、<code>summarise()</code>関数は複数の記述統計量を同時に計算することも可能です。以下は<code>Score</code>変数の平均値、中央値、標準偏差、最小値、最大値、第一四分位点、第三四分位点を計算し、<code>Score.Desc</code>という名のデータフレーム (または、tibble)に格納するコードです。</p>
<pre class="r numberLines"><code>Score.Desc &lt;- df %&gt;%
  summarize(Mean   =     mean(Score,       na.rm = TRUE),  # 平均値
            Median =   median(Score,       na.rm = TRUE),  # 中央値
            SD     =       sd(Score,       na.rm = TRUE),  # 標準偏差
            Min    =      min(Score,       na.rm = TRUE),  # 最小値
            Max    =      max(Score,       na.rm = TRUE),  # 最大値
            Q1     = quantile(Score, 0.25, na.rm = TRUE),  # 第一四分位点
            Q3     = quantile(Score, 0.75, na.rm = TRUE))  # 第三四分位点</code></pre>
<pre class="r numberLines"><code>Score.Desc</code></pre>
<pre><code>## # A tibble: 1 x 7
##    Mean Median    SD   Min   Max    Q1    Q3
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  3.66   3.58 0.719     1     5     3     4</code></pre>
<p>むろん、複数の変数に対して記述統計量を計算することも可能です。たとえば、平均予算 (<code>Budget</code>)、口コミ数 (<code>ScoreN</code>)、口コミ評価 (<code>Score</code>)の平均値を求めるとしたら、</p>
<pre class="r numberLines"><code>df %&gt;%
  summarize(Budget_Mean = mean(Budget, na.rm = TRUE), # 平均予算の平均値
            SocreN_Mean = mean(ScoreN, na.rm = TRUE), # 口コミ数の平均値
            Score_Mean  = mean(Score,  na.rm = TRUE)) # 評価の平均値</code></pre>
<pre><code>## # A tibble: 1 x 3
##   Budget_Mean SocreN_Mean Score_Mean
##         &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;
## 1       1232.       0.537       3.66</code></pre>
<p>のように書きます。実は<code>summarise()</code>はこれくらいで十分便利です。ただし、以上の操作はもっと簡単なコードに置換できます。ただし、ラムダ式など、やや高度な内容になるため、以下の内容は飛ばして、次の節 (グルーピング)を読んでいただいても構いません。</p>
<p>まずは、複数の変数に対して同じ記述統計量を求める例を考えてみましょう。たとえば、<code>Budget</code>、<code>ScoreN</code>、<code>Score</code>に対して平均値を求める例です。これは<code>across()</code>関数を使うとよりコードが短くなります。まずは<code>across()</code>関数の書き方から見ましょう。</p>
<pre class="r numberLines"><code># across()の使い方
データフレーム/tibble名 %&gt;%
  summarise(across(変数名のベクトル, 記述統計を計算する関数名, 関数の引数))</code></pre>
<p><em>変数名のベクトル</em>は長さ1以上のベクトルです。たとえば、<code>Budget</code>、<code>ScoreN</code>、<code>Score</code>の場合<code>c(Budget, ScoreN, Score)</code>になります。これは<code>df</code>内で隣接する変数ですから<code>Budget:Score</code>の書き方も使えます。また、<code>where()</code>や<code>any_of()</code>、<code>starts_with()</code>のような関数を使って変数を指定することも可能です。<em>関数名</em>は<code>mean</code>や<code>sd</code>などの関数名です。ここは<code>関数名()</code>でななく、<code>関数名</code>であることに注意してください。<em>引数</em>は前の関数に必要な引数です。引数を必要としない関数なら省略可能ですが、<code>na.rm = TRUE</code>などの引数が必要な場合は指定する必要があります。それでは<code>Budget</code>、<code>ScoreN</code>、<code>Score</code>の平均値を計算してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  summarize(across(Budget:Score, mean, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 3
##   Budget ScoreN Score
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
## 1  1232.  0.537  3.66</code></pre>
<p><code>across()</code>使わない場合、4行必要だったコードが2行になりました。変数が少ない場合は<code>across()</code>を使わない方が、可読性が高くなる場合もあります。しかし、変数が多くなる場合、可読性がやや落ちても<code>across()</code>を使った方が効率的でしょう。</p>
<p>次は、ある変数に対して複数の記述統計量を計算したい場合について考えます。<code>Budget</code>、<code>ScoreN</code>、<code>Score</code>変数の第一四分位点と第三四分位点を<code>across()</code>を使わずに計算すると家のような7行のコードになります。</p>
<pre class="r numberLines"><code>df %&gt;%
  summarize(Budget_Q1 = quantile(Budget, 0.25, na.rm = TRUE),
            Budget_Q3 = quantile(Budget, 0.75, na.rm = TRUE),
            ScoreN_Q1 = quantile(ScoreN, 0.25, na.rm = TRUE),
            ScoreN_Q3 = quantile(ScoreN, 0.75, na.rm = TRUE),
            Score_Q1  = quantile(Score,  0.25, na.rm = TRUE),
            Score_Q3  = quantile(Score,  0.75, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 6
##   Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3
##       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1       800      1000         0         0        3        4</code></pre>
<p>この作業も<code>across()</code>を使ってより短縮することができます。ここではラムダ式の知識が必要になります。ラムダ関数とは関数名を持たない<a href="https://ja.wikipedia.org/wiki/無名関数">無名関数 (anonymous functions)</a>を意味しますが、詳細は割愛します。興味のある読者は<a href="https://ja.wikipedia.org/wiki/無名関数">Wikipedia</a>などを参照してください。簡単にいうとその場で即席に関数を作成し、計算が終わったら破棄する関数です。ただ、Rは基本的にラムダ式を提供しているのではなく、<code>purrr</code>パッケージのラムダ式スタイルを使用します。まずは、書き方から確認します。</p>
<pre class="r numberLines"><code># ラムダ式を用いたacross()の使い方
データフレーム/tibble名 %&gt;%
  summarise(across(変数名のベクトル, list(結果の変数名 = ラムダ式)))</code></pre>
<p>先ほどの書き方と似ていますが、関数を複数書く必要があるため、今回は関数名をlist型にまとめます。そして、<em>結果の変数名</em>は結果として出力されるデータフレーム (または、tibble)の列名を指定する引数です。たとえば、<code>Mean</code>にすると結果は<code>元の変数名1_Mean</code>、<code>元の変数名2_Mean</code>…のように出力されます。そして、ラムダ式が実際の関数が入る箇所です。とりあえず今回はコードを走らせ、結果から確認してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  summarize(across(Budget:Score, list(Q1 = ~quantile(.x, 0.25, na.rm = TRUE),
                                      Q3 = ~quantile(.x, 0.75, na.rm = TRUE))))</code></pre>
<pre><code>## # A tibble: 1 x 6
##   Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3
##       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1       800      1000         0         0        3        4</code></pre>
<p>結果の列名が<code>Budget_Q1</code>、<code>Budget_Q3</code>、<code>ScoreN_Q1</code>…のようになり、それぞれの変数の第一四分位点と第三四分位点が出力されます。問題はラムダ式の方ですが、普通の関数に非常に近いことが分かります。<code>across()</code>内のラムダ式は<code>~関数名(.x, その他の引数)</code>のような書き方になります。関数名の前に<code>~</code>が付いていることに注意してください。分位数を求める関数は<code>quantile()</code>であり、<code>quantile(ベクトル, 分位数)</code>であり、必要に応じて<code>na.rm</code>を付けます。この分位数が0.25なら第一四分位点、0.5なら第二四分位点 (=中央値)、0.75なら第三四分位点になります。それではラムダ式<code>~quantile(.x, 0.25, na.rm = TRUE)</code>はどういう意味でしょうか。これは<code>.x</code>の箇所に<code>Budget</code>や<code>ScoreN</code>、<code>Score</code>が入ることを意味します。<code>.x</code>という書き方は決まりです。<code>.y</code>とか<code>.Song-san-Daisuki</code>などはダメです。そして、<code>0.25</code>を付けることによって第一四分位点を出力するように指定します。また、<code>Budget</code>、<code>ScoreN</code>、<code>Score</code>に欠損値がある場合、無視するように<code>na.rm = TRUE</code>を付けます。</p>
<p>ラムダ式を自分で定義する関数で表現すると、以下のようになります。</p>
<pre class="r numberLines"><code># 以下の3つは同じ機能をする関数である

# ラムダ式
~quantile(.x, 0.25, na.rm = TRUE)

# 一般的な関数の書き方1
名無し関数 &lt;- function(x) {
  quantile(x, 0.25, na.rm = TRUE)
}

# 一般的な関数の書き方2
名無し関数 &lt;- function(x) quantile(x, 0.25, na.rm = TRUE)</code></pre>
<p>この3つは全て同じですが、ラムダ式は関数名を持たず、その場で使い捨てる関数です。むろん、ラムダ式を使わずに事前に第一四分位点と第三四分位点を求める関数を予め作成し、ラムダ式の代わりに使うことも可能です。まずは第一四分位点と第三四分位点を求める自作関数<code>FuncQ1</code>と<code>FuncQ2</code>を作成します。</p>
<pre class="r numberLines"><code># ラムダ式を使わない場合は事前に関数を定義しておく必要がある
FuncQ1 &lt;- function(x) {
  quantile(x, 0.25, na.rm = TRUE)
}
FuncQ3 &lt;- function(x) {
  quantile(x, 0.75, na.rm = TRUE)
}</code></pre>
<p>後は先ほどのほぼ同じ書き方ですが、今回はラムダ式を使わないため関数名に<code>~</code>を付けず、関数名のみで十分です。</p>
<pre class="r numberLines"><code># やっておくと、summarise()文は簡潔になる
df %&gt;%
  summarize(across(Budget:Score, list(Q1 = FuncQ1, Q3 = FuncQ3)))</code></pre>
<pre><code>## # A tibble: 1 x 6
##   Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3
##       &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1       800      1000         0         0        3        4</code></pre>
<p>事前に関数を用意するのが面倒ですが、<code>across()</code>の中身はかなりスッキリしますね。もし、このような作業を何回も行うなら、ラムダ式を使わず、自作関数を用いることも可能です。ただし、自作関数であっても引数が2つ以上必要な場合はラムダ式を使います。</p>
</div>
<div id="summariseに使える便利な関数" class="section level3">
<h3><code>summarise()</code>に使える便利な関数</h3>
<p>以下の内容は後で説明する<code>group_by()</code>関数を使っているため、まだ<code>group_by()</code>に馴染みのない読者はまずはここを読み飛ばし、グルーピングの節にお進みください。</p>
<p><strong><code>IQR()</code>: 四分位範囲を求める</strong></p>
<p>四分位範囲は第三四分位点から第一四分位点を引いた値であり、Rの内蔵関数である<code>IQR()</code>を使えば便利です。この関数は<code>mean</code>や<code>sd()</code>関数と同じ使い方となります。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Walk)) %&gt;% # 予め欠損したケースを除くと、後でna.rm = TRUEが不要
  group_by(Pref) %&gt;%
  summarise(Mean    = mean(Walk),
            SD      = sd(Walk),
            IQR     = IQR(Walk),
            N       = n(),
            .groups = &quot;drop&quot;) %&gt;%
  arrange(Mean)</code></pre>
<pre><code>## # A tibble: 9 x 5
##   Pref      Mean    SD   IQR     N
##   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1 東京都    4.29  4.49     4   919
## 2 大阪府    5.92  6.08     6   932
## 3 神奈川県  8.21  7.91    10   878
## 4 京都府    8.38  6.95     9   339
## 5 兵庫県    8.52  7.27    10   484
## 6 奈良県   10.6   6.59    10   123
## 7 千葉県   10.6   8.21    12   776
## 8 埼玉県   11.6   8.99    14   817
## 9 和歌山県 12.8   6.83     9   107</code></pre>
<p><strong><code>first()</code>、<code>last()</code>、<code>nth()</code>: n番目の要素を求める</strong></p>
<p>稀なケースかも知れませんが、データ内、またはグループ内の<code>n</code>番目の行を抽出する時があります。たとえば、市区町村の情報が格納されているデータセットで、人口が大きい順でデータがソートされているとします。各都道府県ごとに最も人口が大きい市区町村のデータ、あるいは最も少ない市区町村のデータが必要な際、<code>first()</code>と<code>last()</code>関数が有効です。</p>
<p>それでは各都道府県ごとに「最も駅から遠いラーメン屋」の店舗名と最寄りの駅からの徒歩距離を出力したいとします。まずは、徒歩距離のデータが欠損しているケースを除去し、データを徒歩距離順でソートします。これは<code>filter()</code>と<code>arrange()</code>関数を使えば簡単です。続いて、<code>group_by()</code>を使って都府県単位でデータをグループ化します。最後に<code>summarise()</code>関数内に<code>last()</code>関数を使います。データは駅から近い順に鳴っているため、各都府県内の最後の行は駅から最も遠い店舗になるからです。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Walk)) %&gt;%
  arrange(Walk) %&gt;%
  group_by(Pref) %&gt;%
  summarise(Farthest  = last(Name),
            Distance  = last(Walk),
            .groups   = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     Farthest                           Distance
##   &lt;chr&gt;    &lt;chr&gt;                                 &lt;dbl&gt;
## 1 京都府   熱烈らぁめん                             30
## 2 兵庫県   濃厚醤油 中華そば いせや 玉津店          43
## 3 千葉県   札幌ラーメン どさん子 佐原51号店         59
## 4 和歌山県 中華そば まる乃                          30
## 5 埼玉県   札幌ラーメン どさん子 小鹿野店          116
## 6 大阪府   河童ラーメン本舗 岸和田店                38
## 7 奈良県   博多長浜らーめん 夢街道 四条大路店       29
## 8 東京都   てんがら 青梅新町店                      30
## 9 神奈川県 札幌ラーメン どさん子 中津店             73</code></pre>
<p>この<code>last()</code>を<code>first()</code>に変えると、最寄りの駅から最も近い店舗情報が表示されます。また、「<code>n</code>番目の情報」が必要な際は<code>nth()</code>関数を使います。<code>nth(Name, 2)</code>に変えることで2番目の店舗名が抽出できます。</p>
<p><strong><code>n_distinct()</code>: ユニーク値の個数を求める</strong></p>
<p><code>n_distinct()</code>は何種類の要素が含まれているかを計算する関数であり、<code>length(unique())</code>関数と同じ機能をします。たとえば、以下の<code>myVec1</code>に対して何種類の要素があるかを確認してみましょう。</p>
<pre class="r numberLines"><code>myVec1 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;)

unique(myVec1)</code></pre>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;C&quot;</code></pre>
<p><code>myVec1</code>は<code>"A"</code>、<code>"B"</code>、<code>"D"</code>、<code>"C"</code>の要素で構成されていることが分かります。これが<code>myVec1</code>の<strong>ユニーク値 (unique values)</strong>です。そして、このユニーク値の個数を調べるために<code>length()</code>を使います。</p>
<pre class="r numberLines"><code>length(unique(myVec1))</code></pre>
<pre><code>## [1] 4</code></pre>
<p>これで<code>myVec1</code>は4種類の値が存在することが分かります。これと全く同じ機能をする関数が<code>n_distinct()</code>です。</p>
<pre class="r numberLines"><code>n_distinct(myVec1)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>この関数を<code>summarise()</code>に使うことで、都府県ごとに駅の個数が分かります。あるいは「東京都内の選挙区に、これまでの衆院選において何人の候補者が存在したか」も分かります。ここでは<code>df</code>内の都府県ごとに駅の個数を計算してみましょう。最後の駅数が多い順でソートします。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Station)) %&gt;% # 最寄りの駅が欠損しているケースを除去
  group_by(Pref) %&gt;%
  summarise(N_Station = n_distinct(Station),
            .groups   = &quot;drop&quot;) %&gt;%
  arrange(desc(N_Station))</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     N_Station
##   &lt;chr&gt;        &lt;int&gt;
## 1 東京都         368
## 2 大阪府         341
## 3 千葉県         241
## 4 神奈川県       240
## 5 兵庫県         199
## 6 埼玉県         185
## 7 京都府         123
## 8 奈良県          52
## 9 和歌山県        46</code></pre>
<p>当たり前かも知れませんが、駅数が最も多いのは東京都で次が大阪府であることが分かります。</p>
<p><strong><code>any()</code>、<code>all()</code>: 条件に合致するか否かを求める</strong></p>
<p><code>any()</code>と<code>all()</code>はベクトル内の全要素に対して条件に合致するか否かを判定する関数です。ただし、<code>any()</code>は一つの要素でも条件に合致すれば<code>TRUE</code>を、全要素が合致しない場合<code>FALSE</code>を返します。一方、<code>all()</code>は全要素に対して条件を満たせば<code>TRUE</code>、一つでも満たさない要素があれば<code>FALSE</code>を返します。以下は<code>any()</code>と<code>all()</code>の例です。</p>
<pre class="r numberLines"><code>myVec1 &lt;- c(1, 2, 3, 4, 5)
myVec2 &lt;- c(1, 3, 5, 7, 11)

any(myVec1 %% 2 == 0) # myVec1を2で割った場合、一つでも余りが0か</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r numberLines"><code>all(myVec1 %% 2 == 0) # myVec1を2で割った場合、全ての余りが0か</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r numberLines"><code>all(myVec2 %% 2 != 0) # myVec2を2で割った場合、全ての余りが0ではないか</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>それでは実際に<code>df</code>に対して<code>any()</code>と<code>all()</code>関数を使ってみましょう。一つ目は「ある都府県に最寄りの駅から徒歩60分以上の店舗が<strong>一つでも</strong>あるか」であり、二つ目は「ある都府県の店舗は<strong>全て</strong>最寄りの駅から徒歩30分以下か」です。それぞれの結果を<code>Over60</code>と<code>Within30</code>という列で出力してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  group_by(Pref) %&gt;%
  summarise(Over60   = any(Walk &gt;= 60, na.rm = TRUE),
            Within30 = all(Walk &lt;= 30, na.rm = TRUE),
            .groups  = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     Over60 Within30
##   &lt;chr&gt;    &lt;lgl&gt;  &lt;lgl&gt;   
## 1 京都府   FALSE  TRUE    
## 2 兵庫県   FALSE  FALSE   
## 3 千葉県   FALSE  FALSE   
## 4 和歌山県 FALSE  TRUE    
## 5 埼玉県   TRUE   FALSE   
## 6 大阪府   FALSE  FALSE   
## 7 奈良県   FALSE  TRUE    
## 8 東京都   FALSE  TRUE    
## 9 神奈川県 TRUE   FALSE</code></pre>
<p>埼玉県と神奈川県において、最寄りの駅から徒歩60以上の店がありました。また、京都府、東京都、奈良県、和歌山県の場合、全店舗が最寄りの駅から徒歩30分以下ということが分かります。当たり前ですが<code>Over60</code>が<code>TRUE</code>なら<code>Within30</code>は必ず<code>FALSE</code>になりますね。</p>
<hr />
</div>
</div>
<div id="グルーピング" class="section level2">
<h2>グルーピング</h2>
<div id="group_byによるグループ化" class="section level3">
<h3><code>group_by()</code>によるグループ化</h3>
<p>先ほどの<code>summarise()</code>関数は確かに便利ですが、特段に便利とも言いにくいです。<code>df</code>の<code>Score</code>の平均値を計算するだけなら、<code>summarise()</code>関数を使わない方が楽です。</p>
<pre class="r numberLines"><code># これまでのやり方
df %&gt;%
  summarise(Mean = mean(Score, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 1
##    Mean
##   &lt;dbl&gt;
## 1  3.66</code></pre>
<pre class="r numberLines"><code># 普通にこれでええんちゃう?
mean(df$Score, na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.663457</code></pre>
<p>しかし、これをグループごとに計算するならどうでしょう。たとえば、<code>Score</code>の平均値を都府県ごとに計算するとします。この場合、以下のようなコードになります。</p>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;東京都&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.674256</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;神奈川県&quot;], na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.533931</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;千葉県&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.715983</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;埼玉県&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.641573</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;大阪府&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.765194</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;京都府&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.684976</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;兵庫県&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.543936</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;奈良県&quot;],   na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.854762</code></pre>
<pre class="r numberLines"><code>mean(df$Score[df$Pref == &quot;和歌山県&quot;], na.rm = TRUE)</code></pre>
<pre><code>## [1] 3.96999</code></pre>
<p>変わったのは<code>df$Score</code>が<code>df$Score[df$Pref == "東京都"]</code>に変わっただけです。<code>df$Pref</code>が<code>"東京都"</code>であるか否かを<code>TRUE</code>と<code>FALSE</code>で判定し、これを基準に<code>df$Score</code>を抽出する仕組みです。<code>df$Score</code>と<code>df$Pref</code>は同じデータフレーム (または、tibble)ですから、このような書き方で問題ありません。</p>
<p>これだけでもかなり書くのが面倒ですが、これが47都道府県なら、あるいは200ヶ国ならかなり骨の折れる作業でしょう。ここで大活躍するのが<code>dplyr</code>パッケージの<code>group_by()</code>関数です。引数はグループ化する変数名だけです。先ほどの作業を<code>dplyr</code>を使うなら<code>Pref</code>変数でグループ化し、<code>summarise()</code>関数で平均値を求めるだけです。今回は<code>Score</code>だけでなく、<code>ScoreN</code>の平均値も求めてみましょう。そして、評価が高い順にソートもしてみます。</p>
<pre class="r numberLines"><code># ScoreNとScoreの平均値をPrefごとに求める
df %&gt;%
  group_by(Pref) %&gt;%
  summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE)) %&gt;%
  arrange(desc(Score_Mean))</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     ScoreN_Mean Score_Mean
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;
## 1 和歌山県       0.593       3.97
## 2 奈良県         0.306       3.85
## 3 大阪府         0.516       3.77
## 4 千葉県         0.259       3.72
## 5 京都府         0.522       3.68
## 6 東京都         1.16        3.67
## 7 埼玉県         0.278       3.64
## 8 兵庫県         0.389       3.54
## 9 神奈川県       0.587       3.53</code></pre>
<p>評判が最も高い都府県は和歌山県、最も低いのは神奈川県ですね。Songも和歌山ラーメンは井出系も車庫前系も好きです。しかし、大事なのは「井出系」と「車庫前系」といった分類が正しいかどうかではありません。コードが非常に簡潔となり、ソートなども自由自在であることです。都府県ごとに<code>ScoreN</code>と<code>Score</code>の平均値を求める場合、<code>dplyr()</code>を使わなかったら18行のコードとなり、ソートも自分でやる必要があります。一方、<code>group_by()</code>関数を使うことによってコードが5行になりました。</p>
<p>また、これは2020年6月に公開された<code>dplyr</code>1.0.0からの問題ですが、<code>group_by()</code>の後に<code>summarise()</code>を使うと以下のようなメッセージが出力されます。</p>
<pre><code>## `summarise()` ungrouping output (override with `.groups` argument)</code></pre>
<p>これは<code>group_by()</code>で指定された変数のグループ化が自動的に解除されたことを意味します。なぜなら<code>summarise()</code>をする際は<code>Pref</code>をグループ変数として使いましたが、出力された結果の<code>Pref</code>変数はもはやグループとして機能できなくなるからです。元の<code>df</code>には<code>Pref</code>が<code>"東京都"</code>だったケースが1000行、<code>"京都府"</code>だったのが414行あったので、<code>Pref</code>変数でグループ化する意味がありました。しかし、<code>summarise()</code>から得られたデータフレーム (または、tibble)は<code>Pref == "東京都"</code>の行が1つしかありません。これはグループ化する意味がなくなったことを意味します。したがって、自動的にグループを解除してくれます。自動的にやってくれるのはありがたいことですが、可能ならば関数内に自分で明記することが推奨されます。そこで使う引数が<code>.groups</code>であり、<code>"drop"</code>を指定すると<strong>全ての</strong>グループ化変数を解除します。以下のようなコードだと先ほどのメッセージが表示されません。今後、意識的に入れるようにしましょう。</p>
<pre class="r numberLines"><code># ScoreNとScoreの平均値をPrefごとに求める
df %&gt;%
  group_by(Pref) %&gt;%
  summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE),
            .groups     = &quot;drop&quot;) %&gt;%
  arrange(desc(Score_Mean))</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     ScoreN_Mean Score_Mean
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;
## 1 和歌山県       0.593       3.97
## 2 奈良県         0.306       3.85
## 3 大阪府         0.516       3.77
## 4 千葉県         0.259       3.72
## 5 京都府         0.522       3.68
## 6 東京都         1.16        3.67
## 7 埼玉県         0.278       3.64
## 8 兵庫県         0.389       3.54
## 9 神奈川県       0.587       3.53</code></pre>
<p>続いて、一つ便利な関数を紹介します。それはグループのサイズを計算する関数、<code>n()</code>です。この関数を<code>summarise()</code>内に使うと、各グループに属するケース数を出力します。先ほどのコードを修正し、各グループのサイズを<code>N</code>という名の列として追加してみましょう。そしてソートの順番は<code>N</code>を最優先とし、同じ場合は<code>Score_Mean</code>が高い方を上に出力させます。また、<code>ScoreN_Mean</code>の前に、口コミ数の合計も出してみましょう。</p>
<pre class="r numberLines"><code># Prefごとに口コミ数の合計、口コミ数の平均値、評価の平均値、店舗数を求める
# 店舗数-評価の平均値順でソートする
df %&gt;%
  group_by(Pref) %&gt;%
  summarise(ScoreN_Sum  = sum(ScoreN,  na.rm = TRUE),
            ScoreN_Mean = mean(ScoreN, na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE),
            N           = n(),
            .groups     = &quot;drop&quot;) %&gt;%
  arrange(desc(N), desc(Score_Mean))</code></pre>
<pre><code>## # A tibble: 9 x 5
##   Pref     ScoreN_Sum ScoreN_Mean Score_Mean     N
##   &lt;chr&gt;         &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 大阪府          516       0.516       3.77  1000
## 2 千葉県          259       0.259       3.72  1000
## 3 東京都         1165       1.16        3.67  1000
## 4 埼玉県          278       0.278       3.64  1000
## 5 神奈川県        587       0.587       3.53  1000
## 6 兵庫県          230       0.389       3.54   591
## 7 京都府          216       0.522       3.68   414
## 8 奈良県           45       0.306       3.85   147
## 9 和歌山県         83       0.593       3.97   140</code></pre>
<p>記述統計をグループごとに求めるのは普通にあり得るケースですし、実験データの場合はほぼ必須の作業でう。統制群と処置群間においてグループサイズが均一か、共変量のバラツキが十分に小さいかなどを判断する際に<code>group_by()</code>と<code>summarise()</code>関数の組み合わせは非常に便利です。</p>
</div>
<div id="複数の変数を用いたグループ化" class="section level3">
<h3>複数の変数を用いたグループ化</h3>
<p>グループ化変数は2つ以上指定することも可能です。たとえば、都府県 (<code>Pref</code>)と最寄りの駅の路線 (<code>Line</code>)でグループ化することも可能です。それでは<code>Pref</code>と<code>Line</code>でグループ化し、店舗数と口コミ数、評価の平均値を計算し、ソートの順番は店舗数、店舗数が同じなら評価の平均値が高い順にしましょう。今回も<code>summarise()</code>内に<code>.group = "drop"</code>を指定し、グループ化を解除します。今回はTop 20まで出してみましょう。</p>
<pre class="r numberLines"><code># ScoreNとScoreの平均値をPrefごとに求める
df %&gt;%
  filter(!is.na(Line)) %&gt;% # Lineが欠損していないケースのみ残す
  group_by(Pref, Line) %&gt;% # PrefとLineでグループ化
  summarise(N           = n(),
            ScoreN_Sum  = sum(ScoreN,  na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE),
            .groups     = &quot;drop&quot;) %&gt;%
  arrange(desc(N), desc(Score_Mean)) %&gt;%
  print(n = 20)</code></pre>
<pre><code>## # A tibble: 523 x 5
##    Pref     Line                        N ScoreN_Sum Score_Mean
##    &lt;chr&gt;    &lt;chr&gt;                   &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
##  1 埼玉県   東武東上線                122         27       3.68
##  2 東京都   ＪＲ                      104        231       3.56
##  3 神奈川県 小田急小田原線             96         31       3.59
##  4 埼玉県   東武伊勢崎線               96         18       3.51
##  5 神奈川県 横浜市営ブルーライン       82         77       3.66
##  6 千葉県   京成本線                   82         29       3.34
##  7 神奈川県 京急本線                   68         40       3.33
##  8 千葉県   東武野田線                 63          2       4.75
##  9 神奈川県 小田急江ノ島線             62          8       3.79
## 10 大阪府   阪急京都本線               53         32       3.67
## 11 大阪府   南海本線                   52         11       4.22
## 12 兵庫県   阪神本線                   52         23       3.80
## 13 埼玉県   JR高崎線                   51          5       4   
## 14 兵庫県   山陽電鉄本線               51         15       2.98
## 15 千葉県   JR総武本線（東京-銚子）    47          8       4   
## 16 埼玉県   西武新宿線                 45          8       4.17
## 17 埼玉県   秩父鉄道線                 43         10       3.82
## 18 大阪府   京阪本線                   43         10       3.69
## 19 千葉県   新京成電鉄                 43          6       3.6 
## 20 京都府   阪急京都本線               43         27       3.5 
## # … with 503 more rows</code></pre>
<p>ぐるなびに登録されているラーメン屋が最も多い路線は埼玉県内の東武東上線で122店舗があります。東武東上線は東京都と埼玉県をまたがる路線ですので、東武東上線だけならもっと多いかも知れませんね。</p>
<p>ここで一つ考えたいのは<code>summarise()</code>内の<code>.groups</code>引数です。前回はグループ化に使った変数ごとに1行しか残っていなかったのでグループ化を全て解除しました。しかし、今回は状況がやや異なります。グループ化変数に使った<code>Pref</code>を考えると、まだ<code>Pref == "東京都"</code>であるケースがいくつかあります。やろうとすればまだグループ化出来る状態です。これは<code>Line</code>についても同じです。<code>Line == "東武東上線"</code>の行はここには表示されていないものの、まだデータに残っています。もし、これ以上グループ化しないなら今のように<code>.groups = "drop"</code>が正しいですが、もしもう一回グループ化したい場合はどうすればよいでしょうか。方法は2つ考えられます。</p>
<ol style="list-style-type: decimal">
<li>もう一度パイプ演算子を使って<code>group_by()</code>関数を使う (以下の9行目)。
<ul>
<li>結果を見ると<code>## # Groups:   Pref, Line [523]</code>で、ちゃんとグループ化されていることが分かります。</li>
</ul></li>
</ol>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Line)) %&gt;% 
  group_by(Pref, Line) %&gt;% 
  summarise(N           = n(),
            ScoreN_Sum  = sum(ScoreN,  na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE),
            .groups     = &quot;drop&quot;) %&gt;%
  arrange(desc(N), desc(Score_Mean)) %&gt;%
  group_by(Pref, Line) %&gt;% # group_by()、もう一度
  print(n = 5)</code></pre>
<pre><code>## # A tibble: 523 x 5
## # Groups:   Pref, Line [523]
##   Pref     Line                     N ScoreN_Sum Score_Mean
##   &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
## 1 埼玉県   東武東上線             122         27       3.68
## 2 東京都   ＪＲ                   104        231       3.56
## 3 神奈川県 小田急小田原線          96         31       3.59
## 4 埼玉県   東武伊勢崎線            96         18       3.51
## 5 神奈川県 横浜市営ブルーライン    82         77       3.66
## # … with 518 more rows</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><code>.groups</code>引数を何とかする。</li>
</ol>
<p>推奨される方法は2番です。具体的には<code>.groups = "keep"</code>を指定するだけであり、こっちの方が無駄なコードを省けることができます。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Line)) %&gt;% 
  group_by(Pref, Line) %&gt;% 
  summarise(N           = n(),
            ScoreN_Sum  = sum(ScoreN,  na.rm = TRUE),
            Score_Mean  = mean(Score,  na.rm = TRUE),
            .groups     = &quot;keep&quot;) %&gt;%
  arrange(desc(N), desc(Score_Mean)) %&gt;%
  print(n = 5)</code></pre>
<pre><code>## # A tibble: 523 x 5
## # Groups:   Pref, Line [523]
##   Pref     Line                     N ScoreN_Sum Score_Mean
##   &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
## 1 埼玉県   東武東上線             122         27       3.68
## 2 東京都   ＪＲ                   104        231       3.56
## 3 神奈川県 小田急小田原線          96         31       3.59
## 4 埼玉県   東武伊勢崎線            96         18       3.51
## 5 神奈川県 横浜市営ブルーライン    82         77       3.66
## # … with 518 more rows</code></pre>
<p><code>.groups</code>引数は<code>"drop"</code>と<code>"keep"</code>以外にも<code>"drop_last"</code>があります。実は<code>summarise()</code>に<code>.groups</code>引数を指定したい場合のデフォルト値は<code>.groups == "drop_last"</code>または<code>"keep"</code>ですが、ここがややこしいです。主なケースにおいてデフォルト値は<code>"drop"</code>となりますとなります。<code>.groups == "drop_last"</code>これは最後のグループ化変数のみ解除する意味です。今回の例だと、2番目のグループ化変数である<code>Line</code>がグループ化変数から外され、<code>Pref</code>のみがグループ化変数として残る仕組みです。</p>
<p>それではデフォルト値が<code>"keep"</code>になるのはいつでしょうか。それは記述統計量の結果が長さ2以上のベクトルである場合です。平均値を求める<code>mean()</code>、標準偏差を求める<code>sd()</code>などは、結果として長さ1のベクトルを返します。しかし、長さ2以上ののベクトルを返す関数もあります。たとえば、分位数を求める<code>quantile()</code>関数があります。<code>quantile(ベクトル名, 0.25)</code>の場合、第一四分位点のみ返すため、結果は長さ1のベクトルです。しかし、<code>quantile(ベクトル名, c(0.25, 0.5, 0.75))</code>のように第一四分位点から第三四分位点を同時に計算し、長さ3のベクトルが返されるケースもありますし、第二引数を省略すると、最小値・第一四分位点・第二四分位点・第三四分位点・最大値、つまり、長さ5のベクトルが返される場合があります。</p>
<pre class="r numberLines"><code># 第一四分位点のみを求める (長さ1のベクトル)
quantile(df$Walk, 0.25, na.rm = TRUE)</code></pre>
<pre><code>## 25% 
##   2</code></pre>
<pre class="r numberLines"><code># 引数を省略する (長さ5のベクトル)
quantile(df$Walk, na.rm = TRUE)</code></pre>
<pre><code>##   0%  25%  50%  75% 100% 
##    1    2    5   12  116</code></pre>
<p><code>.groups</code>のデフォルト値が<code>"keep"</code>になるのは、このように長さ2以上のベクトルが返されるケースです。たとえば、都府県と最寄りの駅の路線でグループ化し、店舗までの徒歩距離の平均値を求めるとします。デフォルト値の変化を見るために、ここではあえて<code>.groups</code>引数を省略しました。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Walk)) %&gt;%
  group_by(Pref, Line) %&gt;%
  summarise(Mean = mean(Walk))</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;Pref&#39;. You can override using the `.groups` argument.</code></pre>
<pre><code>## # A tibble: 509 x 3
## # Groups:   Pref [9]
##    Pref   Line                       Mean
##    &lt;chr&gt;  &lt;chr&gt;                     &lt;dbl&gt;
##  1 京都府 ＪＲ                       4   
##  2 京都府 ＪＲ京都線                10   
##  3 京都府 JR奈良線                   3.33
##  4 京都府 ＪＲ奈良線                 8   
##  5 京都府 JR小浜線                  16.5 
##  6 京都府 ＪＲ小浜線                 9   
##  7 京都府 ＪＲ山陰本線              19   
##  8 京都府 JR山陰本線（京都-米子）    8.67
##  9 京都府 ＪＲ山陰本線（京都-米子）  9.23
## 10 京都府 ＪＲ嵯峨野線               5   
## # … with 499 more rows</code></pre>
<p>最初は<code>Pref</code>と<code>Line</code>でグループ化しましたが、<code>summarise()</code>の後、<code>Line</code>がグループ化変数から外されました。つまり、引数が<code>"drop_last"</code>になっていることです。</p>
<p>それでは、平均値に加えて、第一四分位点と第三四分位点も計算し、<code>Quantile</code>という名で格納してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Walk)) %&gt;%
  group_by(Pref, Line) %&gt;%
  summarise(Mean     = mean(Walk),
            Quantile = quantile(Walk, c(0.25, 0.75)))</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;Pref&#39;, &#39;Line&#39;. You can override using the `.groups` argument.</code></pre>
<pre><code>## # A tibble: 1,018 x 4
## # Groups:   Pref, Line [509]
##    Pref   Line        Mean Quantile
##    &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;
##  1 京都府 ＪＲ        4        1.25
##  2 京都府 ＪＲ        4        5   
##  3 京都府 ＪＲ京都線 10       10   
##  4 京都府 ＪＲ京都線 10       10   
##  5 京都府 JR奈良線    3.33     2   
##  6 京都府 JR奈良線    3.33     5   
##  7 京都府 ＪＲ奈良線  8        4   
##  8 京都府 ＪＲ奈良線  8        9   
##  9 京都府 JR小浜線   16.5      9.75
## 10 京都府 JR小浜線   16.5     23.2 
## # … with 1,008 more rows</code></pre>
<p>同じ<code>Pref</code>、<code>Line</code>のケースが2つずつ出来ています。最初に来る数値は第一四分位点、次に来るのが第三四分位点です。そして最初のグループ化変数であった<code>Pref</code>と<code>Line</code>が、<code>summarise()</code>後もグループ化変数として残っていることが分かります。</p>
<p><code>.groups</code>引数は記述統計量だけを計算する意味ではあまり意識する必要がありません。しかし、得られた記述統計量から何らかの計算をしたり、さらにもう一回記述統計量を求めたりする際、予期せぬ結果が得られる可能性があるため注意する必要があります。出来る限り<code>.groups</code>引数は指定するようにしましょう。</p>
<hr />
</div>
</div>
<div id="変数の計算" class="section level2">
<h2>変数の計算</h2>
<div id="mutate関数の使い方" class="section level3">
<h3><code>mutate()</code>関数の使い方</h3>
<p>続いて、データフレーム (または、tibble)内の変数を用いて計算を行い、その結果を新しい列として格納する<code>mutate()</code>関数について紹介します。まず、<code>mutate()</code>関数の書き方からです。</p>
<pre class="r numberLines"><code># mutate()関数の使い方
データフレーム/tibble名 %&gt;%
  mutate(新しい変数名 = 処理内容)</code></pre>
<p>これは何らかの処理を行い、その結果を新しい変数としてデータフレーム (または、tibble)に追加することを意味します。新しく出来た変数は、基本的に最後の列になります。ここでは分単位である<code>Walk</code>を時間単位に変換した<code>Walk_Hour</code>変数を作成するとします。処理内容は<code>Walk / 60</code>です。最後に、都府県名、店舗名、徒歩距離 (分)、徒歩距離 (時間)のみを残し、遠い順にソートします。</p>
<pre class="r numberLines"><code>df %&gt;%
  filter(!is.na(Walk)) %&gt;%
  mutate(Walk_Hour = Walk / 60) %&gt;%
  select(Pref, Name, Walk, Walk_Hour) %&gt;%
  arrange(desc(Walk_Hour))</code></pre>
<pre><code>## # A tibble: 5,375 x 4
##    Pref     Name                               Walk Walk_Hour
##    &lt;chr&gt;    &lt;chr&gt;                             &lt;dbl&gt;     &lt;dbl&gt;
##  1 埼玉県   札幌ラーメン どさん子 小鹿野店      116     1.93 
##  2 神奈川県 札幌ラーメン どさん子 中津店         73     1.22 
##  3 千葉県   札幌ラーメン どさん子 佐原51号店     59     0.983
##  4 神奈川県 札幌ラーメン どさん子 山際店         50     0.833
##  5 千葉県   札幌ラーメン どさん子 関宿店         49     0.817
##  6 兵庫県   濃厚醤油 中華そば いせや 玉津店      43     0.717
##  7 大阪府   河童ラーメン本舗 岸和田店            38     0.633
##  8 埼玉県   ラーメン山岡家 上尾店                35     0.583
##  9 兵庫県   濃厚醤油 中華そば いせや 大蔵谷店    35     0.583
## 10 大阪府   河童ラーメン本舗 松原店              31     0.517
## # … with 5,365 more rows</code></pre>
<p><code>mutate()</code>は3行目に登場しますが、これは<code>Walk</code>を60に割った結果を<code>Walk_Hour</code>としてデータフレーム (または、tibble)の最後の列として格納することを意味します。もし、最後の列でなく、ある変数の前、または後にしたい場合は、<code>.before</code>または<code>.after</code>引数を追加します。これは<code>select()</code>関数の<code>.before</code>と<code>.after</code>と同じ使い方です。たとえば、新しく出来た<code>Walk_Hour</code>を<code>ID</code>と<code>Name</code>の間に入れたい場合は</p>
<pre class="r numberLines"><code># コードの3行名を修正 (.before使用)
mutate(Walk_Hour = Walk / 60,
       .before   = Name)

# コードの3行名を修正 (.after使用)
mutate(Walk_Hour = Walk / 60,
       .after    = ID)</code></pre>
<p>のようにコードを修正します。</p>
<p>むろん、変数間同士の計算も可能です。たとえば、以下のような<code>df2</code>があり、1店舗当たりの平均口コミ数を計算し、<code>ScoreN_Mean</code>という変数名で<code>ScoreN_Sum</code>の後に格納うするとします。この場合、<code>ScoreN_Sum</code>変数を<code>N</code>で割るだけです。</p>
<pre class="r numberLines"><code>df2 &lt;- df %&gt;%
  group_by(Pref) %&gt;%
  summarise(Budget_Mean = mean(Budget, na.rm = TRUE),
            ScoreN_Sum  = sum(ScoreN, na.rm = TRUE),
            Score_Mean  = mean(Score, na.rm = TRUE),
            N           = n(),
            .groups     = &quot;drop&quot;)</code></pre>
<pre class="r numberLines"><code>df2 %&gt;%
  mutate(ScoreN_Mean = ScoreN_Sum / N,
         .after      = ScoreN_Sum)</code></pre>
<pre><code>## # A tibble: 9 x 6
##   Pref     Budget_Mean ScoreN_Sum ScoreN_Mean Score_Mean     N
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 京都府         1399.        216       0.522       3.68   414
## 2 兵庫県         1197.        230       0.389       3.54   591
## 3 千葉県         1124.        259       0.259       3.72  1000
## 4 和歌山県       1252          83       0.593       3.97   140
## 5 埼玉県         1147.        278       0.278       3.64  1000
## 6 大阪府         1203.        516       0.516       3.77  1000
## 7 奈良県         1169.         45       0.306       3.85   147
## 8 東京都         1283.       1165       1.16        3.67  1000
## 9 神奈川県       1239.        587       0.587       3.53  1000</code></pre>
<p>このように、データ内の変数を用いた計算結果を新しい列として追加する場合は、<code>mutate()</code>が便利です。これを<code>mutate()</code>を使わずに処理する場合、以下のようなコードになりますが、可読性が相対的に低いことが分かります。</p>
<pre class="r numberLines"><code>df2$ScoreN_Mean &lt;- df2$ScoreN_Sum / df2$N
df2 &lt;- df2[, c(&quot;Pref&quot;, &quot;Budget_Mean&quot;, &quot;Walk_Mean&quot;, 
               &quot;ScoreN_Sum&quot;, &quot;ScoreN_Mean&quot;, &quot;Score_Mean&quot;, &quot;N&quot;)]</code></pre>
<p>むろんですが、計算には<code>+</code>や<code>/</code>のような演算子だけでなく、関数を使うことも可能です。たとえば、<code>Budget</code>が1000円未満なら<code>"Cheap"</code>、1000円以上なら<code>"Expensive"</code>と示す変数<code>Budget2</code>を作成する場合は<code>ifelse()</code>関数が使えます。</p>
<pre class="r numberLines"><code>df %&gt;% 
  mutate(Budget2 = ifelse(Budget &lt; 1000, &quot;Cheap&quot;, &quot;Expensive&quot;)) %&gt;%
  filter(!is.na(Budget2)) %&gt;% # Budget2が欠損した店舗を除外
  group_by(Pref, Budget2) %&gt;% # PrefとBudget2でグループ化
  summarise(N = n(),          # 店舗数を表示
            .groups = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 18 x 3
##    Pref     Budget2       N
##    &lt;chr&gt;    &lt;chr&gt;     &lt;int&gt;
##  1 京都府   Cheap        22
##  2 京都府   Expensive    28
##  3 兵庫県   Cheap        39
##  4 兵庫県   Expensive    27
##  5 千葉県   Cheap        64
##  6 千葉県   Expensive    72
##  7 和歌山県 Cheap        10
##  8 和歌山県 Expensive     5
##  9 埼玉県   Cheap        37
## 10 埼玉県   Expensive    45
## 11 大阪府   Cheap       104
## 12 大阪府   Expensive   115
## 13 奈良県   Cheap        11
## 14 奈良県   Expensive    10
## 15 東京都   Cheap       206
## 16 東京都   Expensive   236
## 17 神奈川県 Cheap        66
## 18 神奈川県 Expensive    54</code></pre>
<p>これは各都府県ごとの予算1000円未満の店と以上の店の店舗数をまとめた表となります。もし、500円未満なら<code>"Cheap"</code>、500円以上~1000円未満なら<code>"Reasonable"</code>、1000円以上なら<code>"Expensive"</code>になる<code>Budget3</code>変数を作るにはどうすればよいでしょうか。これは<code>ifelse()</code>を重ねることも出来ますが、ここでは<code>case_when()</code>関数が便利です。まずは、<code>ifelse()</code>を使ったコードは以下の通りです。</p>
<pre class="r numberLines"><code># ifelse()を使う場合
df %&gt;% 
  mutate(Budget3 = ifelse(Budget &lt; 500, &quot;Cheap&quot;, 
                          ifelse(Budget &gt;= 500 &amp; Budget &lt; 1000, &quot;Reasonable&quot;,
                                 &quot;Expensive&quot;))) %&gt;%
  filter(!is.na(Budget3)) %&gt;%
  group_by(Pref, Budget3) %&gt;%
  summarise(N = n(),         
            .groups = &quot;drop&quot;)</code></pre>
<p><code>case_when()</code>を使うと以下のような書き方になります。</p>
<pre class="r numberLines"><code># ifelse()を使う場合
df %&gt;% 
  mutate(Budget3 = case_when(Budget &lt; 500                  ~ &quot;Cheap&quot;,
                             Budget &gt;= 500 &amp; Budget &lt; 1000 ~ &quot;Reasonable&quot;,
                             Budget &gt;= 1000                ~ &quot;Expensive&quot;),
         # 新しく出来た変数をfactor型にその場で変換することも可能
         Budget3 = factor(Budget3, 
                          levels = c(&quot;Cheap&quot;, &quot;Reasonable&quot;, &quot;Expensive&quot;))) %&gt;%
  filter(!is.na(Budget3)) %&gt;%
  group_by(Pref, Budget3) %&gt;%
  summarise(N = n(),         
            .groups = &quot;drop&quot;)</code></pre>
<p>書く手間の観点では<code>case_when()</code>は<code>ifelse()</code>と大きく違いはないかも知れませんが、コードが非常に読みやすくなっています。<code>case_when()</code>関数の書き方は以下の通りです。</p>
<pre class="r numberLines"><code># case_when()の使い方
データフレーム/tibble名 %&gt;%
  mutate(新変数名 = case_when(条件1 ~ 条件1を満たす場合の結果値, 
                             条件2 ~ 条件2を満たす場合の結果値, 
                             条件3 ~ 条件3を満たす場合の結果値, 
                             ...))</code></pre>
<p>似たような機能をする関数として<code>recode()</code>関数があります。これは変数の値を単純に置換したい場合に便利な関数です。たとえば、都府県名をローマ字に変換するケースを考えてみましょう。</p>
<pre class="r numberLines"><code># recode()を使う場合
df2 %&gt;% 
  mutate(Pref2 = recode(Pref,
                        &quot;東京都&quot;   = &quot;Tokyo&quot;,
                        &quot;神奈川県&quot; = &quot;Kanagawa&quot;,
                        &quot;千葉県&quot;   = &quot;Chiba&quot;,
                        &quot;埼玉県&quot;   = &quot;Saitama&quot;,
                        &quot;大阪府&quot;   = &quot;Osaka&quot;,
                        &quot;京都府&quot;   = &quot;Kyoto&quot;,
                        &quot;兵庫県&quot;   = &quot;Hyogo&quot;,
                        &quot;奈良県&quot;   = &quot;Nara&quot;,
                        &quot;和歌山県&quot; = &quot;Wakayama&quot;,
                        .default  = &quot;NA&quot;))</code></pre>
<pre><code>## # A tibble: 9 x 6
##   Pref     Budget_Mean ScoreN_Sum Score_Mean     N Pref2   
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;   
## 1 京都府         1399.        216       3.68   414 Kyoto   
## 2 兵庫県         1197.        230       3.54   591 Hyogo   
## 3 千葉県         1124.        259       3.72  1000 Chiba   
## 4 和歌山県       1252          83       3.97   140 Wakayama
## 5 埼玉県         1147.        278       3.64  1000 Saitama 
## 6 大阪府         1203.        516       3.77  1000 Osaka   
## 7 奈良県         1169.         45       3.85   147 Nara    
## 8 東京都         1283.       1165       3.67  1000 Tokyo   
## 9 神奈川県       1239.        587       3.53  1000 Kanagawa</code></pre>
<p>使い方は非常に直感的です。</p>
<pre class="r numberLines"><code># recode()の使い方
データフレーム/tibble名 %&gt;%
  mutate(新変数名 = recode(元の変数名,
                            元の値1 =  新しい値1, 
                            元の値2 =  新しい値2, 
                            元の値3 =  新しい値3, 
                            ...,
                            .default = 該当しない場合の値))</code></pre>
<p>最後の<code>.default</code>引数は、もし該当する値がない場合に返す値を意味し、長さ1のベクトルを指定します。もし、指定しない場合は<code>NA</code>が表示されます。また、ここには紹介しておりませんでしたが、<code>.missing</code>引数もあり、これは欠損値の場合に返す値を意味します。</p>
<p>もう一つ注意すべきところは、今回はcharacter型変数をcharacter型へ変換したため、「<code>"東京都" = "Tokyo"</code>」のような書き方をしました。しかし、numeric型からcharacter型に変換する場合は数字の部分を<code>`</code>で囲む必要があります。たとえば、「<code>`1` = "Tokyo"</code>」といった形式です。ただし、character型からnumeric型への場合は「<code>"東京都" = 1</code>」で構いません。</p>
<p><code>recode()</code>は値をまとめる際にも便利です。たとえば、<code>EastJapan</code>という変数を作成し、関東なら<code>1</code>を、それ以外なら<code>0</code>を付けるとします。そして、これは<code>Pref</code>変数の後に位置づけます。</p>
<pre class="r numberLines"><code># 都府県を関東か否かでまとめる
df2 %&gt;% 
  mutate(EastJapan = recode(Pref,
                            &quot;東京都&quot;   = 1,
                            &quot;神奈川県&quot; = 1,
                            &quot;千葉県&quot;   = 1,
                            &quot;埼玉県&quot;   = 1,
                            &quot;大阪府&quot;   = 0,
                            &quot;京都府&quot;   = 0,
                            &quot;兵庫県&quot;   = 0,
                            &quot;奈良県&quot;   = 0,
                            &quot;和歌山県&quot; = 0,
                            .default  = 0),
         .after = Pref)</code></pre>
<pre><code>## # A tibble: 9 x 6
##   Pref     EastJapan Budget_Mean ScoreN_Sum Score_Mean     N
##   &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 京都府           0       1399.        216       3.68   414
## 2 兵庫県           0       1197.        230       3.54   591
## 3 千葉県           1       1124.        259       3.72  1000
## 4 和歌山県         0       1252          83       3.97   140
## 5 埼玉県           1       1147.        278       3.64  1000
## 6 大阪府           0       1203.        516       3.77  1000
## 7 奈良県           0       1169.         45       3.85   147
## 8 東京都           1       1283.       1165       3.67  1000
## 9 神奈川県         1       1239.        587       3.53  1000</code></pre>
<p>ただし、関東以外は全て0になるため、以下のように省略することも可能です。</p>
<pre class="r numberLines"><code># .default引数を指定する場合
df3 &lt;- df2 %&gt;% 
  mutate(EastJapan = recode(Pref,
                            &quot;東京都&quot;   = 1,
                            &quot;神奈川県&quot; = 1,
                            &quot;千葉県&quot;   = 1,
                            &quot;埼玉県&quot;   = 1,
                            .default  = 0),
         .after = Pref)

df3</code></pre>
<pre><code>## # A tibble: 9 x 6
##   Pref     EastJapan Budget_Mean ScoreN_Sum Score_Mean     N
##   &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 京都府           0       1399.        216       3.68   414
## 2 兵庫県           0       1197.        230       3.54   591
## 3 千葉県           1       1124.        259       3.72  1000
## 4 和歌山県         0       1252          83       3.97   140
## 5 埼玉県           1       1147.        278       3.64  1000
## 6 大阪府           0       1203.        516       3.77  1000
## 7 奈良県           0       1169.         45       3.85   147
## 8 東京都           1       1283.       1165       3.67  1000
## 9 神奈川県         1       1239.        587       3.53  1000</code></pre>
<p>新しく出来た<code>EastJapan</code>のデータ型はなんでしょうか。</p>
<pre class="r numberLines"><code>class(df3$EastJapan)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p><code>EastJapan</code>はnumeric型ですね。もし、これをfactor型にしたい場合はどうすればよいでしょうか。それは<code>mutate()</code>内で<code>EastJapan</code>を生成した後に<code>factor()</code>関数を使うだけです。</p>
<pre class="r numberLines"><code># EastJapan変数をfactor型にする
df3 &lt;- df2 %&gt;% 
  mutate(EastJapan = recode(Pref,
                            &quot;東京都&quot;   = 1,
                            &quot;神奈川県&quot; = 1,
                            &quot;千葉県&quot;   = 1,
                            &quot;埼玉県&quot;   = 1,
                            .default  = 0),
         EastJapan = factor(EastJapan, levels = c(0, 1)),
         .after = Pref)

df3$EastJapan</code></pre>
<pre><code>## [1] 0 0 1 0 1 0 0 1 1
## Levels: 0 1</code></pre>
<p><code>EastJapan</code>がfactor型になりました。実は、<code>recode</code>は再コーディングと同時にfactor化をしてくれる機能があります。ただし、<code>recode()</code>関数でなく、<code>recode_factor()</code>関数を使います。</p>
<pre class="r numberLines"><code># recode_factor()を使う方法
df3 &lt;- df2 %&gt;% 
  mutate(EastJapan = recode_factor(Pref,
                                   &quot;東京都&quot;   = 1,
                                   &quot;神奈川県&quot; = 1,
                                   &quot;千葉県&quot;   = 1,
                                   &quot;埼玉県&quot;   = 1,
                                   .default  = 0),
         .after = Pref)

df3$EastJapan</code></pre>
<pre><code>## [1] 0 0 1 0 1 0 0 1 1
## Levels: 1 0</code></pre>
<p>ただし、levelの順番は<code>recode_factor()</code>内で定義された順番になることに注意してください。</p>
</div>
</div>
<div id="factor型の処理に便利な関数" class="section level2">
<h2>factor型の処理に便利な関数</h2>
<div id="factor型の必要性" class="section level3">
<h3>factor型の必要性</h3>
<p>話がずれますが、可視化における名目変数の扱いについて考えたいと思います。横軸、または縦軸が気温、成績、身長のような連続変数ではなく、都道府県や国、企業のような名目変数になる場合があります。たとえば、棒グラフの横軸は図<a href="#fig:factor1">3</a>のように、一般的に名目変数になる場合が多いです。</p>
<div class="figure" style="text-align: center"><span id="fig:factor1"></span>
<img src="/dplyr_intro_files/figure-html/factor1-1.png" alt="横軸が名目変数の棒グラフ" width="576" />
<p class="caption">
Figure 3: 横軸が名目変数の棒グラフ
</p>
</div>
<p>ここでは横軸の順番に注目してください。京都府、埼玉県、神奈川県、…の順番になっていますね。「この順番で大満足だよ!」という方がいるかも知れませんが、そうでない方もおおいでしょう。普通考えられるものとしては、都道府県コードの順か、縦軸が高い順 (低い順)でしょう。都道府県コードの順だと、埼玉県、千葉県、東京都、神奈川県、京都府、大阪府、兵庫県、奈良県、和歌山県の順番になります。または、縦軸 (口コミ評価の平均値)が高い順なら和歌山県、奈良県、大阪府、…の順番になります。あるいは50音順も考えられるでしょう。アメリカの場合、州を並べる際、アルファベット順で並べます。</p>
<p>自分でこの順番をコントロールするには可視化の前の段階、つまりデータハンドリングの段階で順番を決めなくてはなりません。これを決めておかない場合、Rが勝手に順番を指定します。具体的にはロケール (locale)というパソコン内の空間に文字情報が含まれているわけですが、そこに保存されている文字の順番となります。たとえば、日本語ロケールには「京」が「埼」よりも先に保存されているわけです。</p>
<p>したがって、名目変数がグラフに含まれる場合は、名目変数の表示順番を決める必要があり、そこで必要なのがfactor型です。名目変数がcharacter型の場合、ロケールに保存されている順でソートされますが、factor型の場合、予め指定した順番でソートされます。</p>
<p>たとえば、<code>df</code>を用いて、都道府県ごとの口コミ評価の平均値を計算し、その結果を<code>Score_df</code>として保存します。</p>
<pre class="r"><code>Score_df &lt;- df %&gt;%
    group_by(Pref) %&gt;%
    summarise(Score   = mean(Score, na.rm = TRUE),
              .groups = &quot;drop&quot;)

Score_df</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     Score
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 京都府    3.68
## 2 兵庫県    3.54
## 3 千葉県    3.72
## 4 和歌山県  3.97
## 5 埼玉県    3.64
## 6 大阪府    3.77
## 7 奈良県    3.85
## 8 東京都    3.67
## 9 神奈川県  3.53</code></pre>
<p>この時点で勝手にロケール順になります。実際、表示された<code>Score_df</code>を見ると<code>Pref</code>の下に`<code>&lt;chr&gt;</code>と表記されており、<code>Pref</code>はcharacter型であることが分かります。これをこのまま棒グラフに出してみましょう。可視化の方法は執筆中のE-Bookで詳細に解説する予定ですので、ここでは結果だけに注目してください。</p>
<pre class="r"><code>Score_df %&gt;%
  ggplot() +
  geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) +
  labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) +
  theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) +
  theme(text = element_text(size = 12))</code></pre>
<div class="figure" style="text-align: center"><span id="fig:factor2"></span>
<img src="/dplyr_intro_files/figure-html/factor2-1.png" alt="Prefがcharacter型の場合 (1)" width="576" />
<p class="caption">
Figure 4: Prefがcharacter型の場合 (1)
</p>
</div>
<p>横軸の順番があまり直感的ではありませんね。それでは、<code>Score_df</code>を<code>Score</code>が高い順にソートし、<code>Score_df2</code>で保存してから、もう一回試してみます。</p>
<pre class="r"><code>Score_df2 &lt;- Score_df %&gt;%
  arrange(desc(Score))

Score_df2</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     Score
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 和歌山県  3.97
## 2 奈良県    3.85
## 3 大阪府    3.77
## 4 千葉県    3.72
## 5 京都府    3.68
## 6 東京都    3.67
## 7 埼玉県    3.64
## 8 兵庫県    3.54
## 9 神奈川県  3.53</code></pre>
<p>ここでも<code>Pref</code>はcharacter型ですが、とりあえず、これで図を出してみます。</p>
<pre class="r"><code>Score_df2 %&gt;%
  ggplot() +
  geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) +
  labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) +
  theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) +
  theme(text = element_text(size = 12))</code></pre>
<div class="figure" style="text-align: center"><span id="fig:factor3"></span>
<img src="/dplyr_intro_files/figure-html/factor3-1.png" alt="Prefがcharacter型の場合 (2)" width="576" />
<p class="caption">
Figure 5: Prefがcharacter型の場合 (2)
</p>
</div>
<p>結果は全く変わっておりません。それでは、<code>Score_df</code>の<code>Pref</code>列をfactor型に変換し、順番は口コミ評価の平均値が高い順番にしてみましょう。結果は<code>Score_df_f1</code>という名で保存します。</p>
<pre class="r"><code>Score_df_f1 &lt;- Score_df %&gt;%
  mutate(Pref = factor(Pref, levels = c(&quot;和歌山県&quot;, &quot;奈良県&quot;, &quot;大阪府&quot;,
                                        &quot;千葉県&quot;, &quot;京都府&quot;, &quot;東京都&quot;,
                                        &quot;埼玉県&quot;, &quot;兵庫県&quot;, &quot;神奈川県&quot;)))

Score_df_f1</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     Score
##   &lt;fct&gt;    &lt;dbl&gt;
## 1 京都府    3.68
## 2 兵庫県    3.54
## 3 千葉県    3.72
## 4 和歌山県  3.97
## 5 埼玉県    3.64
## 6 大阪府    3.77
## 7 奈良県    3.85
## 8 東京都    3.67
## 9 神奈川県  3.53</code></pre>
<p>表示される順番は<code>Score_df</code>と<code>Score_df_f1</code>も同じですが、<code>Pref</code>のデータ型が<code>&lt;fct&gt;</code>、つまりfactor型であることが分かります。実際、<code>Pref</code>列だけ抽出した場合、factor型として、和歌山県から神奈川県の順になっていることが確認できます。</p>
<pre class="r"><code>Score_df_f1$Pref</code></pre>
<pre><code>## [1] 京都府   兵庫県   千葉県   和歌山県 埼玉県   大阪府   奈良県   東京都  
## [9] 神奈川県
## 9 Levels: 和歌山県 奈良県 大阪府 千葉県 京都府 東京都 埼玉県 ... 神奈川県</code></pre>
<p>この<code>Score_df_f1</code>データを使って、図<a href="#fig:factor2">4</a>と全く同じコードを実行した結果が図<a href="#fig:factor4">6</a>です。</p>
<div class="figure" style="text-align: center"><span id="fig:factor4"></span>
<img src="/dplyr_intro_files/figure-html/factor4-1.png" alt="Prefがfactor型の場合 (1)" width="576" />
<p class="caption">
Figure 6: Prefがfactor型の場合 (1)
</p>
</div>
<p>これまでの話をまとめるの以下の2点が分かります。</p>
<ol style="list-style-type: decimal">
<li>変数がcharacter型である場合、自動的にロケール順でソートされる。</li>
<li>変数がfactor型である場合、データ内の順番やロケール順と関係なく、指定されたレベル (水準)の順でソートされる。</li>
</ol>
<p>とくに2番目の点についてですが、これは必ずしも順序付きfactorである必要はありません。順序付きfactor型でなくても、<code>factor()</code>内で指定した順にソートされます。むろん、順序付きfactor型なら指定された順序でソートされます。</p>
<p>これからはfactor型変換の際に便利な関数をいくつか紹介しますが、その前に数値として表現された名目変数について話します。たとえば、<code>Score_df_f1</code>に関東地域なら<code>1</code>を、その他の地域なら<code>0</code>を付けた<code>Kanto</code>という変数があるとします。</p>
<pre class="r"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Kanto = ifelse(Pref %in% c(&quot;東京都&quot;, &quot;神奈川県&quot;, &quot;千葉県&quot;, &quot;埼玉県&quot;), 1, 0))

Score_df_f1</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     Score Kanto
##   &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1 京都府    3.68     0
## 2 兵庫県    3.54     0
## 3 千葉県    3.72     1
## 4 和歌山県  3.97     0
## 5 埼玉県    3.64     1
## 6 大阪府    3.77     0
## 7 奈良県    3.85     0
## 8 東京都    3.67     1
## 9 神奈川県  3.53     1</code></pre>
<p><code>Kanto</code>変数のデータ型は、<code>&lt;dbl&gt;</code>、つまりnumeric型です。しかし、これは明らかに名目変数ですね。これをこのまま<code>Kanto</code>を横軸にした図を出すと図<a href="#fig:factor5">7</a>のようになります。</p>
<div class="figure" style="text-align: center"><span id="fig:factor5"></span>
<img src="/dplyr_intro_files/figure-html/factor5-1.png" alt="Kantoがnumeric型の場合" width="288" />
<p class="caption">
Figure 7: Kantoがnumeric型の場合
</p>
</div>
<p>この場合、図の横軸は<code>Kanto</code>の値が小さい順でソートされます。ただし、このような図は非常に見にくいため、<code>1</code>に<code>"関東"</code>、<code>0</code>に<code>"関西"</code>とラベルを付けたfactor型に変換した方が望ましいです。numeric型をラベル付きのfactor型にするためには、<code>levels</code>引数には元の数値を、<code>labels</code>引数にはそれぞれの数値に対応したラベルを指定します。また、関東の方を先に出したいので、<code>factor()</code>内の<code>levels</code>引数は<code>c(0, 1)</code>でなく、<code>c(1, 0)</code>にします。</p>
<pre class="r"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Kanto = factor(Kanto, levels = c(1, 0), labels = c(&quot;関東&quot;, &quot;その他&quot;)))

Score_df_f1</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     Score Kanto 
##   &lt;fct&gt;    &lt;dbl&gt; &lt;fct&gt; 
## 1 京都府    3.68 その他
## 2 兵庫県    3.54 その他
## 3 千葉県    3.72 関東  
## 4 和歌山県  3.97 その他
## 5 埼玉県    3.64 関東  
## 6 大阪府    3.77 その他
## 7 奈良県    3.85 その他
## 8 東京都    3.67 関東  
## 9 神奈川県  3.53 関東</code></pre>
<p><code>Kanto</code>変数がfactor型に変換されたことが分かります。</p>
<pre class="r"><code>Score_df_f1$Kanto</code></pre>
<pre><code>## [1] その他 その他 関東   その他 関東   その他 その他 関東   関東  
## Levels: 関東 その他</code></pre>
<p>また、<code>"関東"</code>、<code>"その他"</code>の順になっていますね。これを図として出力した結果が図<a href="#fig:factor6">8</a>です。</p>
<div class="figure" style="text-align: center"><span id="fig:factor6"></span>
<img src="/dplyr_intro_files/figure-html/factor6-1.png" alt="Kantoがfactor型の場合" width="288" />
<p class="caption">
Figure 8: Kantoがfactor型の場合
</p>
</div>
<p>このように数値型名目変数でも、factor化することによって、自由に横軸の順番を変えることができます。それでは、factor化に使える便利な関数をいくつか紹介します。</p>
</div>
<div id="forcatsパッケージについて" class="section level3">
<h3><code>forcats</code>パッケージについて</h3>
<p>実はfactor型への変換や、順番に変更などは全てR内蔵の<code>factor()</code>関数で対応可能ですが、ここでは<code>forcats</code>パッケージが提供している<code>fct_*()</code>関数を使用します。<code>forcats</code>パッケージは<code>tidyverse</code>を読み込む際、自動的に読み込まれるため、既に<code>tidyverse</code>を読み込んでいる場合、別途のコードは要りません。</p>
<p>実はfactor型への変換や、順番に変更などは全てR内蔵の<code>factor()</code>関数で対応可能ですが、ここでは<code>forcats</code>パッケージが提供している<code>fct_*()</code>関数を使用します。<code>forcats</code>パッケージは<code>tidyverse</code>を読み込む際、自動的に読み込まれるため、既に<code>tidyverse</code>を読み込んでいる場合、別途のコードは要りません。</p>
<p><strong><code>fct_relevel()</code>: 水準の順番を変更する</strong></p>
<p><code>Score_df_f1</code>の<code>f1</code>は<code>Score</code>が高い順になっています。これを50音順に変更する際、<code>fct_relevel()</code>関数を使います。</p>
<pre class="r"><code># 新しい変数名と元となる変数名が一致すると上書きになる
データフレーム名 %&gt;%
  mutate(新しい変数名 = fct_releve(元となる変数名, 
                                    &quot;水準1&quot;, &quot;水準2&quot;, &quot;水準3&quot;, ...))</code></pre>
<p>ここでは、<code>Pref</code>変数を再調整した<code>Pref2</code>変数を作ってみましょう。</p>
<pre class="r numberLines"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Pref2 = fct_relevel(Pref, &quot;大阪府&quot;, &quot;神奈川県&quot;, &quot;京都府&quot;, 
                             &quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, 
                             &quot;奈良県&quot;, &quot;兵庫県&quot;, &quot;和歌山県&quot;))

Score_df_f1</code></pre>
<pre><code>## # A tibble: 9 x 4
##   Pref     Score Kanto  Pref2   
##   &lt;fct&gt;    &lt;dbl&gt; &lt;fct&gt;  &lt;fct&gt;   
## 1 京都府    3.68 その他 京都府  
## 2 兵庫県    3.54 その他 兵庫県  
## 3 千葉県    3.72 関東   千葉県  
## 4 和歌山県  3.97 その他 和歌山県
## 5 埼玉県    3.64 関東   埼玉県  
## 6 大阪府    3.77 その他 大阪府  
## 7 奈良県    3.85 その他 奈良県  
## 8 東京都    3.67 関東   東京都  
## 9 神奈川県  3.53 関東   神奈川県</code></pre>
<p>一見、<code>Pref</code>と<code>Pref2</code>変数は同じように見えますが、水準はどうなっているでしょうか。</p>
<pre class="r numberLines"><code>levels(Score_df_f1$Pref)  # Prefの水準</code></pre>
<pre><code>## [1] &quot;和歌山県&quot; &quot;奈良県&quot;   &quot;大阪府&quot;   &quot;千葉県&quot;   &quot;京都府&quot;   &quot;東京都&quot;   &quot;埼玉県&quot;  
## [8] &quot;兵庫県&quot;   &quot;神奈川県&quot;</code></pre>
<pre class="r numberLines"><code>levels(Score_df_f1$Pref2) # Pref2の水準</code></pre>
<pre><code>## [1] &quot;大阪府&quot;   &quot;神奈川県&quot; &quot;京都府&quot;   &quot;埼玉県&quot;   &quot;千葉県&quot;   &quot;東京都&quot;   &quot;奈良県&quot;  
## [8] &quot;兵庫県&quot;   &quot;和歌山県&quot;</code></pre>
<p>問題なく50音順になっていることが分かります。他にも<code>fct_relevel()</code>には全ての水準名を指定する必要がありません。一部の水準名も可能です。たとえば、「関東が関西の先に来るなんでけしからん！」と思う読者もいるでしょう。この場合、関西の府県名を入れると、指定した水準が最初に位置するようになります。</p>
<pre class="r numberLines"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Pref3 = fct_relevel(Pref, &quot;京都府&quot;, &quot;大阪府&quot;,
                             &quot;兵庫県&quot;, &quot;奈良県&quot;, &quot;和歌山県&quot;))

levels(Score_df_f1$Pref3) # Pref3の水準</code></pre>
<pre><code>## [1] &quot;京都府&quot;   &quot;大阪府&quot;   &quot;兵庫県&quot;   &quot;奈良県&quot;   &quot;和歌山県&quot; &quot;千葉県&quot;   &quot;東京都&quot;  
## [8] &quot;埼玉県&quot;   &quot;神奈川県&quot;</code></pre>
<p>一部の水準名のみを指定するとその水準が最初に移動されますが、<code>after</code>引数を指定すると、位置を調整することも可能です。<code>after = 2</code>の場合、元となる変数の1、3番目の水準は維持され、3番目以降に指定した水準、それに続いて指定されていない水準の順番になります。<code>Pref</code>は和歌山、奈良、大阪の順ですが、ここで京都と東京を、奈良と大阪の間に移動するなら、</p>
<pre class="r numberLines"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Pref4 = fct_relevel(Pref, &quot;京都府&quot;, &quot;東京都&quot;, after = 2))

levels(Score_df_f1$Pref4) # Pref4の水準</code></pre>
<pre><code>## [1] &quot;和歌山県&quot; &quot;奈良県&quot;   &quot;京都府&quot;   &quot;東京都&quot;   &quot;大阪府&quot;   &quot;千葉県&quot;   &quot;埼玉県&quot;  
## [8] &quot;兵庫県&quot;   &quot;神奈川県&quot;</code></pre>
<p>のように書きます。<code>after</code>を指定しない場合のデフォルト値は0であるため、最初に移動します。</p>
<p><strong><code>fct_recode()</code>: 水準のラベルを変更する</strong></p>
<p><code>fct_recode()</code>は水準のラベルを変更する時に使う関数で、以下のように使います。</p>
<pre class="r"><code># 新しい変数名と元となる変数名が一致すると上書きになる
データフレーム名 %&gt;%
  mutate(新しい変数名 = fct_recode(元となる変数名, 
                                   新しいラベル1 = &quot;既存のラベル1&quot;,
                                   新しいラベル2 = &quot;既存のラベル2&quot;,
                                   新しいラベル3 = &quot;既存のラベル3&quot;,
                                   ...))</code></pre>
<p>注意点としては新しいラベルは<code>"</code>で囲まず、既存のラベルは<code>"</code>で囲む点です。それでは、<code>Pref</code>のラベルをローマ字に変更してみましょう。</p>
<pre class="r numberLines"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Pref5 = fct_recode(Pref,
                            Saitama  = &quot;埼玉県&quot;,
                            Wakayama = &quot;和歌山県&quot;,
                            Kyoto    = &quot;京都府&quot;,
                            Osaka    = &quot;大阪府&quot;,
                            Tokyo    = &quot;東京都&quot;,
                            Nara     = &quot;奈良県&quot;,
                            Kanagawa = &quot;神奈川県&quot;,
                            Hyogo    = &quot;兵庫県&quot;,
                            Chiba    = &quot;千葉県&quot;))

Score_df_f1</code></pre>
<pre><code>## # A tibble: 9 x 7
##   Pref     Score Kanto  Pref2    Pref3    Pref4    Pref5   
##   &lt;fct&gt;    &lt;dbl&gt; &lt;fct&gt;  &lt;fct&gt;    &lt;fct&gt;    &lt;fct&gt;    &lt;fct&gt;   
## 1 京都府    3.68 その他 京都府   京都府   京都府   Kyoto   
## 2 兵庫県    3.54 その他 兵庫県   兵庫県   兵庫県   Hyogo   
## 3 千葉県    3.72 関東   千葉県   千葉県   千葉県   Chiba   
## 4 和歌山県  3.97 その他 和歌山県 和歌山県 和歌山県 Wakayama
## 5 埼玉県    3.64 関東   埼玉県   埼玉県   埼玉県   Saitama 
## 6 大阪府    3.77 その他 大阪府   大阪府   大阪府   Osaka   
## 7 奈良県    3.85 その他 奈良県   奈良県   奈良県   Nara    
## 8 東京都    3.67 関東   東京都   東京都   東京都   Tokyo   
## 9 神奈川県  3.53 関東   神奈川県 神奈川県 神奈川県 Kanagawa</code></pre>
<p><code>fct_recode()</code>の中に指定する水準の順番は無視されます。つまり、水準の順番はそのまま維持されるため、好きな順番で結構です。また、全ての水準を指定せず、一部のみ変更することも可能です。それでは<code>Pref5</code>の順番が<code>Pref</code>の順番と同じかを確認してみましょう。</p>
<pre class="r numberLines"><code>levels(Score_df_f1$Pref)  # Prefの水準</code></pre>
<pre><code>## [1] &quot;和歌山県&quot; &quot;奈良県&quot;   &quot;大阪府&quot;   &quot;千葉県&quot;   &quot;京都府&quot;   &quot;東京都&quot;   &quot;埼玉県&quot;  
## [8] &quot;兵庫県&quot;   &quot;神奈川県&quot;</code></pre>
<pre class="r numberLines"><code>levels(Score_df_f1$Pref5) # Pref5の水準</code></pre>
<pre><code>## [1] &quot;Wakayama&quot; &quot;Nara&quot;     &quot;Osaka&quot;    &quot;Chiba&quot;    &quot;Kyoto&quot;    &quot;Tokyo&quot;    &quot;Saitama&quot; 
## [8] &quot;Hyogo&quot;    &quot;Kanagawa&quot;</code></pre>
<p><strong><code>fct_rev()</code>: 水準の順番を反転する</strong></p>
<p>水準の順番を反転することは非常によくあります。たとえば、グラフの読みやすさのために、左右または上下を反転するケースがあります。既に何回も強調しましたように、名目変数は基本的にfactor型にすべきであり、ここで<code>fct_rev()</code>関数が非常に便利です。たとえば、<code>Pref2</code>の水準は50音順でありますが、これを反転し、<code>Pref6</code>という名の列として追加してみましょう。</p>
<pre class="r numberLines"><code>Score_df_f1 &lt;- Score_df_f1 %&gt;%
  mutate(Pref6 = fct_rev(Pref2))

levels(Score_df_f1$Pref6)</code></pre>
<pre><code>## [1] &quot;和歌山県&quot; &quot;兵庫県&quot;   &quot;奈良県&quot;   &quot;東京都&quot;   &quot;千葉県&quot;   &quot;埼玉県&quot;   &quot;京都府&quot;  
## [8] &quot;神奈川県&quot; &quot;大阪府&quot;</code></pre>
<p>関数一つで水準の順番が反転されました。</p>
<p><strong><code>fct_infreq()</code>: 頻度順に順番を変更する</strong></p>
<p>続いて、水準の順番を頻度順に合わせる<code>fct_infreq()</code>関数です。たとえば、<code>Score</code>が欠損でないケースのみで構成された<code>df2</code>を考えてみましょう。</p>
<pre class="r numberLines"><code>df2 &lt;- df %&gt;%
  filter(!is.na(Score))</code></pre>
<p>そして、都府県ごとのケース数を計算します。</p>
<pre class="r numberLines"><code>table(df2$Pref)</code></pre>
<pre><code>## 
##   京都府   兵庫県   千葉県 和歌山県   埼玉県   大阪府   奈良県   東京都 
##       79       85      108       24      118      175       28      298 
## 神奈川県 
##      219</code></pre>
<p>ここで<code>Pref</code>をfactor化しますが、水準の順番を店舗数が多い方を先にするにはどうすれば良いでしょうか。<code>fct_infreq()</code>関数は指定された変数の各値の個数を計算し、多い順にfactorの水準を調整します。</p>
<pre class="r numberLines"><code>df2 &lt;- df2 %&gt;%
  # 多く出現した値順でfactor化する
  mutate(Pref = fct_infreq(Pref))

levels(df2$Pref) # df2のPref変数の水準を出力</code></pre>
<pre><code>## [1] &quot;東京都&quot;   &quot;神奈川県&quot; &quot;大阪府&quot;   &quot;埼玉県&quot;   &quot;千葉県&quot;   &quot;兵庫県&quot;   &quot;京都府&quot;  
## [8] &quot;奈良県&quot;   &quot;和歌山県&quot;</code></pre>
<p><code>"東京都"</code>、<code>"神奈川県"</code>、<code>"大阪府"</code>、…の順で水準の順番が調整され、これは<code>table(df$Pref2)</code>の順位とも一致します。</p>
<p><strong><code>fct_inorder()</code>: データ内の出現順番に順番を変更する</strong></p>
<p>続いて、<code>fct_inorder()</code>ですが、これは意外と頻繁に使われる関数です。たとえば、自分でデータフレームなどを作成し、ケースの順番も綺麗に整えたとします。しかし、既に指摘した通り、データフレーム (または、tibble)での順番とグラフにおける順番は一致するとは限りません。データフレームに格納された順番でfactorの水準が設定できれば非常に便利でしょう。そこで使うのが<code>fct_inorder()</code>です。</p>
<p>たとえば、<code>df</code>の<code>Pref</code>は<code>"東京都"</code>が1000個並び、続いて<code>"神奈川県"</code>が1000個、<code>"千葉県"</code>が1000個、…の順番で格納されています。この順番をそのままfactorの順番にするには以下のように書きます。</p>
<pre class="r numberLines"><code>df3 &lt;- df %&gt;%
  # Pref変数をfactor化し、水準は出現順とする
  # 変換後の結果はPrefに上書きする
  mutate(Pref = fct_inorder(Pref))

levels(df3$Pref)</code></pre>
<pre><code>## [1] &quot;東京都&quot;   &quot;神奈川県&quot; &quot;千葉県&quot;   &quot;埼玉県&quot;   &quot;大阪府&quot;   &quot;京都府&quot;   &quot;兵庫県&quot;  
## [8] &quot;奈良県&quot;   &quot;和歌山県&quot;</code></pre>
<p><strong><code>fct_shift()</code>: 水準の順番をずらす</strong></p>
<p>続いて、水準の順番をずらす<code>fct_shift()</code>関数を紹介します。たとえば、「1:そう思う」〜「5:そう思わない」、「9:答えたくない」の6水準で構成された変数があるとします。</p>
<pre class="r numberLines"><code>df4 &lt;- tibble(
  ID = 1:10,
  Q1 = c(1, 5, 3, 2, 9, 2, 4, 9, 5, 1)
) 

df4 &lt;- df4 %&gt;%
  mutate(Q1 = factor(Q1, levels = c(1:5, 9),
                     labels = c(&quot;そう思う&quot;, 
                                &quot;どちらかと言えばそう思う&quot;,
                                &quot;どちらとも言えない&quot;,
                                &quot;どちらかと言えばそう思わない&quot;,
                                &quot;そう思わない&quot;,
                                &quot;答えたくない&quot;)))

df4</code></pre>
<pre><code>## # A tibble: 10 x 2
##       ID Q1                          
##    &lt;int&gt; &lt;fct&gt;                       
##  1     1 そう思う                    
##  2     2 そう思わない                
##  3     3 どちらとも言えない          
##  4     4 どちらかと言えばそう思う    
##  5     5 答えたくない                
##  6     6 どちらかと言えばそう思う    
##  7     7 どちらかと言えばそう思わない
##  8     8 答えたくない                
##  9     9 そう思わない                
## 10    10 そう思う</code></pre>
<p>水準の順番も「そう思う」〜「答えたくない」順で綺麗に整っています。この水準を反転するには<code>fct_rev()</code>関数が便利です。<code>Q1</code>の水準を反転した変数を<code>Q1_R</code>という新しい列として追加し、水準を確認してみましょう。</p>
<pre class="r numberLines"><code>df4 &lt;- df4 %&gt;%
  mutate(Q1_R = fct_rev(Q1))

df4</code></pre>
<pre><code>## # A tibble: 10 x 3
##       ID Q1                           Q1_R                        
##    &lt;int&gt; &lt;fct&gt;                        &lt;fct&gt;                       
##  1     1 そう思う                     そう思う                    
##  2     2 そう思わない                 そう思わない                
##  3     3 どちらとも言えない           どちらとも言えない          
##  4     4 どちらかと言えばそう思う     どちらかと言えばそう思う    
##  5     5 答えたくない                 答えたくない                
##  6     6 どちらかと言えばそう思う     どちらかと言えばそう思う    
##  7     7 どちらかと言えばそう思わない どちらかと言えばそう思わない
##  8     8 答えたくない                 答えたくない                
##  9     9 そう思わない                 そう思わない                
## 10    10 そう思う                     そう思う</code></pre>
<pre class="r numberLines"><code>levels(df4$Q1_R)</code></pre>
<pre><code>## [1] &quot;答えたくない&quot;                 &quot;そう思わない&quot;                
## [3] &quot;どちらかと言えばそう思わない&quot; &quot;どちらとも言えない&quot;          
## [5] &quot;どちらかと言えばそう思う&quot;     &quot;そう思う&quot;</code></pre>
<p>「答えたくない」が最初の順番に来ましてね。できれば、「そう思わない」〜「そう思う」、「答えたくない」の順番にしたいところです。ここで使うのが<code>fct_shift()</code>ですが、書き方がややこしいので、噛み砕いて解説します。</p>
<pre class="r"><code># fct_shift()の使い方
データ名 %&gt;%
  mutate(新しい変数名 = fct_shift(元の変数名, n = 左方向へずらす個数))</code></pre>
<p>問題は<code>n =</code>引数ですが、その挙動については以下の表を参照してください。</p>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
水準の順番
</th>
<th style="text-align:center;">
1番目
</th>
<th style="text-align:center;">
2番目
</th>
<th style="text-align:center;">
3番目
</th>
<th style="text-align:center;">
4番目
</th>
<th style="text-align:center;">
5番目
</th>
<th style="text-align:center;">
6番目
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<code>n = -2</code>
</td>
<td style="text-align:center;">
<code>E</code>
</td>
<td style="text-align:center;">
<code>F</code>
</td>
<td style="text-align:center;">
<code>A</code>
</td>
<td style="text-align:center;">
<code>B</code>
</td>
<td style="text-align:center;">
<code>C</code>
</td>
<td style="text-align:center;">
<code>D</code>
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>n = -1</code>
</td>
<td style="text-align:center;">
<code>F</code>
</td>
<td style="text-align:center;">
<code>A</code>
</td>
<td style="text-align:center;">
<code>B</code>
</td>
<td style="text-align:center;">
<code>C</code>
</td>
<td style="text-align:center;">
<code>D</code>
</td>
<td style="text-align:center;">
<code>E</code>
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>n = 0</code>
</td>
<td style="text-align:center;">
<code>A</code>
</td>
<td style="text-align:center;">
<code>B</code>
</td>
<td style="text-align:center;">
<code>C</code>
</td>
<td style="text-align:center;">
<code>D</code>
</td>
<td style="text-align:center;">
<code>E</code>
</td>
<td style="text-align:center;">
<code>F</code>
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>n = 1</code>
</td>
<td style="text-align:center;">
<code>B</code>
</td>
<td style="text-align:center;">
<code>C</code>
</td>
<td style="text-align:center;">
<code>D</code>
</td>
<td style="text-align:center;">
<code>E</code>
</td>
<td style="text-align:center;">
<code>F</code>
</td>
<td style="text-align:center;">
<code>A</code>
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>n = 2</code>
</td>
<td style="text-align:center;">
<code>C</code>
</td>
<td style="text-align:center;">
<code>D</code>
</td>
<td style="text-align:center;">
<code>E</code>
</td>
<td style="text-align:center;">
<code>F</code>
</td>
<td style="text-align:center;">
<code>A</code>
</td>
<td style="text-align:center;">
<code>B</code>
</td>
</tr>
</tbody>
</table>
<p>具体的には水準は左方向へ<code>n</code>個移動します。元の水準が<code>A</code>, <code>B</code>, <code>C</code>, …, <code>F</code>の順で、<code>n = 1</code>の場合、<code>A</code>が<code>F</code>の後ろへ移動し、<code>B</code>, <code>C</code>, <code>D</code>, <code>E</code>, <code>F</code>が前の方へ1つずつ移動します。逆に右側へ1つ移動したい場合は<code>n = -1</code>のように書きます。今回は最初の水準を最後に移動させたいので、<code>n = 1</code>と指定します。</p>
<pre class="r numberLines"><code>df4 &lt;- df4 %&gt;%
  # Q1_Rの水準を左方向で1ずらす
  mutate(Q1_R = fct_shift(Q1_R, n = 1))

levels(df4$Q1_R)</code></pre>
<pre><code>## [1] &quot;そう思わない&quot;                 &quot;どちらかと言えばそう思わない&quot;
## [3] &quot;どちらとも言えない&quot;           &quot;どちらかと言えばそう思う&quot;    
## [5] &quot;そう思う&quot;                     &quot;答えたくない&quot;</code></pre>
<p>これで水準の反転が完了しました。<code>fct_shift()</code>はこのように世論調査データの処理に便利ですが、他にも曜日の処理に使えます。例えば、1週間の始まりを月曜にするか日曜にするかによって、<code>fct_shift()</code>を使うケースがあります。</p>
<p><strong><code>fct_shuffle()</code>: 水準の順番をランダム化する</strong></p>
<p>あまり使わない機能ですが、水準の順番をランダム化することも可能です。使い方は非常に簡単で、<code>fct_shuffle()</code>に元の変数名を入れるだけです。たとえば、<code>Score_df</code>の<code>Pref</code>の順番をランダム化し、<code>Pref2</code>として追加します。同じことをもう2回繰り返し、それぞれ<code>Pref3</code>と<code>Pref4</code>という名前で追加してみましょう。</p>
<pre class="r numberLines"><code>Score_df &lt;- Score_df %&gt;%
  mutate(Pref2 = fct_shuffle(Pref),
         Pref3 = fct_shuffle(Pref),
         Pref4 = fct_shuffle(Pref))

Score_df</code></pre>
<pre><code>## # A tibble: 9 x 5
##   Pref     Score Pref2    Pref3    Pref4   
##   &lt;chr&gt;    &lt;dbl&gt; &lt;fct&gt;    &lt;fct&gt;    &lt;fct&gt;   
## 1 京都府    3.68 京都府   京都府   京都府  
## 2 兵庫県    3.54 兵庫県   兵庫県   兵庫県  
## 3 千葉県    3.72 千葉県   千葉県   千葉県  
## 4 和歌山県  3.97 和歌山県 和歌山県 和歌山県
## 5 埼玉県    3.64 埼玉県   埼玉県   埼玉県  
## 6 大阪府    3.77 大阪府   大阪府   大阪府  
## 7 奈良県    3.85 奈良県   奈良県   奈良県  
## 8 東京都    3.67 東京都   東京都   東京都  
## 9 神奈川県  3.53 神奈川県 神奈川県 神奈川県</code></pre>
<pre class="r numberLines"><code>levels(Score_df$Pref2)</code></pre>
<pre><code>## [1] &quot;奈良県&quot;   &quot;神奈川県&quot; &quot;大阪府&quot;   &quot;兵庫県&quot;   &quot;京都府&quot;   &quot;和歌山県&quot; &quot;千葉県&quot;  
## [8] &quot;埼玉県&quot;   &quot;東京都&quot;</code></pre>
<pre class="r numberLines"><code>levels(Score_df$Pref3)</code></pre>
<pre><code>## [1] &quot;京都府&quot;   &quot;大阪府&quot;   &quot;和歌山県&quot; &quot;神奈川県&quot; &quot;奈良県&quot;   &quot;東京都&quot;   &quot;兵庫県&quot;  
## [8] &quot;埼玉県&quot;   &quot;千葉県&quot;</code></pre>
<pre class="r numberLines"><code>levels(Score_df$Pref4)</code></pre>
<pre><code>## [1] &quot;兵庫県&quot;   &quot;東京都&quot;   &quot;京都府&quot;   &quot;神奈川県&quot; &quot;千葉県&quot;   &quot;和歌山県&quot; &quot;奈良県&quot;  
## [8] &quot;大阪府&quot;   &quot;埼玉県&quot;</code></pre>
<p><code>Pref</code>から<code>Pref4</code>まで同じように見えますが、水準の順番が異なります (<code>Pref</code>はcharacter型だから水準がありません)。</p>
<p><strong><code>fct_reorder()</code>: 別の1変数の値を基準に水準の順番を変更する</strong></p>
<p><code>fct_infreq()</code>は出現頻度順に並び替える関数でしたが、それと似たような関数として<code>fct_reorder()</code>があります。ただし、これは出現頻度を基準にするのではなく、ある変数の平均値が低い順、中央値が高い順などでソートされます。まずは使い方から確認します。</p>
<pre class="r"><code>データ名 %&gt;%
  mutate(新しい変数名 = fct_reorder(元の変数名, 基準となる変数, 
                                   関数名, 関数の引数))</code></pre>
<p>必要な引数が多いですね。解説よりも実際の例を見ながら説明します。今回も<code>Pref</code>をfactor変数にし、<code>Pref_R</code>という列で格納しますが、平均予算が安い順でfactorの水準を決めたいと思います。</p>
<pre class="r numberLines"><code>df &lt;- df %&gt;%
  mutate(Pref_R = fct_reorder(Pref, Budget, mean, na.rm = TRUE))

levels(df$Pref_R)</code></pre>
<pre><code>## [1] &quot;千葉県&quot;   &quot;埼玉県&quot;   &quot;奈良県&quot;   &quot;兵庫県&quot;   &quot;大阪府&quot;   &quot;神奈川県&quot; &quot;和歌山県&quot;
## [8] &quot;東京都&quot;   &quot;京都府&quot;</code></pre>
<p><code>Pref_R</code>の水準は千葉県、埼玉県、奈良県、…の順ですが、本当にそうでしょうか。<code>group_by()</code>と<code>summarise()</code>などを使って確認してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;% 
  group_by(Pref) %&gt;%
  summarise(Budget  = mean(Budget, na.rm = TRUE),
            .groups = &quot;drop&quot;) %&gt;%
  arrange(Budget)</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     Budget
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 千葉県    1124.
## 2 埼玉県    1147.
## 3 奈良県    1169.
## 4 兵庫県    1197.
## 5 大阪府    1203.
## 6 神奈川県  1239.
## 7 和歌山県  1252 
## 8 東京都    1283.
## 9 京都府    1399.</code></pre>
<p>問題なくソートされましたね。注意点としては<code>fct_reorder()</code>内に関数名を書く際、<code>()</code>は不要という点です。関数名の次の引数としてはその関数に別途必要な引数を指定します。引数が省略可能、あるいは不要な関数を使う場合は、省略しても構いませんし、数に制限はありません。</p>
<p>また、低い順ではなく、高い順にすることも可能です。次は<code>Score</code>の中央値が高い順に水準を設定した<code>Pref_R2</code>を作ってみましょう。</p>
<pre class="r numberLines"><code>df &lt;- df %&gt;%
  mutate(Pref_R2 = fct_reorder(Pref, Score, median, na.rm = TRUE, .desc = TRUE))

levels(df$Pref_R2)</code></pre>
<pre><code>## [1] &quot;和歌山県&quot; &quot;奈良県&quot;   &quot;千葉県&quot;   &quot;大阪府&quot;   &quot;東京都&quot;   &quot;埼玉県&quot;   &quot;京都府&quot;  
## [8] &quot;兵庫県&quot;   &quot;神奈川県&quot;</code></pre>
<p>変わったのは<code>mean</code>の代わりに<code>median</code>を使ったこと、そして<code>.desc</code>引数が追加された点です。<code>fct_reorder()</code>には<code>.desc = FALSE</code>がデフォルトとして指定されており、省略した場合は昇順でfactorの水準が決まります。ここで<code>.desc = TRUE</code>を指定すると、降順となります。実際、<code>Score</code>の中央値順になっているかを確認してみましょう。</p>
<pre class="r numberLines"><code>df %&gt;% 
  group_by(Pref) %&gt;%
  summarise(Score   = median(Score, na.rm = TRUE),
            .groups = &quot;drop&quot;) %&gt;%
  arrange(desc(Score))</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     Score
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 和歌山県  4   
## 2 奈良県    3.88
## 3 千葉県    3.75
## 4 大阪府    3.75
## 5 東京都    3.64
## 6 埼玉県    3.61
## 7 京都府    3.5 
## 8 兵庫県    3.5 
## 9 神奈川県  3.5</code></pre>
<p><strong><code>fct_reorder2()</code>: 別の2変数の値を基準に水準の順番を変更する</strong></p>
<p>この関数は別の変数を基準に水準が調整される点では<code>fct_reorder()</code>と類似しています。ただし、よく誤解されるのは「変数Aの値が同じなら変数Bを基準に…」といったものではありません。たとえば、<code>fct_reorder(x, y, mean)</code>の場合、<code>y</code>の平均値 (<code>mean()</code>)の順で<code>x</code>の水準を調整するという意味です。この<code>mean()</code>関数に必要なデータはベクトル1つです。しかし、関数によっては2つの変数が必要な場合があります。</p>
<p>これは頻繁に直面する問題ではありませんが、この<code>fct_reorder2()</code>関数が活躍するケースを紹介します。以下は6月27日から7月1日までの5日間、5地域におけるCOVID-19新規感染者数を表したデータです<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>。入力が面倒な方は<a href="../Data/COVID19.csv">ここ</a>からダウンロードして読み込んでください。</p>
<pre class="r"><code># 入力が面倒ならデータをダウンロードし、
# Reorder2_df &lt;- read_csv(&quot;Data/COVID19.csv&quot;)
Reorder2_df &lt;- tibble(
  Country = rep(c(&quot;日本&quot;, &quot;韓国&quot;, &quot;中国 (本土)&quot;, &quot;台湾&quot;, &quot;香港&quot;),
                each = 5),
  Date    = rep(c(&quot;2020/06/27&quot;, &quot;2020/06/28&quot;, &quot;2020/06/29&quot;,
                  &quot;2020/06/30&quot;, &quot;2020/07/01&quot;), 5),
  NewPat  = c(100, 93, 86, 117, 130, 
               62, 42, 43,  50,  54,
               17, 12, 19,   3,   5,
                0,  0,  0,   0,   0,
                1,  2,  4,   2,  28)
)

Reorder2_df &lt;- Reorder2_df %&gt;%
  mutate(Date = as.Date(Date))

Reorder2_df</code></pre>
<pre><code>## # A tibble: 25 x 3
##    Country Date       NewPat
##    &lt;chr&gt;   &lt;date&gt;      &lt;dbl&gt;
##  1 日本    2020-06-27    100
##  2 日本    2020-06-28     93
##  3 日本    2020-06-29     86
##  4 日本    2020-06-30    117
##  5 日本    2020-07-01    130
##  6 韓国    2020-06-27     62
##  7 韓国    2020-06-28     42
##  8 韓国    2020-06-29     43
##  9 韓国    2020-06-30     50
## 10 韓国    2020-07-01     54
## # … with 15 more rows</code></pre>
<p>可視化のコードはとりあえず無視し、グラフを出力してみましょう。</p>
<pre class="r"><code>Reorder2_df %&gt;%
  ggplot() +
  geom_line(aes(x = Date, y = NewPat, color = Country),
            size = 1) +
  scale_x_date(date_labels = &quot;%Y年%m月%d日&quot;) +
  labs(x = &quot;年月日&quot;, y = &quot;新規感染者数 (人)&quot;, color = &quot;&quot;) +
  theme_gray(base_family = &quot;HiraKakuProN-W3&quot;)</code></pre>
<p><img src="/dplyr_intro_files/figure-html/unnamed-chunk-148-1.png" width="672" /></p>
<p>このグラフに違和感はあまりありませんが、「読みやすさ」の麺では改善の余地があります。たとえば、7月1日の時点で、新規感染者数が多いのは日本、韓国、香港、中国 (本土)、台湾の順です。しかし、右側の凡例の順番はそうではありません。この順番が一致すれば、更に図は読みやすくなるでしょう。</p>
<pre class="r"><code>factor(Reorder2_df$Country)</code></pre>
<pre><code>##  [1] 日本        日本        日本        日本        日本        韓国       
##  [7] 韓国        韓国        韓国        韓国        中国 (本土) 中国 (本土)
## [13] 中国 (本土) 中国 (本土) 中国 (本土) 台湾        台湾        台湾       
## [19] 台湾        台湾        香港        香港        香港        香港       
## [25] 香港       
## Levels: 中国 (本土) 台湾 日本 韓国 香港</code></pre>
<p>実際、何も指定せずに<code>Reorder2_df</code>の<code>Country</code>をfactor化すると、韓国、香港、台湾、…の順であり、これは上のグラフと一致します。これをグラフにおける7月1日の新規感染者数の順で並べるためには、<code>Date</code>を昇順にソートし、そして最後の要素 (<code>"2020/07/01"</code>)内で新規感染者数 (<code>NewPat</code>)を降順に並べ替えた場合の順番にする必要があります。実際、<code>Reorder2_df</code>を<code>Date</code>で昇順、<code>NewPat</code>で降順にソートし、最後の5行を抽出した結果が以下のコードです。</p>
<pre class="r"><code>Reorder2_df %&gt;%
  arrange(Date, desc(NewPat)) %&gt;%
  slice_tail(n = 5)</code></pre>
<pre><code>## # A tibble: 5 x 3
##   Country     Date       NewPat
##   &lt;chr&gt;       &lt;date&gt;      &lt;dbl&gt;
## 1 日本        2020-07-01    130
## 2 韓国        2020-07-01     54
## 3 香港        2020-07-01     28
## 4 中国 (本土) 2020-07-01      5
## 5 台湾        2020-07-01      0</code></pre>
<p>このように、水準を調整する際に2つの変数 (<code>Date</code>と<code>NewPat</code>)が使用されます。<code>fct_reorder2()</code>は<code>fct_reorder()</code>と買い方がほぼ同じですが、基準となる変数がもう一つ加わります。</p>
<pre class="r"><code>データ名 %&gt;%
  mutate(新しい変数名 = fct_reorder2(元の変数名, 
                                    基準となる変数1, 基準となる変数2,
                                    関数名, 関数の引数))</code></pre>
<p>重要なのはここの関数のところですが、<code>fct_reorder2()</code>はデフォルトで<code>last2()</code>という関数が指定されており、まさに私たちに必要な関数です。したがって、ここでは関数名も省略できますが、ここでは一応明記しておきます。</p>
<pre class="r"><code>Reorder2_df &lt;- Reorder2_df %&gt;%
  mutate(Country2 = fct_reorder2(Country, Date, NewPat, last2)) </code></pre>
<p>それでは新しく出来た<code>Country2</code>の水準を確認してみましょう。</p>
<pre class="r"><code>levels(Reorder2_df$Country2)</code></pre>
<pre><code>## [1] &quot;日本&quot;        &quot;韓国&quot;        &quot;香港&quot;        &quot;中国 (本土)&quot; &quot;台湾&quot;</code></pre>
<p>ちゃんと7月1日の新規感染者数基準で水準の順番が調整されましたので、これを使ってグラフをもう一回作ってみます。</p>
<pre class="r"><code>Reorder2_df %&gt;%
  ggplot() +
  geom_line(aes(x = Date, y = NewPat, color = Country2),
            size = 1) +
  scale_x_date(date_labels = &quot;%Y年%m月%d日&quot;) +
  labs(x = &quot;年月日&quot;, y = &quot;新規感染者数 (人)&quot;, color = &quot;&quot;) +
  theme_gray(base_family = &quot;HiraKakuProN-W3&quot;)</code></pre>
<p><img src="/dplyr_intro_files/figure-html/unnamed-chunk-154-1.png" width="672" /></p>
<p>これで図がさらに読みやすくなりました。ちなみに、<code>forcats</code>パッケージは<code>last2()</code>以外にも<code>first2()</code>という関数も提供しております。これを使うと、7月1日でなく、6月27日の新規感染者数の降順で水準の順番が調整されます。他にも引数を2つ使用する自作関数も使えますが、<code>fct_reorder2()</code>の主な使いみちは<code>last2()</code>で十分でしょう。</p>
<p><strong><code>fct_collapse()</code>: 水準を統合する</strong></p>
<p>水準数をより水準数に減らすためには、<code>fct_recode()</code>を使います。先ほど、<code>fct_shift()</code>で使った<code>df4</code>の例を考えてみましょう。<code>df4</code>の<code>Q1</code>の水準数は6つです。</p>
<pre class="r numberLines"><code>levels(df4$Q1)</code></pre>
<pre><code>## [1] &quot;そう思う&quot;                     &quot;どちらかと言えばそう思う&quot;    
## [3] &quot;どちらとも言えない&quot;           &quot;どちらかと言えばそう思わない&quot;
## [5] &quot;そう思わない&quot;                 &quot;答えたくない&quot;</code></pre>
<p>これを4つに減らして見ましょう。具体的には「そう思う」と「どちらかと言えばそう思う」を「そう思う」に、「そう思わない」と「どちらかと言えばそう思わない」を「そう思わない」に統合します。これを<code>fct_recode()</code>で処理したのが以下のコードです。</p>
<pre class="r numberLines"><code># fct_recode()を使った例
df4 &lt;- df4 %&gt;% 
    mutate(Q1_R2 = fct_recode(Q1,
                              そう思う          = &quot;そう思う&quot;,
                              そう思う          = &quot;どちらかと言えばそう思う&quot;,
                              どちらとも言えない  = &quot;どちらとも言えない&quot;,
                              そう思わない       = &quot;どちらかと言えばそう思わない&quot;,
                              そう思わない       = &quot;そう思わない&quot;,
                              答えたくない       = &quot;答えたくない&quot;))

df4</code></pre>
<pre><code>## # A tibble: 10 x 4
##       ID Q1                          Q1_R                       Q1_R2           
##    &lt;int&gt; &lt;fct&gt;                       &lt;fct&gt;                      &lt;fct&gt;           
##  1     1 そう思う                    そう思う                   そう思う        
##  2     2 そう思わない                そう思わない               そう思わない    
##  3     3 どちらとも言えない          どちらとも言えない         どちらとも言え… 
##  4     4 どちらかと言えばそう思う    どちらかと言えばそう思う   そう思う        
##  5     5 答えたくない                答えたくない               答えたくない    
##  6     6 どちらかと言えばそう思う    どちらかと言えばそう思う   そう思う        
##  7     7 どちらかと言えばそう思わな… どちらかと言えばそう思わ…  そう思わない    
##  8     8 答えたくない                答えたくない               答えたくない    
##  9     9 そう思わない                そう思わない               そう思わない    
## 10    10 そう思う                    そう思う                   そう思う</code></pre>
<pre class="r numberLines"><code>levels(df4$Q1_R2)</code></pre>
<pre><code>## [1] &quot;そう思う&quot;           &quot;どちらとも言えない&quot; &quot;そう思わない&quot;      
## [4] &quot;答えたくない&quot;</code></pre>
<p>しかし、水準を統合するに特化した<code>fct_collapse()</code>を使えばより便利です。使い方は、<code>fct_recode()</code>に非常に似ているため省略しますが、<code>=</code>の右側を<code>c()</code>でまとめることが出来ます。</p>
<pre class="r numberLines"><code># fct_collapse()を使った例
df4 &lt;- df4 %&gt;% 
    mutate(Q1_R3 = fct_collapse(Q1,
                                そう思う = c(&quot;そう思う&quot;, &quot;どちらかと言えばそう思う&quot;),
                                どちらとも言えない = &quot;どちらとも言えない&quot;,
                                そう思わない = c( &quot;どちらかと言えばそう思わない&quot;, &quot;そう思わない&quot;),
                                答えたくない = &quot;答えたくない&quot;))

df4</code></pre>
<pre><code>## # A tibble: 10 x 5
##       ID Q1                    Q1_R                  Q1_R2         Q1_R3        
##    &lt;int&gt; &lt;fct&gt;                 &lt;fct&gt;                 &lt;fct&gt;         &lt;fct&gt;        
##  1     1 そう思う              そう思う              そう思う      そう思う     
##  2     2 そう思わない          そう思わない          そう思わない  そう思わない 
##  3     3 どちらとも言えない    どちらとも言えない    どちらとも言… どちらとも言…
##  4     4 どちらかと言えばそう… どちらかと言えばそう… そう思う      そう思う     
##  5     5 答えたくない          答えたくない          答えたくない  答えたくない 
##  6     6 どちらかと言えばそう… どちらかと言えばそう… そう思う      そう思う     
##  7     7 どちらかと言えばそう… どちらかと言えばそう… そう思わない  そう思わない 
##  8     8 答えたくない          答えたくない          答えたくない  答えたくない 
##  9     9 そう思わない          そう思わない          そう思わない  そう思わない 
## 10    10 そう思う              そう思う              そう思う      そう思う</code></pre>
<pre class="r numberLines"><code>levels(df4$Q1_R3)</code></pre>
<pre><code>## [1] &quot;そう思う&quot;           &quot;どちらとも言えない&quot; &quot;そう思わない&quot;      
## [4] &quot;答えたくない&quot;</code></pre>
<p><code>fct_recode()</code>の結果と同じ結果が得られました。元の水準数や、減らされる水準数などによっては書く手間があまり変わらないので、好きな方を使っても良いでしょう。</p>
<p><strong><code>fct_drop()</code>: 使われていない水準を除去する</strong></p>
<p>水準としては存在するものの、データとしては存在しないケースもあります。これをここでは「空水準 (empty levels)」と呼びます。たとえば、以下のコードは<code>Pref</code>をfactor化してから<code>Pref == "奈良県"</code>のケースを落としたものです。</p>
<pre class="r numberLines"><code>Score_df_f2 &lt;- df %&gt;%
  mutate(Pref = fct_inorder(Pref)) %&gt;%
  filter(Pref != &quot;奈良県&quot;) %&gt;%
  group_by(Pref) %&gt;%
  summarise(Score   = mean(Score, na.rm = TRUE),
            .groups = &quot;drop&quot;)

Score_df_f2</code></pre>
<pre><code>## # A tibble: 8 x 2
##   Pref     Score
##   &lt;fct&gt;    &lt;dbl&gt;
## 1 東京都    3.67
## 2 神奈川県  3.53
## 3 千葉県    3.72
## 4 埼玉県    3.64
## 5 大阪府    3.77
## 6 京都府    3.68
## 7 兵庫県    3.54
## 8 和歌山県  3.97</code></pre>
<p>このように結果としては、奈良県のデータを除外したため空水準である奈良県は表示されませんが、<code>Pref</code>変数はどうでしょうか。</p>
<pre class="r numberLines"><code>levels(Score_df_f2$Pref)</code></pre>
<pre><code>## [1] &quot;東京都&quot;   &quot;神奈川県&quot; &quot;千葉県&quot;   &quot;埼玉県&quot;   &quot;大阪府&quot;   &quot;京都府&quot;   &quot;兵庫県&quot;  
## [8] &quot;奈良県&quot;   &quot;和歌山県&quot;</code></pre>
<p>このように水準としては残っていることが分かります。使われていない水準が分析や可視化に影響を与えないケースもありますが、与えるケースもあります。これもこれまで勉強してきた<code>fct_*()</code>関数群で対応可能ですが、<code>fct_drop()</code>関数を使えば一発で終わります。実際にやってみましょう。</p>
<pre class="r numberLines"><code>Score_df_f2 &lt;- Score_df_f2 %&gt;%
  mutate(Pref = fct_drop(Pref))</code></pre>
<pre class="r numberLines"><code>levels(Score_df_f2$Pref)</code></pre>
<pre><code>## [1] &quot;東京都&quot;   &quot;神奈川県&quot; &quot;千葉県&quot;   &quot;埼玉県&quot;   &quot;大阪府&quot;   &quot;京都府&quot;   &quot;兵庫県&quot;  
## [8] &quot;和歌山県&quot;</code></pre>
<p>水準から奈良県が消えました。同じ機能をする関数としてはR内蔵関数である<code>droplevels()</code>関数があり、使い方は<code>fct_drop()</code>と同じです。</p>
<p><strong><code>fct_expand()</code>: 水準を追加する</strong></p>
<p>一方、空水準を追加することも可能です。<code>fct_expand()</code>関数には元の変数名に加え、追加する水準名を入れるだけです。たとえば、<code>df</code>の<code>Pref</code>の水準は関東と関西の9都府県名となっていますが、ここに<code>"滋賀県"</code>という水準を追加してみます。。</p>
<pre class="r numberLines"><code>df5 &lt;- df %&gt;%
  mutate(Pref = fct_expand(Pref, &quot;滋賀県&quot;))

levels(df5$Pref)</code></pre>
<pre><code>##  [1] &quot;京都府&quot;   &quot;兵庫県&quot;   &quot;千葉県&quot;   &quot;和歌山県&quot; &quot;埼玉県&quot;   &quot;大阪府&quot;  
##  [7] &quot;奈良県&quot;   &quot;東京都&quot;   &quot;神奈川県&quot; &quot;滋賀県&quot;</code></pre>
<p><code>"滋賀県"</code>という新しい水準が出来ましたね。ただし、新しく追加された水準は最後の順番になりますので、修正が必要な場合は<code>fct_relevel()</code>などを使って適宜修正してください。</p>
<p>新しく水準が追加されることによって、何かの変化はあるでしょうか。まずは都府県ごとに<code>Score</code>の平均値とケース数を計算してみましょう。</p>
<pre class="r numberLines"><code>df5 %&gt;%
  group_by(Pref) %&gt;%
  summarise(Score   = mean(Score, na.rm = TRUE),
            N       = n(),
            .groups = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 9 x 3
##   Pref     Score     N
##   &lt;fct&gt;    &lt;dbl&gt; &lt;int&gt;
## 1 京都府    3.68   414
## 2 兵庫県    3.54   591
## 3 千葉県    3.72  1000
## 4 和歌山県  3.97   140
## 5 埼玉県    3.64  1000
## 6 大阪府    3.77  1000
## 7 奈良県    3.85   147
## 8 東京都    3.67  1000
## 9 神奈川県  3.53  1000</code></pre>
<p>見た目は全く変わらず、滋賀県の行が新しく出来たわけでもありません。<code>dplyr</code>の<code>group_by()</code>の場合、空水準はグループ化の対象になりません。一方、多くのR内蔵関数はケースとして存在しなくても計算の対象となります。たとえば、ベクトル内のある値が何個格納されているか確認する<code>table()</code>関数の例を見てみましょう。</p>
<pre class="r numberLines"><code>table(df5$Pref)</code></pre>
<pre><code>## 
##   京都府   兵庫県   千葉県 和歌山県   埼玉県   大阪府   奈良県   東京都 
##      414      591     1000      140     1000     1000      147     1000 
## 神奈川県   滋賀県 
##     1000        0</code></pre>
<p><code>"滋賀県"</code>という列があり、合致するケースが0と表示されます。<code>group_by()</code>でも空の水準まで含めて出力する引数<code>.drop</code>があります。デフォルトは<code>TRUE</code>ですが、これを<code>FALSE</code>に指定してみます。</p>
<pre class="r numberLines"><code>df5 %&gt;%
  group_by(Pref, .drop = FALSE) %&gt;%
  summarise(Score   = mean(Score, na.rm = TRUE),
            N       = n(),
            .groups = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 10 x 3
##    Pref      Score     N
##    &lt;fct&gt;     &lt;dbl&gt; &lt;int&gt;
##  1 京都府     3.68   414
##  2 兵庫県     3.54   591
##  3 千葉県     3.72  1000
##  4 和歌山県   3.97   140
##  5 埼玉県     3.64  1000
##  6 大阪府     3.77  1000
##  7 奈良県     3.85   147
##  8 東京都     3.67  1000
##  9 神奈川県   3.53  1000
## 10 滋賀県   NaN        0</code></pre>
<p>空水準も出力され、<code>Score</code>の平均値は計算不可 (<code>NaN</code>)、ケース数は0という結果が得られました。</p>
<p><strong><code>fct_explicit_na()</code>: 欠損値に水準を与える</strong></p>
<p>まずは、実習用データ<code>df6</code>を作ってみまます。<code>X1</code>はnumeric型変数ですが、これをfactor化します。最初から<code>tibble()</code>内でfactor化しておいても問題ありませんが、練習だと思ってください。</p>
<pre class="r numberLines"><code>df6 &lt;- tibble(
  ID = 1:10,
  X1 = c(1, 3, 2, NA, 2, 2, 1, NA, 3, NA)
)

df6 &lt;- df6 %&gt;%
  mutate(X1 = factor(X1, 
                     levels = c(1, 2, 3),
                     labels = c(&quot;ラーメン&quot;, &quot;うどん&quot;, &quot;そば&quot;)))

df6</code></pre>
<pre><code>## # A tibble: 10 x 2
##       ID X1      
##    &lt;int&gt; &lt;fct&gt;   
##  1     1 ラーメン
##  2     2 そば    
##  3     3 うどん  
##  4     4 &lt;NA&gt;    
##  5     5 うどん  
##  6     6 うどん  
##  7     7 ラーメン
##  8     8 &lt;NA&gt;    
##  9     9 そば    
## 10    10 &lt;NA&gt;</code></pre>
<p>それでは<code>X1</code>をグループ化変数とし、ケース数を計算してみましょう。</p>
<pre class="r numberLines"><code>df6 %&gt;%
  group_by(X1) %&gt;%
  summarise(N       = n(),
            .groups = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 4 x 2
##   X1           N
##   &lt;fct&gt;    &lt;int&gt;
## 1 ラーメン     2
## 2 うどん       3
## 3 そば         2
## 4 &lt;NA&gt;         3</code></pre>
<p><code>NA</code>もグループ化の対象となります。以下はこの欠損値も一つの水準として指定する方法について紹介します。欠損値を欠損値のままにするケースが多いですが、欠損値が何らかの意味を持つ場合、分析の対象になります。たとえば、多項ロジスティック回帰の応答変数として「分からない/答えたくない」を含めたり、<a href="https://ci.nii.ac.jp/naid/40021269699">「分からない/答えたくない」を選択する要因を分析</a>したい場合は、欠損値に値を与える必要があります。なぜなら、一般的な分析において欠損値は分析対象から除外されるからです。</p>
<p>まずは、これまで紹介した関数を使ったやり方から紹介します。</p>
<pre class="r numberLines"><code>df6 %&gt;%
         # まず、X1をcharacter型に変換し、X2という列に保存
  mutate(X2 = as.character(X1),
         # X2がNAなら&quot;欠損値&quot;、それ以外なら元のX2の値に置換
         X2 = ifelse(is.na(X2), &quot;欠損値&quot;, X2),
         # X2を再度factor化する
         X2 = factor(X2, 
                     levels = c(&quot;ラーメン&quot;, &quot;うどん&quot;, &quot;そば&quot;, &quot;欠損値&quot;)))</code></pre>
<pre><code>## # A tibble: 10 x 3
##       ID X1       X2      
##    &lt;int&gt; &lt;fct&gt;    &lt;fct&gt;   
##  1     1 ラーメン ラーメン
##  2     2 そば     そば    
##  3     3 うどん   うどん  
##  4     4 &lt;NA&gt;     欠損値  
##  5     5 うどん   うどん  
##  6     6 うどん   うどん  
##  7     7 ラーメン ラーメン
##  8     8 &lt;NA&gt;     欠損値  
##  9     9 そば     そば    
## 10    10 &lt;NA&gt;     欠損値</code></pre>
<p><code>X1</code>をcharacter型に戻す理由<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>は、水準にない値が入るとfactor化が解除されるからです。factor型をcharacter型に戻さずに<code>df6$X1</code>の<code>NA</code>を<code>"欠損値"</code>に置換すると、以下のようになります。</p>
<pre class="r numberLines"><code># df6のX1がNAなら&quot;欠損&quot;、それ以外なら元のX1の値を返す
ifelse(is.na(df6$X1), &quot;欠損値&quot;, df6$X1)</code></pre>
<pre><code>##  [1] &quot;1&quot;      &quot;3&quot;      &quot;2&quot;      &quot;欠損値&quot; &quot;2&quot;      &quot;2&quot;      &quot;1&quot;      &quot;欠損値&quot;
##  [9] &quot;3&quot;      &quot;欠損値&quot;</code></pre>
<p><code>"ラーメン"</code>と<code>"うどん"</code>、<code>"そば"</code>がfactor化前の1, 2, 3に戻っただけでなく、<code>NA</code>が<code>"欠損値"</code>というcharacter型に置換されたため、全体がcharacter型に変換されました。このように欠損値に水準を与える作業は難しくはありませんが、面倒な作業です。そこで登場する関数が<code>fct_exlpicit_na()</code>関数です。使い方は、元の変数に加え、欠損値の水準名を指定する<code>na_level</code>です。</p>
<pre class="r numberLines"><code>df6 &lt;- df6 %&gt;%
  # na_levelのデフォルト値は&quot;(Missing)&quot;
  mutate(X2 = fct_explicit_na(X1, na_level = &quot;欠損値&quot;))

df6</code></pre>
<pre><code>## # A tibble: 10 x 3
##       ID X1       X2      
##    &lt;int&gt; &lt;fct&gt;    &lt;fct&gt;   
##  1     1 ラーメン ラーメン
##  2     2 そば     そば    
##  3     3 うどん   うどん  
##  4     4 &lt;NA&gt;     欠損値  
##  5     5 うどん   うどん  
##  6     6 うどん   うどん  
##  7     7 ラーメン ラーメン
##  8     8 &lt;NA&gt;     欠損値  
##  9     9 そば     そば    
## 10    10 &lt;NA&gt;     欠損値</code></pre>
<p>欠損値が一つの水準になったことが分かります。</p>
<pre class="r numberLines"><code>df6 %&gt;%
  group_by(X2) %&gt;%
  summarise(N       = n(),
            .groups = &quot;drop&quot;)</code></pre>
<pre><code>## # A tibble: 4 x 2
##   X2           N
##   &lt;fct&gt;    &lt;int&gt;
## 1 ラーメン     2
## 2 うどん       3
## 3 そば         2
## 4 欠損値       3</code></pre>
<p>むろん、<code>group_by()</code>を使ってもちゃんと出力されます。</p>
<hr />
</div>
</div>
<div id="行単位の操作" class="section level2">
<h2>行単位の操作</h2>
<p>ここでは行単位の操作について考えたいと思います。<code>select()</code>の説明で使った<code>myDF1</code>を見てみましょう。</p>
<pre class="r numberLines"><code>myDF1</code></pre>
<pre><code>## # A tibble: 5 x 10
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9
## 2     2     4     5     2     5     3     9     0     5     1
## 3     3     6     1     1     6     2     5     3     9     3
## 4     4     2     1     6     0     3     0     0     1     3
## 5     5     7     0     9     2     1     1     2     3     8</code></pre>
<p>ここで<code>X1</code>と<code>X2</code>と<code>X3</code>の平均値を計算し、<code>X_Mean</code>という名の変数にする場合、以下のような書き方が普通でしょう。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  mutate(X_Mean = mean(c(X1, X2, X3)))</code></pre>
<pre><code>## # A tibble: 5 x 11
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D X_Mean
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9   3.13
## 2     2     4     5     2     5     3     9     0     5     1   3.13
## 3     3     6     1     1     6     2     5     3     9     3   3.13
## 4     4     2     1     6     0     3     0     0     1     3   3.13
## 5     5     7     0     9     2     1     1     2     3     8   3.13</code></pre>
<p>あら、なんかおかしくありませんか。1行目の場合、<code>X1</code>と<code>X2</code>、<code>X3</code>それぞれ2、5、3であり、平均値は3.333であるはずなのに3.133になりました。これは2行目以降も同じです。なぜでしょうか。</p>
<p>実は<code>dplyr</code>は行単位の計算が苦手です。実際、データフレーム (または、tibble)というのは既に説明したとおり、縦ベクトルを横に並べたものです。列をまたがる場合、データ型が異なる場合も多いため、そもそも使う場面も多くありません。したがって、以下のような書き方が必要でした。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  mutate(X_Mean = (X1 + X2 + X3) / 3)</code></pre>
<pre><code>## # A tibble: 5 x 11
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D X_Mean
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9  3.33 
## 2     2     4     5     2     5     3     9     0     5     1  3    
## 3     3     6     1     1     6     2     5     3     9     3  5    
## 4     4     2     1     6     0     3     0     0     1     3  0.667
## 5     5     7     0     9     2     1     1     2     3     8  3.67</code></pre>
<p>先ほどの<code>mean(c(X1, X2, X3))</code>は(<code>X1</code>列と<code>X2</code>列、<code>X3</code>列)の平均値です。<code>X1</code>は長さ1のベクトルではなく、その列全体を指すものです。つまり、<code>mean(c(X1, X2, X3))</code>は<code>mean(c(myD1F$X1, myDF1$X2, myDF1$X3))</code>と同じことになります。だから全て3.133という結果が得られました。ただし、後者はベクトル同士の加減乗除になるため問題ありません。実際<code>c(1, 2, 3) + c(3, 5, 0)</code>は同じ位置の要素同士の計算になります。</p>
<p>ここで<code>mean()</code>関数を使う場合には全ての演算を、一行一行に分けて行う必要があります。ある一行のみに限定する場合、<code>mean(c(X1, X2, X3))</code>の<code>X1</code>などは長さ1のベクトルになるため、<code>(X1 + X2 + X3) / 3</code>と同じことになります。この「一行単位で処理を行う」ことを指定する関数が<code>rowwise()</code>関数です。これは行単位の作業を行う前に指定するだけです。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  rowwise() %&gt;%
  mutate(X_Mean = mean(c(X1, X2, X3)))</code></pre>
<pre><code>## # A tibble: 5 x 11
## # Rowwise: 
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D X_Mean
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9  3.33 
## 2     2     4     5     2     5     3     9     0     5     1  3    
## 3     3     6     1     1     6     2     5     3     9     3  5    
## 4     4     2     1     6     0     3     0     0     1     3  0.667
## 5     5     7     0     9     2     1     1     2     3     8  3.67</code></pre>
<p>これで問題なく行単位の処理ができるようになりました。今回は変数が3つのみだったので、これで問題ありませんが、変数が多くなると<code>:</code>や<code>starts_with()</code>、<code>num_range()</code>などを使って変数を選択したくなります。この場合は計算する関数内に<code>c_across()</code>を入れます。ここでは<code>X1</code>列から<code>X3D</code>列までの平均値を求めてみましょう。</p>
<pre class="r numberLines"><code>myDF1 %&gt;%
  rowwise() %&gt;%
  mutate(X_Mean = mean(X1:X3D))</code></pre>
<pre><code>## # A tibble: 5 x 11
## # Rowwise: 
##      ID    X1    Y1   X1D    X2    Y2   X2D    X3    Y3   X3D X_Mean
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1     1     2     3     4     5     3     8     3     1     9    5.5
## 2     2     4     5     2     5     3     9     0     5     1    2.5
## 3     3     6     1     1     6     2     5     3     9     3    4.5
## 4     4     2     1     6     0     3     0     0     1     3    2.5
## 5     5     7     0     9     2     1     1     2     3     8    7.5</code></pre>
<p>実は<code>rowwise()</code>関数、2020年6月に公開されたdplyr 1.0.0で注目された関数ですが、昔のdplyrにも<code>rowwise()</code>関数はありました。ただし、<code>purrr</code>パッケージや<code>tidyr</code>パッケージの<code>nest()</code>関数などにより使い道がなくなりましたが、なぜか華麗に復活しました。データ分析に使うデータは基本単位は列であるため、実際に<code>rowwise()</code>が使われる場面は今の段階では多くないでしょう。また、簡単な作業なら<code>X1 + X2</code>のような演算でも対応できます。それでも、覚えておけば便利な関数であることには間違いありません。</p>
<hr />
</div>
<div id="データの結合" class="section level2">
<h2>データの結合</h2>
<div id="行の結合" class="section level3">
<h3>行の結合</h3>
<p>まずは、複数のデータフレームまたはtibbleを縦に結合する方法について解説します。イメージとしては図<a href="#fig:merge-row">9</a>のようなものです。</p>
<div class="figure" style="text-align: center"><span id="fig:merge-row"></span>
<img src="Figures/Handling1/Merge1.png" alt="行の結合" width="80%" />
<p class="caption">
Figure 9: 行の結合
</p>
</div>
<p>行を結合する際には<code>dplyr</code>パッケージの<code>bind_rows()</code>関数を使います。この関数の使い方は以下の通りです。</p>
<pre class="r"><code># 新しいデータ名ではなく、既にあるデータ名にすると上書きとなる
新しいデータ名 &lt;-  bind_rows(データ1, データ2, ...)</code></pre>
<p>それでは早速実際に使ってみましょう。実習のために、4つのtibbleを作成します (tibbleでなくデータフレームでも問題ありません)。</p>
<pre class="r"><code># tibble()の代わりにdata.frame()も可
rbind_df1 &lt;- tibble(X1 = 1:3,
                    X2 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;),
                    X3 = c(T, T, F)) # TRUEとFALSEはTはFと省略可能

rbind_df2 &lt;- tibble(X1 = 4:6,
                    X2 = c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;),
                    X3 = c(F, T, F))

rbind_df3 &lt;- tibble(X1 = 7:9,
                    X3 = c(T, T, T),
                    X2 = c(&quot;G&quot;, &quot;H&quot;, &quot;I&quot;))

rbind_df4 &lt;- tibble(X1 = 10:12,
                    X2 = c(&quot;J&quot;, &quot;K&quot;, &quot;L&quot;),
                    X5 = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;))

rbind_df1 # rbind_df1を出力</code></pre>
<pre><code>## # A tibble: 3 x 3
##      X1 X2    X3   
##   &lt;int&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     1 A     TRUE 
## 2     2 B     TRUE 
## 3     3 C     FALSE</code></pre>
<pre class="r"><code>rbind_df2 # rbind_df2を出力</code></pre>
<pre><code>## # A tibble: 3 x 3
##      X1 X2    X3   
##   &lt;int&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     4 D     FALSE
## 2     5 E     TRUE 
## 3     6 F     FALSE</code></pre>
<pre class="r"><code>rbind_df3 # rbind_df3を出力</code></pre>
<pre><code>## # A tibble: 3 x 3
##      X1 X3    X2   
##   &lt;int&gt; &lt;lgl&gt; &lt;chr&gt;
## 1     7 TRUE  G    
## 2     8 TRUE  H    
## 3     9 TRUE  I</code></pre>
<pre class="r"><code>rbind_df4 # rbind_df4を出力</code></pre>
<pre><code>## # A tibble: 3 x 3
##      X1 X2    X5    
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; 
## 1    10 J     Song  
## 2    11 K     Yanai 
## 3    12 L     Hadley</code></pre>
<p>まずは、<code>rbind_df1</code>と<code>rbind_df2</code>を結合してみます。この2つのデータは同じ変数が同じ順番で並んでいますね。</p>
<pre class="r"><code>Binded_df1 &lt;- bind_rows(rbind_df1, rbind_df2)
Binded_df1</code></pre>
<pre><code>## # A tibble: 6 x 3
##      X1 X2    X3   
##   &lt;int&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     1 A     TRUE 
## 2     2 B     TRUE 
## 3     3 C     FALSE
## 4     4 D     FALSE
## 5     5 E     TRUE 
## 6     6 F     FALSE</code></pre>
<p>2つのデータが結合されたことが確認できます。それでは<code>rbind_df1</code>と<code>rbind_df2</code>、<code>rbind_df3</code>はどうでしょうか。確かに3つのデータは同じ変数を持ちますが、<code>rbind_df3</code>は変数の順番が<code>X1</code>、<code>X3</code>、<code>X2</code>になっています。このまま結合するとエラーが出るでしょうか。とりあえず、やってみます。</p>
<pre class="r"><code>Binded_df2 &lt;- bind_rows(rbind_df1, rbind_df2, rbind_df3)
Binded_df2</code></pre>
<pre><code>## # A tibble: 9 x 3
##      X1 X2    X3   
##   &lt;int&gt; &lt;chr&gt; &lt;lgl&gt;
## 1     1 A     TRUE 
## 2     2 B     TRUE 
## 3     3 C     FALSE
## 4     4 D     FALSE
## 5     5 E     TRUE 
## 6     6 F     FALSE
## 7     7 G     TRUE 
## 8     8 H     TRUE 
## 9     9 I     TRUE</code></pre>
<p>このように変数の順番が異なっても、先に指定したデータの変数順で問題なく結合できました。これまでの作業は<code>dplyr</code>パッケージの<code>bind_rows()</code>を使わずに、R内蔵関数の<code>rbind()</code>でも同じやり方でできます。<code>bind_rows()</code>の特徴は、変数名が一致しない場合、つまり今回の例だと<code>rbind_df4</code>が含まれる場合です。<code>rbind_df1</code>から<code>rbind_df3</code>までは順番が違っても<code>X1</code>、<code>X2</code>、<code>X3</code>変数で構成されていました。一方、<code>rbind_dr4</code>には<code>X3</code>がなく、新たに<code>X4</code>という変数があります。これを<code>rbind()</code>関数で結合するとエラーが出力されます。</p>
<pre class="r"><code># rbind()を使う場合
rbind(rbind_df1, rbind_df2, rbind_df3, rbind_df4)</code></pre>
<pre><code>## Error in match.names(clabs, names(xi)): names do not match previous names</code></pre>
<p>一方、<code>bind_rows()</code>はどうでしょうか。</p>
<pre class="r"><code>Binded_df3 &lt;- bind_rows(rbind_df1, rbind_df2, rbind_df3, rbind_df4)
Binded_df3</code></pre>
<pre><code>## # A tibble: 12 x 4
##       X1 X2    X3    X5    
##    &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; 
##  1     1 A     TRUE  &lt;NA&gt;  
##  2     2 B     TRUE  &lt;NA&gt;  
##  3     3 C     FALSE &lt;NA&gt;  
##  4     4 D     FALSE &lt;NA&gt;  
##  5     5 E     TRUE  &lt;NA&gt;  
##  6     6 F     FALSE &lt;NA&gt;  
##  7     7 G     TRUE  &lt;NA&gt;  
##  8     8 H     TRUE  &lt;NA&gt;  
##  9     9 I     TRUE  &lt;NA&gt;  
## 10    10 J     NA    Song  
## 11    11 K     NA    Yanai 
## 12    12 L     NA    Hadley</code></pre>
<p><code>X1</code>から<code>X4</code>まで全ての列が生成され、元のデータにはなかった列に関しては<code>NA</code>で埋められています。</p>
<p>ならば、<code>bind_rows()</code>の完全勝利かというと、そうとは限りません。自分で架空した複数のデータフレーム、またはtibbleを結合する際、「このデータは全て同じ変数を持っているはず」と事前に分かっているなら<code>rbind()</code>の方が効果的です。なぜなら、変数名が異なる場合、エラーが出力されるからです。<code>bind_rows()</code>を使うと、コーディングミスなどにより、列名の相違がある場合でも結合してくれてしまうので、分析の結果を歪ませる可能性があります。</p>
</div>
<div id="列の結合" class="section level3">
<h3>列の結合</h3>
<p>実はデータ分析においてデータの結合といえば、列の結合が一般的です。これは図<a href="#fig:merge-col">10</a>のような操作を意味します。</p>
<div class="figure" style="text-align: center"><span id="fig:merge-col"></span>
<img src="Figures/Handling1/Merge2.png" alt="列の結合" width="80%" />
<p class="caption">
Figure 10: 列の結合
</p>
</div>
<p>まずは、本章で作成した<code>df2</code>をもう一回作ってみます。</p>
<pre class="r"><code>df2 &lt;- df %&gt;%
  group_by(Pref) %&gt;%
  summarise(Budget_Mean = mean(Budget, na.rm = TRUE),
            ScoreN_Sum  = sum(ScoreN, na.rm = TRUE),
            Score_Mean  = mean(Score, na.rm = TRUE),
            N           = n(),
            .groups     = &quot;drop&quot;)

df2</code></pre>
<pre><code>## # A tibble: 9 x 5
##   Pref     Budget_Mean ScoreN_Sum Score_Mean     N
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;
## 1 京都府         1399.        216       3.68   414
## 2 兵庫県         1197.        230       3.54   591
## 3 千葉県         1124.        259       3.72  1000
## 4 和歌山県       1252          83       3.97   140
## 5 埼玉県         1147.        278       3.64  1000
## 6 大阪府         1203.        516       3.77  1000
## 7 奈良県         1169.         45       3.85   147
## 8 東京都         1283.       1165       3.67  1000
## 9 神奈川県       1239.        587       3.53  1000</code></pre>
<p>ラーメン屋の店舗ですが、たしかにデータには埼玉、東京、大阪などは1000店舗しか入っておりません。実はもっと多いですが、ぐるなびAPIの仕様上、最大1000店舗しか情報取得が出来ないからです。ここに実際の店舗数が入っている新しいデータセット、<a href="../Data/Ramen2.csv">Ramen2.csv</a>があります。これを読み込み、<code>df3</code>という名で格納しましょう。</p>
<pre class="r"><code># データのパスは適宜修正すること
df3 &lt;- read_csv(&quot;Data/Ramen2.csv&quot;)</code></pre>
<pre><code>## 
## ── Column specification ────────────────────────────────────────────────────────
## cols(
##   Pref = col_character(),
##   Pop = col_number(),
##   Area = col_number(),
##   RamenN = col_double(),
##   Turnout = col_double(),
##   LDP = col_double(),
##   CDP = col_double(),
##   DPFP = col_double(),
##   Komei = col_double(),
##   JIP = col_double(),
##   JCP = col_double(),
##   SDP = col_double(),
##   Reiwa = col_double(),
##   NHK = col_double(),
##   HRP = col_double()
## )</code></pre>
<pre class="r"><code>df3</code></pre>
<pre><code>## # A tibble: 47 x 15
##    Pref      Pop   Area RamenN Turnout   LDP   CDP  DPFP Komei   JIP   JCP   SDP
##    &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 北海道 5.38e6 83424.   1454    53.8  32.3  20.8  6.65 11.7   7.78 11.6   1.31
##  2 青森県 1.31e6  9646.    336    42.9  39.8  22.0  7.24 11.3   3.4   8.31  2.36
##  3 岩手県 1.28e6 15275.    285    56.5  35.5  17.8 12.5   8.22  4.36 10.4   3.83
##  4 宮城県 2.33e6  7282.    557    51.2  39.6  17.8  9.02 11.1   4.6   7.89  2.1 
##  5 秋田県 1.02e6 11638.    301    56.3  44.5  13.5  8.64 10.6   4.48  8.09  3.77
##  6 山形県 1.12e6  9323.    512    60.7  45.2  14.9  7.37  9.87  4.28  6.51  5.08
##  7 福島県 1.91e6 13784.    550    52.4  38.2  13.6 12.1  12.8   5.31  7.99  3.01
##  8 茨城県 2.92e6  6097.    663    45.0  39.3  15.2  7.15 15.1   6.73  7.73  1.46
##  9 栃木県 1.97e6  6408.    595    44.1  40.3  18.9  9.94 12.8   4.9   5.04  1.03
## 10 群馬県 1.97e6  6362.    488    48.2  40.6  16.4  9.76 12.4   4.67  7.58  1.87
## # … with 37 more rows, and 3 more variables: Reiwa &lt;dbl&gt;, NHK &lt;dbl&gt;, HRP &lt;dbl&gt;</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;text-align: center;">
変数名
</th>
<th style="text-align:left;text-align: center;">
説明
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<code>Pref</code>
</td>
<td style="text-align:left;">
都道府県名
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Pop</code>
</td>
<td style="text-align:left;">
日本人人口 (2015年国勢調査)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Area</code>
</td>
<td style="text-align:left;">
面積 (2015年国勢調査)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>RamenN</code>
</td>
<td style="text-align:left;">
ぐるなびに登録されたラーメン屋の店舗数
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Turnout</code>
</td>
<td style="text-align:left;">
2019年参院選: 投票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>LDP</code>
</td>
<td style="text-align:left;">
2019年参院選: 自民党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>CDP</code>
</td>
<td style="text-align:left;">
2019年参院選: 立憲民主党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>DPFP</code>
</td>
<td style="text-align:left;">
2019年参院選: 国民民主党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Komei</code>
</td>
<td style="text-align:left;">
2019年参院選: 公明党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>JIP</code>
</td>
<td style="text-align:left;">
2019年参院選: 日本維新の会の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>JCP</code>
</td>
<td style="text-align:left;">
2019年参院選: 日本共産党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>SDP</code>
</td>
<td style="text-align:left;">
2019年参院選: 社会民主党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>Reiwa</code>
</td>
<td style="text-align:left;">
2019年参院選: れいわ新選組の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>NHK</code>
</td>
<td style="text-align:left;">
2019年参院選: NHKから国民を守る党の得票率 (比例)
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>HRP</code>
</td>
<td style="text-align:left;">
2019年参院選: 幸福実現党の得票率 (比例)
</td>
</tr>
</tbody>
</table>
<p>本データは都道府県ごとの人口、面積、ぐるなびに登録されたラーメン屋の店舗数、2019年参議院議員通常選挙の結果が格納されています。人口と面積は2015年国勢調査、ぐるなびの情報は2020年6月時点での情報です。</p>
<p><code>df2</code>にデータ上の店舗数ではなく、実際の店舗数を新しい列として追加したい場合はどうすれば良いでしょうか。簡単な方法としては<code>df3</code>から情報を取得し、それを自分で入れる方法です。</p>
<pre class="r"><code>df3 %&gt;%
  # df2のPrefベクトルの要素と一致するものに絞る
  filter(Pref %in% df2$Pref) %&gt;%
  # 都道府県名とラーメン屋の店舗数のみ抽出
  select(Pref, RamenN)</code></pre>
<pre><code>## # A tibble: 9 x 2
##   Pref     RamenN
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 埼玉県     1106
## 2 千葉県     1098
## 3 東京都     3220
## 4 神奈川県   1254
## 5 京都府      415
## 6 大阪府     1325
## 7 兵庫県      591
## 8 奈良県      147
## 9 和歌山県    140</code></pre>
<p>そして、この情報を<code>df2$RamenN &lt;- c(415, 1106, 1254, ...)</code>のように追加すればいいですね。</p>
<p>しかし、このような方法は非効率的です。そもそも<code>df3</code>から得られた結果の順番と<code>df2</code>の順番も一致しないので、一々対照しながらベクトルを作ることになります。ここで登場する関数が<code>dplyr</code>の<code>*_join()</code>関数群です。この関数群には4つの関数が含まれており、以下のような使い方になります。</p>
<pre class="r"><code># 新しいデータ名ではなく、データ1またはデータ2の名前に格納すると上書きとなる

# 1. データ1を基準に結合
新しいデータ名 &lt;-  left_join(データ1, データ2, by = &quot;共通変数名&quot;)

# 2. データ2を基準に結合
新しいデータ名 &lt;- right_join(データ1, データ2, by = &quot;共通変数名&quot;)

# 3. データ1とデータ2両方に共通するケースのみ結合
新しいデータ名 &lt;- inner_join(データ1, データ2, by = &quot;共通変数名&quot;)

# 4. データ1とデータ2、どれかに存在するケースを結合
新しいデータ名 &lt;-  full_join(データ1, データ2, by = &quot;共通変数名&quot;)</code></pre>
<p>4つの関数の違いについて説明する前に、<code>by</code>引数について話したいと思います。これは主にキー (key)変数と呼ばれる変数で、それぞれのデータに同じ名前の変数がある必要があります。<code>df2</code>と<code>df3</code>だとそれが<code>Pref</code>変数です。どの<code>*_join()</code>関数でも、<code>Pref</code>の値が同じもの同士を結合することになります。</p>
<p>データのキー変数名が異なる場合もあります。たとえば、データ1の都道府県名は<code>Pref</code>という列に、データ2の都道府県名は<code>Prefecture</code>という列になっている場合、<code>by = "Pref"</code>でなく、<code>by = c("データ1のキー変数名" = "データ2のキー変数名")</code>、つまり、<code>by = c("Pref" = "Prefecture")</code>と指定します。</p>
<p>それでは、<code>df3</code>から都道府県名とラーメン屋の店舗数だけ抽出し、<code>df4</code>として格納しておきます。</p>
<pre class="r"><code>df4 &lt;- df3 %&gt;%
  select(Pref, RamenN)

df4</code></pre>
<pre><code>## # A tibble: 47 x 2
##    Pref   RamenN
##    &lt;chr&gt;   &lt;dbl&gt;
##  1 北海道   1454
##  2 青森県    336
##  3 岩手県    285
##  4 宮城県    557
##  5 秋田県    301
##  6 山形県    512
##  7 福島県    550
##  8 茨城県    663
##  9 栃木県    595
## 10 群馬県    488
## # … with 37 more rows</code></pre>
<p>これから共通変数名の値をキー (key)と呼びます。今回の例だと<code>Pref</code>が<code>df2</code>と<code>df4</code>のキー変数であり、その値である<code>"東京都"</code>、<code>"北海道"</code>などがキーです。</p>
<p>まずは、<code>inner_join()</code>の仕組みについて考えます。これは<code>df2</code>と<code>df4</code>に共通するキーを持つケースのみ結合する関数です。<code>df4</code>には<code>"北海道"</code>というキーがありますが、<code>df2</code>にはありません。したがって、キーが<code>"北海道"</code>のケースは結合から除外されます。これをイメージにしたものが図<a href="#fig:inner-join">11</a>です<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>。それぞれ3 <span class="math inline">\(\times\)</span> 2 (3行2列)のデータですが、キーが一致するケースは2つしかないため、結合後のデータは3 <span class="math inline">\(\times\)</span> 2となります。</p>
<div class="figure" style="text-align: center"><span id="fig:inner-join"></span>
<img src="Figures/Handling1/Merge_Inner.png" alt="`inner_join()`の仕組み" width="80%" />
<p class="caption">
Figure 11: <code>inner_join()</code>の仕組み
</p>
</div>
<p>実際にやってみましょう。</p>
<pre class="r"><code>inner_join(df2, df4, by = &quot;Pref&quot;)</code></pre>
<pre><code>## # A tibble: 9 x 6
##   Pref     Budget_Mean ScoreN_Sum Score_Mean     N RamenN
##   &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;
## 1 京都府         1399.        216       3.68   414    415
## 2 兵庫県         1197.        230       3.54   591    591
## 3 千葉県         1124.        259       3.72  1000   1098
## 4 和歌山県       1252          83       3.97   140    140
## 5 埼玉県         1147.        278       3.64  1000   1106
## 6 大阪府         1203.        516       3.77  1000   1325
## 7 奈良県         1169.         45       3.85   147    147
## 8 東京都         1283.       1165       3.67  1000   3220
## 9 神奈川県       1239.        587       3.53  1000   1254</code></pre>
<p>共通するキーは9つのみであり、結果として返されたデータの大きさも9 <span class="math inline">\(\times\)</span> 6です。<code>df2</code>に足された<code>df4</code>は2列のデータですが、キー変数である<code>Pref</code>は共通するため、1列のみ足されました。キー変数を両方残す場合は<code>keep = TRUE</code>引数を追加してください。</p>
<p>一方、<code>full_join()</code>は、すべてのキーに対して結合を行います (図<a href="#fig:full-join">12</a>)。たとえば、<code>df2</code>には<code>"北海道"</code>というキーがありません。それでも新しく出来上がるデータには北海道の列が追加されます。ただし、道内店舗の平均予算、口コミ数などの情報はないため、欠損値が代入されます。</p>
<div class="figure" style="text-align: center"><span id="fig:full-join"></span>
<img src="Figures/Handling1/Merge_Full.png" alt="`full_join()`の仕組み" width="80%" />
<p class="caption">
Figure 12: <code>full_join()</code>の仕組み
</p>
</div>
<p>それでは実際、結果を確認してみましょう。今回は結合後、<code>RamenN</code>が大きい順で出力します。</p>
<pre class="r"><code>full_join(df2, df4, by = &quot;Pref&quot;) %&gt;%
  arrange(desc(RamenN)) # ぐるなびに登録された店舗の多い都道府県から出力</code></pre>
<pre><code>## # A tibble: 47 x 6
##    Pref     Budget_Mean ScoreN_Sum Score_Mean     N RamenN
##    &lt;chr&gt;          &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt;
##  1 東京都         1283.       1165       3.67  1000   3220
##  2 北海道           NA          NA      NA       NA   1454
##  3 大阪府         1203.        516       3.77  1000   1325
##  4 愛知県           NA          NA      NA       NA   1255
##  5 神奈川県       1239.        587       3.53  1000   1254
##  6 埼玉県         1147.        278       3.64  1000   1106
##  7 千葉県         1124.        259       3.72  1000   1098
##  8 福岡県           NA          NA      NA       NA    985
##  9 新潟県           NA          NA      NA       NA    705
## 10 静岡県           NA          NA      NA       NA    679
## # … with 37 more rows</code></pre>
<p><code>df2</code>にはなかった北海道や愛知県などの行ができました。そして、<code>df2</code>にはない情報はすべて欠損値 (<code>NA</code>)となりました。</p>
<p>続いて、<code>left_join()</code>ですが、これは先に指定したデータに存在するキーのみで結合を行います (図<a href="#fig:left-join">13</a>)。今回は<code>df2</code>が先に指定されていますが、<code>df2</code>のキーは<code>df4</code>のキーの部分集合であるため、<code>inner_join()</code>と同じ結果が得られます。</p>
<div class="figure" style="text-align: center"><span id="fig:left-join"></span>
<img src="Figures/Handling1/Merge_Left.png" alt="`left_join()`の仕組み" width="80%" />
<p class="caption">
Figure 13: <code>left_join()</code>の仕組み
</p>
</div>
<p>一方、<code>right_join()</code>は<code>left_join()</code>と逆の関数であり、後に指定したデータに存在するキーを基準に結合を行います (図<a href="#fig:right-join">14</a>)。後に指定された<code>df4</code>のキーは<code>df2</code>のキーを完全に含むので、<code>full_join()</code>と同じ結果が得られます。</p>
<div class="figure" style="text-align: center"><span id="fig:right-join"></span>
<img src="Figures/Handling1/Merge_Right.png" alt="`right_join()`の仕組み" width="80%" />
<p class="caption">
Figure 14: <code>right_join()</code>の仕組み
</p>
</div>
<p>これからは<code>df2</code>と<code>df4</code>を結合することになりますが、この2つのtibbleの大きさが異なります。<code>df2</code>は9つの都府県のみであるに対し、<code>df4</code>は47都道府県全てのデータが入っているからです。</p>
<p>ここまではキー変数が一つである場合についてのみ考えましたが、複数のキー変数が必要な場合もあります。たとえば、市区町村の人口・面積データと市区町村の投票率データを結合するとします。各自治体に与えられている「<a href="https://www.soumu.go.jp/denshijiti/code.html">全国地方公共団体コード</a>」が両データに含まれている場合は、このコードをキー変数として使えば問題ありませんが、市区町村名をキー変数として使わざる得ないケースもあるでしょう。しかし、キー変数が複数ある場合もあります。たとえば、府中市は東京都と広島県にありますし、太子町は大阪府と兵庫県にあります。この場合、市区町村名のみでケースをマッチングすると、重複されてマッチングされる恐れがあります。この場合はキー変数を増やすことで対処できます。たとえば、同じ都道府県なら同じ市区町村は存在しないでしょう<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>。キー変数を複数指定する方法は簡単です。たとえば、市区町村名変数が<code>Munip</code>、都道府県名変数が<code>Pref</code>なら<code>by = c("Munip", "Pref")</code>と指定するだけです。</p>
<p>最後に、キー変数以外の変数名が重複する場合について考えましょう。これはパネルデータを結合する時によく直面する問題です。同じ回答者に2回の調査を行った場合、回答者のIDでデータを結合することになります。ただし、それぞれのデータにおいて回答者の性別に関する変数が<code>F1</code>という名前の場合、どうなるでしょうか。同じデータの同じ名前の変数が複数あると、非常に扱いにくくなります。実際の結果を見てみましょう。</p>
<pre class="r"><code>Wave1_df &lt;- tibble(ID = c(1, 2, 3, 4, 5),
                   F1 = c(1, 1, 0, 0, 1),
                   F2 = c(18, 77, 37, 50, 41),
                   Q1 = c(1, 5, 2, 2, 3))

Wave2_df &lt;- tibble(ID = c(1, 3, 4, 6, 7),
                   F1 = c(1, 0, 0, 0, 1),
                   F2 = c(18, 37, 50, 20, 62),
                   Q1 = c(1, 2, 2, 5, 4))

full_join(Wave1_df, Wave2_df, by = &quot;ID&quot;)</code></pre>
<pre><code>## # A tibble: 7 x 7
##      ID  F1.x  F2.x  Q1.x  F1.y  F2.y  Q1.y
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1    18     1     1    18     1
## 2     2     1    77     5    NA    NA    NA
## 3     3     0    37     2     0    37     2
## 4     4     0    50     2     0    50     2
## 5     5     1    41     3    NA    NA    NA
## 6     6    NA    NA    NA     0    20     5
## 7     7    NA    NA    NA     1    62     4</code></pre>
<p>それぞれの変数名の後に<code>.x</code>と<code>.y</code>が付きます。この接尾辞 (suffix)は<code>suffix</code>引数を指定することで、分析側からカスタマイズ可能です。たとえば、接尾辞を<code>_W1</code>、<code>_W2</code>にしたい場合は</p>
<pre class="r"><code>full_join(Wave1_df, Wave2_df, by = &quot;ID&quot;, suffix = c(&quot;_W1&quot;, &quot;_W2&quot;))</code></pre>
<pre><code>## # A tibble: 7 x 7
##      ID F1_W1 F2_W1 Q1_W1 F1_W2 F2_W2 Q1_W2
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1    18     1     1    18     1
## 2     2     1    77     5    NA    NA    NA
## 3     3     0    37     2     0    37     2
## 4     4     0    50     2     0    50     2
## 5     5     1    41     3    NA    NA    NA
## 6     6    NA    NA    NA     0    20     5
## 7     7    NA    NA    NA     1    62     4</code></pre>
<p>のように、データ1とデータ2それぞれの接尾辞を指定するだけです。</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>実は<code>select(starts_with("X"), -ends_with("D"), ID)</code>のように順番を変えると<code>ID</code>は最後の列になりますが、とりあえず残ります。なぜなら、<code>select()</code>関数は左側から右側の方へコードを実行するからです。<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>実は<code>select.df[, c(2, 8, 9)]</code>でも前後にパイプ演算子を使うことは可能ですが、コードが読みにくくなるため、推奨しません。<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>サービスによってはこの機能が有料になっていたりもしますね。<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>たとえば、データ内に「ラーメンショップ」という店舗は3店舗あり、この場合、長さ3のベクトルが返されます。<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>データの出典は<a href="https://news.google.com/covid19/map">Google</a>です。<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>character型でなく、numeric型でも出来ます。<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>これらの図は<a href="https://r4ds.had.co.nz">Garrett Grolemund and Hadley Wickham. 2017. <em>R for Data Science: Import, Tidy, Transform, Visualize, and Model Data.</em> O’Reilly.</a>を参考にしました。<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>行政区も含むなら多くの政令指定都市にある「南区」とか「北区」が重複しますが、ここでは考えないことにしましょう。<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
</div>

</main>

        <footer>
            <p class="copyright text-muted" align = "center">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>. Customized by <a href="https://www.jaysong.net">Jaehyun Song</a></p>
        </footer>

        

        
    </body>

</html>

